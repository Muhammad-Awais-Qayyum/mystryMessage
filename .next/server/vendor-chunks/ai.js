"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ai";
exports.ids = ["vendor-chunks/ai"];
exports.modules = {

/***/ "(ssr)/./node_modules/ai/node_modules/nanoid/non-secure/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ai/node_modules/nanoid/non-secure/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   customAlphabet: () => (/* binding */ customAlphabet),\n/* harmony export */   nanoid: () => (/* binding */ nanoid)\n/* harmony export */ });\nlet urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nlet customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = ''\n    let i = size\n    while (i--) {\n      id += alphabet[(Math.random() * alphabet.length) | 0]\n    }\n    return id\n  }\n}\nlet nanoid = (size = 21) => {\n  let id = ''\n  let i = size\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0]\n  }\n  return id\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWkvbm9kZV9tb2R1bGVzL25hbm9pZC9ub24tc2VjdXJlL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FhLy4vbm9kZV9tb2R1bGVzL2FpL25vZGVfbW9kdWxlcy9uYW5vaWQvbm9uLXNlY3VyZS9pbmRleC5qcz80YWE0Il0sInNvdXJjZXNDb250ZW50IjpbImxldCB1cmxBbHBoYWJldCA9XG4gICd1c2VhbmRvbS0yNlQxOTgzNDBQWDc1cHhKQUNLVkVSWU1JTkRCVVNIV09MRl9HUVpiZmdoamtscXZ3eXpyaWN0J1xubGV0IGN1c3RvbUFscGhhYmV0ID0gKGFscGhhYmV0LCBkZWZhdWx0U2l6ZSA9IDIxKSA9PiB7XG4gIHJldHVybiAoc2l6ZSA9IGRlZmF1bHRTaXplKSA9PiB7XG4gICAgbGV0IGlkID0gJydcbiAgICBsZXQgaSA9IHNpemVcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBpZCArPSBhbHBoYWJldFsoTWF0aC5yYW5kb20oKSAqIGFscGhhYmV0Lmxlbmd0aCkgfCAwXVxuICAgIH1cbiAgICByZXR1cm4gaWRcbiAgfVxufVxubGV0IG5hbm9pZCA9IChzaXplID0gMjEpID0+IHtcbiAgbGV0IGlkID0gJydcbiAgbGV0IGkgPSBzaXplXG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZCArPSB1cmxBbHBoYWJldFsoTWF0aC5yYW5kb20oKSAqIDY0KSB8IDBdXG4gIH1cbiAgcmV0dXJuIGlkXG59XG5leHBvcnQgeyBuYW5vaWQsIGN1c3RvbUFscGhhYmV0IH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ai/node_modules/nanoid/non-secure/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ai/react/dist/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/ai/react/dist/index.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   experimental_useAssistant: () => (/* binding */ experimental_useAssistant),\n/* harmony export */   useAssistant: () => (/* binding */ useAssistant),\n/* harmony export */   useChat: () => (/* binding */ useChat),\n/* harmony export */   useCompletion: () => (/* binding */ useCompletion)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! swr */ \"(ssr)/./node_modules/swr/core/dist/index.mjs\");\n/* harmony import */ var nanoid_non_secure__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! nanoid/non-secure */ \"(ssr)/./node_modules/ai/node_modules/nanoid/non-secure/index.js\");\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(ssr)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* __next_internal_client_entry_do_not_use__ experimental_useAssistant,useAssistant,useChat,useCompletion auto */ // react/use-chat.ts\n\n\n// shared/generate-id.ts\n\nvar generateId = (0,nanoid_non_secure__WEBPACK_IMPORTED_MODULE_2__.customAlphabet)(\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\", 7);\n// shared/stream-parts.ts\nvar textStreamPart = {\n    code: \"0\",\n    name: \"text\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"text\" parts expect a string value.');\n        }\n        return {\n            type: \"text\",\n            value\n        };\n    }\n};\nvar functionCallStreamPart = {\n    code: \"1\",\n    name: \"function_call\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"function_call\" in value) || typeof value.function_call !== \"object\" || value.function_call == null || !(\"name\" in value.function_call) || !(\"arguments\" in value.function_call) || typeof value.function_call.name !== \"string\" || typeof value.function_call.arguments !== \"string\") {\n            throw new Error('\"function_call\" parts expect an object with a \"function_call\" property.');\n        }\n        return {\n            type: \"function_call\",\n            value\n        };\n    }\n};\nvar dataStreamPart = {\n    code: \"2\",\n    name: \"data\",\n    parse: (value)=>{\n        if (!Array.isArray(value)) {\n            throw new Error('\"data\" parts expect an array value.');\n        }\n        return {\n            type: \"data\",\n            value\n        };\n    }\n};\nvar errorStreamPart = {\n    code: \"3\",\n    name: \"error\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"error\" parts expect a string value.');\n        }\n        return {\n            type: \"error\",\n            value\n        };\n    }\n};\nvar assistantMessageStreamPart = {\n    code: \"4\",\n    name: \"assistant_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"id\" in value) || !(\"role\" in value) || !(\"content\" in value) || typeof value.id !== \"string\" || typeof value.role !== \"string\" || value.role !== \"assistant\" || !Array.isArray(value.content) || !value.content.every((item)=>item != null && typeof item === \"object\" && \"type\" in item && item.type === \"text\" && \"text\" in item && item.text != null && typeof item.text === \"object\" && \"value\" in item.text && typeof item.text.value === \"string\")) {\n            throw new Error('\"assistant_message\" parts expect an object with an \"id\", \"role\", and \"content\" property.');\n        }\n        return {\n            type: \"assistant_message\",\n            value\n        };\n    }\n};\nvar assistantControlDataStreamPart = {\n    code: \"5\",\n    name: \"assistant_control_data\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"threadId\" in value) || !(\"messageId\" in value) || typeof value.threadId !== \"string\" || typeof value.messageId !== \"string\") {\n            throw new Error('\"assistant_control_data\" parts expect an object with a \"threadId\" and \"messageId\" property.');\n        }\n        return {\n            type: \"assistant_control_data\",\n            value: {\n                threadId: value.threadId,\n                messageId: value.messageId\n            }\n        };\n    }\n};\nvar dataMessageStreamPart = {\n    code: \"6\",\n    name: \"data_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"role\" in value) || !(\"data\" in value) || typeof value.role !== \"string\" || value.role !== \"data\") {\n            throw new Error('\"data_message\" parts expect an object with a \"role\" and \"data\" property.');\n        }\n        return {\n            type: \"data_message\",\n            value\n        };\n    }\n};\nvar toolCallsStreamPart = {\n    code: \"7\",\n    name: \"tool_calls\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"tool_calls\" in value) || typeof value.tool_calls !== \"object\" || value.tool_calls == null || !Array.isArray(value.tool_calls) || value.tool_calls.some((tc)=>tc == null || typeof tc !== \"object\" || !(\"id\" in tc) || typeof tc.id !== \"string\" || !(\"type\" in tc) || typeof tc.type !== \"string\" || !(\"function\" in tc) || tc.function == null || typeof tc.function !== \"object\" || !(\"arguments\" in tc.function) || typeof tc.function.name !== \"string\" || typeof tc.function.arguments !== \"string\")) {\n            throw new Error('\"tool_calls\" parts expect an object with a ToolCallPayload.');\n        }\n        return {\n            type: \"tool_calls\",\n            value\n        };\n    }\n};\nvar messageAnnotationsStreamPart = {\n    code: \"8\",\n    name: \"message_annotations\",\n    parse: (value)=>{\n        if (!Array.isArray(value)) {\n            throw new Error('\"message_annotations\" parts expect an array value.');\n        }\n        return {\n            type: \"message_annotations\",\n            value\n        };\n    }\n};\nvar toolCallStreamPart = {\n    code: \"9\",\n    name: \"tool_call\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"toolCallId\" in value) || typeof value.toolCallId !== \"string\" || !(\"toolName\" in value) || typeof value.toolName !== \"string\" || !(\"args\" in value) || typeof value.args !== \"object\") {\n            throw new Error('\"tool_call\" parts expect an object with a \"toolCallId\", \"toolName\", and \"args\" property.');\n        }\n        return {\n            type: \"tool_call\",\n            value\n        };\n    }\n};\nvar toolResultStreamPart = {\n    code: \"a\",\n    name: \"tool_result\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"toolCallId\" in value) || typeof value.toolCallId !== \"string\" || !(\"toolName\" in value) || typeof value.toolName !== \"string\" || !(\"args\" in value) || typeof value.args !== \"object\" || !(\"result\" in value)) {\n            throw new Error('\"tool_result\" parts expect an object with a \"toolCallId\", \"toolName\", \"args\", and \"result\" property.');\n        }\n        return {\n            type: \"tool_result\",\n            value\n        };\n    }\n};\nvar streamParts = [\n    textStreamPart,\n    functionCallStreamPart,\n    dataStreamPart,\n    errorStreamPart,\n    assistantMessageStreamPart,\n    assistantControlDataStreamPart,\n    dataMessageStreamPart,\n    toolCallsStreamPart,\n    messageAnnotationsStreamPart,\n    toolCallStreamPart,\n    toolResultStreamPart\n];\nvar streamPartsByCode = {\n    [textStreamPart.code]: textStreamPart,\n    [functionCallStreamPart.code]: functionCallStreamPart,\n    [dataStreamPart.code]: dataStreamPart,\n    [errorStreamPart.code]: errorStreamPart,\n    [assistantMessageStreamPart.code]: assistantMessageStreamPart,\n    [assistantControlDataStreamPart.code]: assistantControlDataStreamPart,\n    [dataMessageStreamPart.code]: dataMessageStreamPart,\n    [toolCallsStreamPart.code]: toolCallsStreamPart,\n    [messageAnnotationsStreamPart.code]: messageAnnotationsStreamPart,\n    [toolCallStreamPart.code]: toolCallStreamPart,\n    [toolResultStreamPart.code]: toolResultStreamPart\n};\nvar StreamStringPrefixes = {\n    [textStreamPart.name]: textStreamPart.code,\n    [functionCallStreamPart.name]: functionCallStreamPart.code,\n    [dataStreamPart.name]: dataStreamPart.code,\n    [errorStreamPart.name]: errorStreamPart.code,\n    [assistantMessageStreamPart.name]: assistantMessageStreamPart.code,\n    [assistantControlDataStreamPart.name]: assistantControlDataStreamPart.code,\n    [dataMessageStreamPart.name]: dataMessageStreamPart.code,\n    [toolCallsStreamPart.name]: toolCallsStreamPart.code,\n    [messageAnnotationsStreamPart.name]: messageAnnotationsStreamPart.code,\n    [toolCallStreamPart.name]: toolCallStreamPart.code,\n    [toolResultStreamPart.name]: toolResultStreamPart.code\n};\nvar validCodes = streamParts.map((part)=>part.code);\nvar parseStreamPart = (line)=>{\n    const firstSeparatorIndex = line.indexOf(\":\");\n    if (firstSeparatorIndex === -1) {\n        throw new Error(\"Failed to parse stream string. No separator found.\");\n    }\n    const prefix = line.slice(0, firstSeparatorIndex);\n    if (!validCodes.includes(prefix)) {\n        throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n    }\n    const code = prefix;\n    const textValue = line.slice(firstSeparatorIndex + 1);\n    const jsonValue = JSON.parse(textValue);\n    return streamPartsByCode[code].parse(jsonValue);\n};\n// shared/read-data-stream.ts\nvar NEWLINE = \"\\n\".charCodeAt(0);\nfunction concatChunks(chunks, totalLength) {\n    const concatenatedChunks = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const chunk of chunks){\n        concatenatedChunks.set(chunk, offset);\n        offset += chunk.length;\n    }\n    chunks.length = 0;\n    return concatenatedChunks;\n}\nasync function* readDataStream(reader, { isAborted } = {}) {\n    const decoder = new TextDecoder();\n    const chunks = [];\n    let totalLength = 0;\n    while(true){\n        const { value } = await reader.read();\n        if (value) {\n            chunks.push(value);\n            totalLength += value.length;\n            if (value[value.length - 1] !== NEWLINE) {\n                continue;\n            }\n        }\n        if (chunks.length === 0) {\n            break;\n        }\n        const concatenatedChunks = concatChunks(chunks, totalLength);\n        totalLength = 0;\n        const streamParts2 = decoder.decode(concatenatedChunks, {\n            stream: true\n        }).split(\"\\n\").filter((line)=>line !== \"\").map(parseStreamPart);\n        for (const streamPart of streamParts2){\n            yield streamPart;\n        }\n        if (isAborted == null ? void 0 : isAborted()) {\n            reader.cancel();\n            break;\n        }\n    }\n}\n// shared/parse-complex-response.ts\nfunction assignAnnotationsToMessage(message, annotations) {\n    if (!message || !annotations || !annotations.length) return message;\n    return {\n        ...message,\n        annotations: [\n            ...annotations\n        ]\n    };\n}\nasync function parseComplexResponse({ reader, abortControllerRef, update, onFinish, generateId: generateId2 = generateId, getCurrentDate = ()=>/* @__PURE__ */ new Date() }) {\n    const createdAt = getCurrentDate();\n    const prefixMap = {\n        data: []\n    };\n    let message_annotations = void 0;\n    for await (const { type, value } of readDataStream(reader, {\n        isAborted: ()=>(abortControllerRef == null ? void 0 : abortControllerRef.current) === null\n    })){\n        if (type === \"text\") {\n            if (prefixMap[\"text\"]) {\n                prefixMap[\"text\"] = {\n                    ...prefixMap[\"text\"],\n                    content: (prefixMap[\"text\"].content || \"\") + value\n                };\n            } else {\n                prefixMap[\"text\"] = {\n                    id: generateId2(),\n                    role: \"assistant\",\n                    content: value,\n                    createdAt\n                };\n            }\n        }\n        if (type === \"tool_call\") {\n            if (prefixMap.text == null) {\n                prefixMap.text = {\n                    id: generateId2(),\n                    role: \"assistant\",\n                    content: \"\",\n                    createdAt\n                };\n            }\n            if (prefixMap.text.toolInvocations == null) {\n                prefixMap.text.toolInvocations = [];\n            }\n            prefixMap.text.toolInvocations.push(value);\n        } else if (type === \"tool_result\") {\n            if (prefixMap.text == null) {\n                prefixMap.text = {\n                    id: generateId2(),\n                    role: \"assistant\",\n                    content: \"\",\n                    createdAt\n                };\n            }\n            if (prefixMap.text.toolInvocations == null) {\n                prefixMap.text.toolInvocations = [];\n            }\n            const toolInvocationIndex = prefixMap.text.toolInvocations.findIndex((invocation)=>invocation.toolCallId === value.toolCallId);\n            if (toolInvocationIndex !== -1) {\n                prefixMap.text.toolInvocations[toolInvocationIndex] = value;\n            } else {\n                prefixMap.text.toolInvocations.push(value);\n            }\n        }\n        let functionCallMessage = null;\n        if (type === \"function_call\") {\n            prefixMap[\"function_call\"] = {\n                id: generateId2(),\n                role: \"assistant\",\n                content: \"\",\n                function_call: value.function_call,\n                name: value.function_call.name,\n                createdAt\n            };\n            functionCallMessage = prefixMap[\"function_call\"];\n        }\n        let toolCallMessage = null;\n        if (type === \"tool_calls\") {\n            prefixMap[\"tool_calls\"] = {\n                id: generateId2(),\n                role: \"assistant\",\n                content: \"\",\n                tool_calls: value.tool_calls,\n                createdAt\n            };\n            toolCallMessage = prefixMap[\"tool_calls\"];\n        }\n        if (type === \"data\") {\n            prefixMap[\"data\"].push(...value);\n        }\n        let responseMessage = prefixMap[\"text\"];\n        if (type === \"message_annotations\") {\n            if (!message_annotations) {\n                message_annotations = [\n                    ...value\n                ];\n            } else {\n                message_annotations.push(...value);\n            }\n            functionCallMessage = assignAnnotationsToMessage(prefixMap[\"function_call\"], message_annotations);\n            toolCallMessage = assignAnnotationsToMessage(prefixMap[\"tool_calls\"], message_annotations);\n            responseMessage = assignAnnotationsToMessage(prefixMap[\"text\"], message_annotations);\n        }\n        if (message_annotations == null ? void 0 : message_annotations.length) {\n            const messagePrefixKeys = [\n                \"text\",\n                \"function_call\",\n                \"tool_calls\"\n            ];\n            messagePrefixKeys.forEach((key)=>{\n                if (prefixMap[key]) {\n                    prefixMap[key].annotations = [\n                        ...message_annotations\n                    ];\n                }\n            });\n        }\n        const merged = [\n            functionCallMessage,\n            toolCallMessage,\n            responseMessage\n        ].filter(Boolean).map((message)=>({\n                ...assignAnnotationsToMessage(message, message_annotations)\n            }));\n        update(merged, [\n            ...prefixMap[\"data\"]\n        ]);\n    }\n    onFinish == null ? void 0 : onFinish(prefixMap);\n    return {\n        messages: [\n            prefixMap.text,\n            prefixMap.function_call,\n            prefixMap.tool_calls\n        ].filter(Boolean),\n        data: prefixMap.data\n    };\n}\n// shared/utils.ts\nfunction createChunkDecoder(complex) {\n    const decoder = new TextDecoder();\n    if (!complex) {\n        return function(chunk) {\n            if (!chunk) return \"\";\n            return decoder.decode(chunk, {\n                stream: true\n            });\n        };\n    }\n    return function(chunk) {\n        const decoded = decoder.decode(chunk, {\n            stream: true\n        }).split(\"\\n\").filter((line)=>line !== \"\");\n        return decoded.map(parseStreamPart).filter(Boolean);\n    };\n}\n// shared/call-chat-api.ts\nasync function callChatApi({ api, messages, body, streamMode = \"stream-data\", credentials, headers, abortController, restoreMessagesOnFailure, onResponse, onUpdate, onFinish, generateId: generateId2 }) {\n    var _a;\n    const response = await fetch(api, {\n        method: \"POST\",\n        body: JSON.stringify({\n            messages,\n            ...body\n        }),\n        headers: {\n            \"Content-Type\": \"application/json\",\n            ...headers\n        },\n        signal: (_a = abortController == null ? void 0 : abortController()) == null ? void 0 : _a.signal,\n        credentials\n    }).catch((err)=>{\n        restoreMessagesOnFailure();\n        throw err;\n    });\n    if (onResponse) {\n        try {\n            await onResponse(response);\n        } catch (err) {\n            throw err;\n        }\n    }\n    if (!response.ok) {\n        restoreMessagesOnFailure();\n        throw new Error(await response.text() || \"Failed to fetch the chat response.\");\n    }\n    if (!response.body) {\n        throw new Error(\"The response body is empty.\");\n    }\n    const reader = response.body.getReader();\n    switch(streamMode){\n        case \"text\":\n            {\n                const decoder = createChunkDecoder();\n                const resultMessage = {\n                    id: generateId2(),\n                    createdAt: /* @__PURE__ */ new Date(),\n                    role: \"assistant\",\n                    content: \"\"\n                };\n                while(true){\n                    const { done, value } = await reader.read();\n                    if (done) {\n                        break;\n                    }\n                    resultMessage.content += decoder(value);\n                    resultMessage.id = generateId2();\n                    onUpdate([\n                        {\n                            ...resultMessage\n                        }\n                    ], []);\n                    if ((abortController == null ? void 0 : abortController()) === null) {\n                        reader.cancel();\n                        break;\n                    }\n                }\n                onFinish == null ? void 0 : onFinish(resultMessage);\n                return {\n                    messages: [\n                        resultMessage\n                    ],\n                    data: []\n                };\n            }\n        case \"stream-data\":\n            {\n                return await parseComplexResponse({\n                    reader,\n                    abortControllerRef: abortController != null ? {\n                        current: abortController()\n                    } : void 0,\n                    update: onUpdate,\n                    onFinish (prefixMap) {\n                        if (onFinish && prefixMap.text != null) {\n                            onFinish(prefixMap.text);\n                        }\n                    },\n                    generateId: generateId2\n                });\n            }\n        default:\n            {\n                const exhaustiveCheck = streamMode;\n                throw new Error(`Unknown stream mode: ${exhaustiveCheck}`);\n            }\n    }\n}\n// shared/process-chat-stream.ts\nasync function processChatStream({ getStreamedResponse: getStreamedResponse2, experimental_onFunctionCall, experimental_onToolCall, updateChatRequest, getCurrentMessages }) {\n    while(true){\n        const messagesAndDataOrJustMessage = await getStreamedResponse2();\n        if (\"messages\" in messagesAndDataOrJustMessage) {\n            let hasFollowingResponse = false;\n            for (const message of messagesAndDataOrJustMessage.messages){\n                if ((message.function_call === void 0 || typeof message.function_call === \"string\") && (message.tool_calls === void 0 || typeof message.tool_calls === \"string\")) {\n                    continue;\n                }\n                hasFollowingResponse = true;\n                if (experimental_onFunctionCall) {\n                    const functionCall = message.function_call;\n                    if (typeof functionCall !== \"object\") {\n                        console.warn(\"experimental_onFunctionCall should not be defined when using tools\");\n                        continue;\n                    }\n                    const functionCallResponse = await experimental_onFunctionCall(getCurrentMessages(), functionCall);\n                    if (functionCallResponse === void 0) {\n                        hasFollowingResponse = false;\n                        break;\n                    }\n                    updateChatRequest(functionCallResponse);\n                }\n                if (experimental_onToolCall) {\n                    const toolCalls = message.tool_calls;\n                    if (!Array.isArray(toolCalls) || toolCalls.some((toolCall)=>typeof toolCall !== \"object\")) {\n                        console.warn(\"experimental_onToolCall should not be defined when using tools\");\n                        continue;\n                    }\n                    const toolCallResponse = await experimental_onToolCall(getCurrentMessages(), toolCalls);\n                    if (toolCallResponse === void 0) {\n                        hasFollowingResponse = false;\n                        break;\n                    }\n                    updateChatRequest(toolCallResponse);\n                }\n            }\n            if (!hasFollowingResponse) {\n                break;\n            }\n        } else {\n            let fixFunctionCallArguments2 = function(response) {\n                for (const message of response.messages){\n                    if (message.tool_calls !== void 0) {\n                        for (const toolCall of message.tool_calls){\n                            if (typeof toolCall === \"object\") {\n                                if (toolCall.function.arguments && typeof toolCall.function.arguments !== \"string\") {\n                                    toolCall.function.arguments = JSON.stringify(toolCall.function.arguments);\n                                }\n                            }\n                        }\n                    }\n                    if (message.function_call !== void 0) {\n                        if (typeof message.function_call === \"object\") {\n                            if (message.function_call.arguments && typeof message.function_call.arguments !== \"string\") {\n                                message.function_call.arguments = JSON.stringify(message.function_call.arguments);\n                            }\n                        }\n                    }\n                }\n            };\n            var fixFunctionCallArguments = fixFunctionCallArguments2;\n            const streamedResponseMessage = messagesAndDataOrJustMessage;\n            if ((streamedResponseMessage.function_call === void 0 || typeof streamedResponseMessage.function_call === \"string\") && (streamedResponseMessage.tool_calls === void 0 || typeof streamedResponseMessage.tool_calls === \"string\")) {\n                break;\n            }\n            if (experimental_onFunctionCall) {\n                const functionCall = streamedResponseMessage.function_call;\n                if (!(typeof functionCall === \"object\")) {\n                    console.warn(\"experimental_onFunctionCall should not be defined when using tools\");\n                    continue;\n                }\n                const functionCallResponse = await experimental_onFunctionCall(getCurrentMessages(), functionCall);\n                if (functionCallResponse === void 0) break;\n                fixFunctionCallArguments2(functionCallResponse);\n                updateChatRequest(functionCallResponse);\n            }\n            if (experimental_onToolCall) {\n                const toolCalls = streamedResponseMessage.tool_calls;\n                if (!(typeof toolCalls === \"object\")) {\n                    console.warn(\"experimental_onToolCall should not be defined when using functions\");\n                    continue;\n                }\n                const toolCallResponse = await experimental_onToolCall(getCurrentMessages(), toolCalls);\n                if (toolCallResponse === void 0) break;\n                fixFunctionCallArguments2(toolCallResponse);\n                updateChatRequest(toolCallResponse);\n            }\n        }\n    }\n}\n// react/use-chat.ts\nvar getStreamedResponse = async (api, chatRequest, mutate, mutateStreamData, existingData, extraMetadataRef, messagesRef, abortControllerRef, generateId2, streamMode, onFinish, onResponse, sendExtraMessageFields)=>{\n    var _a, _b;\n    const previousMessages = messagesRef.current;\n    mutate(chatRequest.messages, false);\n    const constructedMessagesPayload = sendExtraMessageFields ? chatRequest.messages : chatRequest.messages.map(({ role, content, name, toolInvocations, function_call, tool_calls, tool_call_id })=>({\n            role,\n            content,\n            ...name !== void 0 && {\n                name\n            },\n            ...toolInvocations !== void 0 && {\n                toolInvocations\n            },\n            // outdated function/tool call handling (TODO deprecate):\n            tool_call_id,\n            ...function_call !== void 0 && {\n                function_call\n            },\n            ...tool_calls !== void 0 && {\n                tool_calls\n            }\n        }));\n    if (typeof api !== \"string\") {\n        const replyId = generateId2();\n        const createdAt = /* @__PURE__ */ new Date();\n        let responseMessage = {\n            id: replyId,\n            createdAt,\n            content: \"\",\n            role: \"assistant\"\n        };\n        async function readRow(promise) {\n            const { content, ui, next } = await promise;\n            responseMessage[\"content\"] = content;\n            responseMessage[\"ui\"] = await ui;\n            mutate([\n                ...chatRequest.messages,\n                {\n                    ...responseMessage\n                }\n            ], false);\n            if (next) {\n                await readRow(next);\n            }\n        }\n        try {\n            const promise = api({\n                messages: constructedMessagesPayload,\n                data: chatRequest.data\n            });\n            await readRow(promise);\n        } catch (e) {\n            mutate(previousMessages, false);\n            throw e;\n        }\n        if (onFinish) {\n            onFinish(responseMessage);\n        }\n        return responseMessage;\n    }\n    return await callChatApi({\n        api,\n        messages: constructedMessagesPayload,\n        body: {\n            data: chatRequest.data,\n            ...extraMetadataRef.current.body,\n            ...(_a = chatRequest.options) == null ? void 0 : _a.body,\n            ...chatRequest.functions !== void 0 && {\n                functions: chatRequest.functions\n            },\n            ...chatRequest.function_call !== void 0 && {\n                function_call: chatRequest.function_call\n            },\n            ...chatRequest.tools !== void 0 && {\n                tools: chatRequest.tools\n            },\n            ...chatRequest.tool_choice !== void 0 && {\n                tool_choice: chatRequest.tool_choice\n            }\n        },\n        streamMode,\n        credentials: extraMetadataRef.current.credentials,\n        headers: {\n            ...extraMetadataRef.current.headers,\n            ...(_b = chatRequest.options) == null ? void 0 : _b.headers\n        },\n        abortController: ()=>abortControllerRef.current,\n        restoreMessagesOnFailure () {\n            mutate(previousMessages, false);\n        },\n        onResponse,\n        onUpdate (merged, data) {\n            mutate([\n                ...chatRequest.messages,\n                ...merged\n            ], false);\n            mutateStreamData([\n                ...existingData || [],\n                ...data || []\n            ], false);\n        },\n        onFinish,\n        generateId: generateId2\n    });\n};\nfunction useChat({ api = \"/api/chat\", id, initialMessages, initialInput = \"\", sendExtraMessageFields, experimental_onFunctionCall, experimental_onToolCall, streamMode, onResponse, onFinish, onError, credentials, headers, body, generateId: generateId2 = generateId } = {}) {\n    const hookId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n    const idKey = id != null ? id : hookId;\n    const chatKey = typeof api === \"string\" ? [\n        api,\n        idKey\n    ] : idKey;\n    const [initialMessagesFallback] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const { data: messages, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"messages\"\n    ], null, {\n        fallbackData: initialMessages != null ? initialMessages : initialMessagesFallback\n    });\n    const { data: isLoading = false, mutate: mutateLoading } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"loading\"\n    ], null);\n    const { data: streamData, mutate: mutateStreamData } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"streamData\"\n    ], null);\n    const { data: error = void 0, mutate: setError } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"error\"\n    ], null);\n    const messagesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(messages || []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        messagesRef.current = messages || [];\n    }, [\n        messages\n    ]);\n    const abortControllerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const extraMetadataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        credentials,\n        headers,\n        body\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        extraMetadataRef.current = {\n            credentials,\n            headers,\n            body\n        };\n    }, [\n        credentials,\n        headers,\n        body\n    ]);\n    const triggerRequest = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (chatRequest)=>{\n        try {\n            mutateLoading(true);\n            setError(void 0);\n            const abortController = new AbortController();\n            abortControllerRef.current = abortController;\n            await processChatStream({\n                getStreamedResponse: ()=>getStreamedResponse(api, chatRequest, mutate, mutateStreamData, streamData, extraMetadataRef, messagesRef, abortControllerRef, generateId2, streamMode, onFinish, onResponse, sendExtraMessageFields),\n                experimental_onFunctionCall,\n                experimental_onToolCall,\n                updateChatRequest: (chatRequestParam)=>{\n                    chatRequest = chatRequestParam;\n                },\n                getCurrentMessages: ()=>messagesRef.current\n            });\n            abortControllerRef.current = null;\n        } catch (err) {\n            if (err.name === \"AbortError\") {\n                abortControllerRef.current = null;\n                return null;\n            }\n            if (onError && err instanceof Error) {\n                onError(err);\n            }\n            setError(err);\n        } finally{\n            mutateLoading(false);\n        }\n    }, [\n        mutate,\n        mutateLoading,\n        api,\n        extraMetadataRef,\n        onResponse,\n        onFinish,\n        onError,\n        setError,\n        mutateStreamData,\n        streamData,\n        streamMode,\n        sendExtraMessageFields,\n        experimental_onFunctionCall,\n        experimental_onToolCall,\n        messagesRef,\n        abortControllerRef,\n        generateId2\n    ]);\n    const append = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (message, { options, functions, function_call, tools, tool_choice, data } = {})=>{\n        if (!message.id) {\n            message.id = generateId2();\n        }\n        const chatRequest = {\n            messages: messagesRef.current.concat(message),\n            options,\n            data,\n            ...functions !== void 0 && {\n                functions\n            },\n            ...function_call !== void 0 && {\n                function_call\n            },\n            ...tools !== void 0 && {\n                tools\n            },\n            ...tool_choice !== void 0 && {\n                tool_choice\n            }\n        };\n        return triggerRequest(chatRequest);\n    }, [\n        triggerRequest,\n        generateId2\n    ]);\n    const reload = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ({ options, functions, function_call, tools, tool_choice } = {})=>{\n        if (messagesRef.current.length === 0) return null;\n        const lastMessage = messagesRef.current[messagesRef.current.length - 1];\n        if (lastMessage.role === \"assistant\") {\n            const chatRequest2 = {\n                messages: messagesRef.current.slice(0, -1),\n                options,\n                ...functions !== void 0 && {\n                    functions\n                },\n                ...function_call !== void 0 && {\n                    function_call\n                },\n                ...tools !== void 0 && {\n                    tools\n                },\n                ...tool_choice !== void 0 && {\n                    tool_choice\n                }\n            };\n            return triggerRequest(chatRequest2);\n        }\n        const chatRequest = {\n            messages: messagesRef.current,\n            options,\n            ...functions !== void 0 && {\n                functions\n            },\n            ...function_call !== void 0 && {\n                function_call\n            },\n            ...tools !== void 0 && {\n                tools\n            },\n            ...tool_choice !== void 0 && {\n                tool_choice\n            }\n        };\n        return triggerRequest(chatRequest);\n    }, [\n        triggerRequest\n    ]);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (abortControllerRef.current) {\n            abortControllerRef.current.abort();\n            abortControllerRef.current = null;\n        }\n    }, []);\n    const setMessages = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((messages2)=>{\n        mutate(messages2, false);\n        messagesRef.current = messages2;\n    }, [\n        mutate\n    ]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialInput);\n    const handleSubmit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e, options = {}, metadata)=>{\n        if (metadata) {\n            extraMetadataRef.current = {\n                ...extraMetadataRef.current,\n                ...metadata\n            };\n        }\n        e.preventDefault();\n        if (!input) return;\n        append({\n            content: input,\n            role: \"user\",\n            createdAt: /* @__PURE__ */ new Date()\n        }, options);\n        setInput(\"\");\n    }, [\n        input,\n        append\n    ]);\n    const handleInputChange = (e)=>{\n        setInput(e.target.value);\n    };\n    return {\n        messages: messages || [],\n        error,\n        append,\n        reload,\n        stop,\n        setMessages,\n        input,\n        setInput,\n        handleInputChange,\n        handleSubmit,\n        isLoading,\n        data: streamData,\n        experimental_addToolResult: ({ toolCallId, result })=>{\n            const updatedMessages = messagesRef.current.map((message, index, arr)=>// update the tool calls in the last assistant message:\n                index === arr.length - 1 && message.role === \"assistant\" && message.toolInvocations ? {\n                    ...message,\n                    toolInvocations: message.toolInvocations.map((toolInvocation)=>toolInvocation.toolCallId === toolCallId ? {\n                            ...toolInvocation,\n                            result\n                        } : toolInvocation)\n                } : message);\n            mutate(updatedMessages, false);\n            const lastMessage = updatedMessages[updatedMessages.length - 1];\n            if (lastMessage.role === \"assistant\" && lastMessage.toolInvocations && lastMessage.toolInvocations.length > 0 && lastMessage.toolInvocations.every((toolInvocation)=>\"result\" in toolInvocation)) {\n                triggerRequest({\n                    messages: updatedMessages\n                });\n            }\n        }\n    };\n}\n// react/use-completion.ts\n\n\n// shared/call-completion-api.ts\nasync function callCompletionApi({ api, prompt, credentials, headers, body, streamMode = \"stream-data\", setCompletion, setLoading, setError, setAbortController, onResponse, onFinish, onError, onData }) {\n    try {\n        setLoading(true);\n        setError(void 0);\n        const abortController = new AbortController();\n        setAbortController(abortController);\n        setCompletion(\"\");\n        const res = await fetch(api, {\n            method: \"POST\",\n            body: JSON.stringify({\n                prompt,\n                ...body\n            }),\n            credentials,\n            headers: {\n                \"Content-Type\": \"application/json\",\n                ...headers\n            },\n            signal: abortController.signal\n        }).catch((err)=>{\n            throw err;\n        });\n        if (onResponse) {\n            try {\n                await onResponse(res);\n            } catch (err) {\n                throw err;\n            }\n        }\n        if (!res.ok) {\n            throw new Error(await res.text() || \"Failed to fetch the chat response.\");\n        }\n        if (!res.body) {\n            throw new Error(\"The response body is empty.\");\n        }\n        let result = \"\";\n        const reader = res.body.getReader();\n        switch(streamMode){\n            case \"text\":\n                {\n                    const decoder = createChunkDecoder();\n                    while(true){\n                        const { done, value } = await reader.read();\n                        if (done) {\n                            break;\n                        }\n                        result += decoder(value);\n                        setCompletion(result);\n                        if (abortController === null) {\n                            reader.cancel();\n                            break;\n                        }\n                    }\n                    break;\n                }\n            case \"stream-data\":\n                {\n                    for await (const { type, value } of readDataStream(reader, {\n                        isAborted: ()=>abortController === null\n                    })){\n                        switch(type){\n                            case \"text\":\n                                {\n                                    result += value;\n                                    setCompletion(result);\n                                    break;\n                                }\n                            case \"data\":\n                                {\n                                    onData == null ? void 0 : onData(value);\n                                    break;\n                                }\n                        }\n                    }\n                    break;\n                }\n            default:\n                {\n                    const exhaustiveCheck = streamMode;\n                    throw new Error(`Unknown stream mode: ${exhaustiveCheck}`);\n                }\n        }\n        if (onFinish) {\n            onFinish(prompt, result);\n        }\n        setAbortController(null);\n        return result;\n    } catch (err) {\n        if (err.name === \"AbortError\") {\n            setAbortController(null);\n            return null;\n        }\n        if (err instanceof Error) {\n            if (onError) {\n                onError(err);\n            }\n        }\n        setError(err);\n    } finally{\n        setLoading(false);\n    }\n}\n// react/use-completion.ts\nfunction useCompletion({ api = \"/api/completion\", id, initialCompletion = \"\", initialInput = \"\", credentials, headers, body, streamMode, onResponse, onFinish, onError } = {}) {\n    const hookId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n    const completionId = id || hookId;\n    const { data, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        api,\n        completionId\n    ], null, {\n        fallbackData: initialCompletion\n    });\n    const { data: isLoading = false, mutate: mutateLoading } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        completionId,\n        \"loading\"\n    ], null);\n    const { data: streamData, mutate: mutateStreamData } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        completionId,\n        \"streamData\"\n    ], null);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const completion = data;\n    const [abortController, setAbortController] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const extraMetadataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        credentials,\n        headers,\n        body\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        extraMetadataRef.current = {\n            credentials,\n            headers,\n            body\n        };\n    }, [\n        credentials,\n        headers,\n        body\n    ]);\n    const triggerRequest = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (prompt, options)=>callCompletionApi({\n            api,\n            prompt,\n            credentials: extraMetadataRef.current.credentials,\n            headers: {\n                ...extraMetadataRef.current.headers,\n                ...options == null ? void 0 : options.headers\n            },\n            body: {\n                ...extraMetadataRef.current.body,\n                ...options == null ? void 0 : options.body\n            },\n            streamMode,\n            setCompletion: (completion2)=>mutate(completion2, false),\n            setLoading: mutateLoading,\n            setError,\n            setAbortController,\n            onResponse,\n            onFinish,\n            onError,\n            onData: (data2)=>{\n                mutateStreamData([\n                    ...streamData || [],\n                    ...data2 || []\n                ], false);\n            }\n        }), [\n        mutate,\n        mutateLoading,\n        api,\n        extraMetadataRef,\n        setAbortController,\n        onResponse,\n        onFinish,\n        onError,\n        setError,\n        streamData,\n        streamMode,\n        mutateStreamData\n    ]);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (abortController) {\n            abortController.abort();\n            setAbortController(null);\n        }\n    }, [\n        abortController\n    ]);\n    const setCompletion = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((completion2)=>{\n        mutate(completion2, false);\n    }, [\n        mutate\n    ]);\n    const complete = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (prompt, options)=>{\n        return triggerRequest(prompt, options);\n    }, [\n        triggerRequest\n    ]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialInput);\n    const handleSubmit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        e.preventDefault();\n        if (!input) return;\n        return complete(input);\n    }, [\n        input,\n        complete\n    ]);\n    const handleInputChange = (e)=>{\n        setInput(e.target.value);\n    };\n    return {\n        completion,\n        complete,\n        error,\n        setCompletion,\n        stop,\n        input,\n        setInput,\n        handleInputChange,\n        handleSubmit,\n        isLoading,\n        data: streamData\n    };\n}\n// react/use-assistant.ts\n\n\nfunction useAssistant({ api, threadId: threadIdParam, credentials, headers, body, onError }) {\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const [threadId, setThreadId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"awaiting_message\");\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const handleInputChange = (event)=>{\n        setInput(event.target.value);\n    };\n    const abortControllerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (abortControllerRef.current) {\n            abortControllerRef.current.abort();\n            abortControllerRef.current = null;\n        }\n    }, []);\n    const append = async (message, requestOptions)=>{\n        var _a;\n        setStatus(\"in_progress\");\n        setMessages((messages2)=>{\n            var _a2;\n            return [\n                ...messages2,\n                {\n                    ...message,\n                    id: (_a2 = message.id) != null ? _a2 : generateId()\n                }\n            ];\n        });\n        setInput(\"\");\n        const abortController = new AbortController();\n        try {\n            abortControllerRef.current = abortController;\n            const result = await fetch(api, {\n                method: \"POST\",\n                credentials,\n                signal: abortController.signal,\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...headers\n                },\n                body: JSON.stringify({\n                    ...body,\n                    // always use user-provided threadId when available:\n                    threadId: (_a = threadIdParam != null ? threadIdParam : threadId) != null ? _a : null,\n                    message: message.content,\n                    // optional request data:\n                    data: requestOptions == null ? void 0 : requestOptions.data\n                })\n            });\n            if (result.body == null) {\n                throw new Error(\"The response body is empty.\");\n            }\n            for await (const { type, value } of readDataStream(result.body.getReader())){\n                switch(type){\n                    case \"assistant_message\":\n                        {\n                            setMessages((messages2)=>[\n                                    ...messages2,\n                                    {\n                                        id: value.id,\n                                        role: value.role,\n                                        content: value.content[0].text.value\n                                    }\n                                ]);\n                            break;\n                        }\n                    case \"text\":\n                        {\n                            setMessages((messages2)=>{\n                                const lastMessage = messages2[messages2.length - 1];\n                                return [\n                                    ...messages2.slice(0, messages2.length - 1),\n                                    {\n                                        id: lastMessage.id,\n                                        role: lastMessage.role,\n                                        content: lastMessage.content + value\n                                    }\n                                ];\n                            });\n                            break;\n                        }\n                    case \"data_message\":\n                        {\n                            setMessages((messages2)=>{\n                                var _a2;\n                                return [\n                                    ...messages2,\n                                    {\n                                        id: (_a2 = value.id) != null ? _a2 : generateId(),\n                                        role: \"data\",\n                                        content: \"\",\n                                        data: value.data\n                                    }\n                                ];\n                            });\n                            break;\n                        }\n                    case \"assistant_control_data\":\n                        {\n                            setThreadId(value.threadId);\n                            setMessages((messages2)=>{\n                                const lastMessage = messages2[messages2.length - 1];\n                                lastMessage.id = value.messageId;\n                                return [\n                                    ...messages2.slice(0, messages2.length - 1),\n                                    lastMessage\n                                ];\n                            });\n                            break;\n                        }\n                    case \"error\":\n                        {\n                            const errorObj = new Error(value);\n                            setError(errorObj);\n                            break;\n                        }\n                }\n            }\n        } catch (error2) {\n            if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_3__.isAbortError)(error2) && abortController.signal.aborted) {\n                abortControllerRef.current = null;\n                return;\n            }\n            if (onError && error2 instanceof Error) {\n                onError(error2);\n            }\n            setError(error2);\n        } finally{\n            abortControllerRef.current = null;\n            setStatus(\"awaiting_message\");\n        }\n    };\n    const submitMessage = async (event, requestOptions)=>{\n        var _a;\n        (_a = event == null ? void 0 : event.preventDefault) == null ? void 0 : _a.call(event);\n        if (input === \"\") {\n            return;\n        }\n        append({\n            role: \"user\",\n            content: input\n        }, requestOptions);\n    };\n    return {\n        append,\n        messages,\n        setMessages,\n        threadId,\n        input,\n        setInput,\n        handleInputChange,\n        submitMessage,\n        status,\n        error,\n        stop\n    };\n}\nvar experimental_useAssistant = useAssistant;\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWkvcmVhY3QvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7a0hBRUEsb0JBQW9CO0FBQ29EO0FBQy9DO0FBRXpCLHdCQUF3QjtBQUMyQjtBQUNuRCxJQUFJTyxhQUFhRCxpRUFBY0EsQ0FDN0Isa0VBQ0E7QUFHRix5QkFBeUI7QUFDekIsSUFBSUUsaUJBQWlCO0lBQ25CQyxNQUFNO0lBQ05DLE1BQU07SUFDTkMsT0FBTyxDQUFDQztRQUNOLElBQUksT0FBT0EsVUFBVSxVQUFVO1lBQzdCLE1BQU0sSUFBSUMsTUFBTTtRQUNsQjtRQUNBLE9BQU87WUFBRUMsTUFBTTtZQUFRRjtRQUFNO0lBQy9CO0FBQ0Y7QUFDQSxJQUFJRyx5QkFBeUI7SUFDM0JOLE1BQU07SUFDTkMsTUFBTTtJQUNOQyxPQUFPLENBQUNDO1FBQ04sSUFBSUEsU0FBUyxRQUFRLE9BQU9BLFVBQVUsWUFBWSxDQUFFLG9CQUFtQkEsS0FBSSxLQUFNLE9BQU9BLE1BQU1JLGFBQWEsS0FBSyxZQUFZSixNQUFNSSxhQUFhLElBQUksUUFBUSxDQUFFLFdBQVVKLE1BQU1JLGFBQWEsS0FBSyxDQUFFLGdCQUFlSixNQUFNSSxhQUFhLEtBQUssT0FBT0osTUFBTUksYUFBYSxDQUFDTixJQUFJLEtBQUssWUFBWSxPQUFPRSxNQUFNSSxhQUFhLENBQUNDLFNBQVMsS0FBSyxVQUFVO1lBQ3pVLE1BQU0sSUFBSUosTUFDUjtRQUVKO1FBQ0EsT0FBTztZQUNMQyxNQUFNO1lBQ05GO1FBQ0Y7SUFDRjtBQUNGO0FBQ0EsSUFBSU0saUJBQWlCO0lBQ25CVCxNQUFNO0lBQ05DLE1BQU07SUFDTkMsT0FBTyxDQUFDQztRQUNOLElBQUksQ0FBQ08sTUFBTUMsT0FBTyxDQUFDUixRQUFRO1lBQ3pCLE1BQU0sSUFBSUMsTUFBTTtRQUNsQjtRQUNBLE9BQU87WUFBRUMsTUFBTTtZQUFRRjtRQUFNO0lBQy9CO0FBQ0Y7QUFDQSxJQUFJUyxrQkFBa0I7SUFDcEJaLE1B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TUFBTXRDLGNBQWMsS0FBSyxPQUFPLEtBQUssSUFBSW5GLEdBQUdnSSxJQUFJLENBQUNQO1FBQ2hGLElBQUkxQyxVQUFVLElBQUk7WUFDaEI7UUFDRjtRQUNBVCxPQUFPO1lBQUU1SyxNQUFNO1lBQVFDLFNBQVNvTDtRQUFNLEdBQUcyQztJQUMzQztJQUNBLE9BQU87UUFDTHBEO1FBQ0FwRjtRQUNBMkY7UUFDQTdLO1FBQ0ErSztRQUNBQztRQUNBSTtRQUNBMkM7UUFDQVI7UUFDQXREO1FBQ0FVO0lBQ0Y7QUFDRjtBQUNBLElBQUlzRCw0QkFBNEJiO0FBTTlCLENBQ0Ysa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWEvLi9ub2RlX21vZHVsZXMvYWkvcmVhY3QvZGlzdC9pbmRleC5tanM/MmJmYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuLy8gcmVhY3QvdXNlLWNoYXQudHNcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZUlkLCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgdXNlU1dSIGZyb20gXCJzd3JcIjtcblxuLy8gc2hhcmVkL2dlbmVyYXRlLWlkLnRzXG5pbXBvcnQgeyBjdXN0b21BbHBoYWJldCB9IGZyb20gXCJuYW5vaWQvbm9uLXNlY3VyZVwiO1xudmFyIGdlbmVyYXRlSWQgPSBjdXN0b21BbHBoYWJldChcbiAgXCIwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiLFxuICA3XG4pO1xuXG4vLyBzaGFyZWQvc3RyZWFtLXBhcnRzLnRzXG52YXIgdGV4dFN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiMFwiLFxuICBuYW1lOiBcInRleHRcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJ0ZXh0XCIgcGFydHMgZXhwZWN0IGEgc3RyaW5nIHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcInRleHRcIiwgdmFsdWUgfTtcbiAgfVxufTtcbnZhciBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjFcIixcbiAgbmFtZTogXCJmdW5jdGlvbl9jYWxsXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcImZ1bmN0aW9uX2NhbGxcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLmZ1bmN0aW9uX2NhbGwgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUuZnVuY3Rpb25fY2FsbCA9PSBudWxsIHx8ICEoXCJuYW1lXCIgaW4gdmFsdWUuZnVuY3Rpb25fY2FsbCkgfHwgIShcImFyZ3VtZW50c1wiIGluIHZhbHVlLmZ1bmN0aW9uX2NhbGwpIHx8IHR5cGVvZiB2YWx1ZS5mdW5jdGlvbl9jYWxsLm5hbWUgIT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImZ1bmN0aW9uX2NhbGxcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcImZ1bmN0aW9uX2NhbGxcIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJmdW5jdGlvbl9jYWxsXCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbn07XG52YXIgZGF0YVN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiMlwiLFxuICBuYW1lOiBcImRhdGFcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJkYXRhXCIgcGFydHMgZXhwZWN0IGFuIGFycmF5IHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcImRhdGFcIiwgdmFsdWUgfTtcbiAgfVxufTtcbnZhciBlcnJvclN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiM1wiLFxuICBuYW1lOiBcImVycm9yXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiZXJyb3JcIiBwYXJ0cyBleHBlY3QgYSBzdHJpbmcgdmFsdWUuJyk7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgdmFsdWUgfTtcbiAgfVxufTtcbnZhciBhc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCI0XCIsXG4gIG5hbWU6IFwiYXNzaXN0YW50X21lc3NhZ2VcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwiaWRcIiBpbiB2YWx1ZSkgfHwgIShcInJvbGVcIiBpbiB2YWx1ZSkgfHwgIShcImNvbnRlbnRcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLmlkICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZS5yb2xlICE9PSBcInN0cmluZ1wiIHx8IHZhbHVlLnJvbGUgIT09IFwiYXNzaXN0YW50XCIgfHwgIUFycmF5LmlzQXJyYXkodmFsdWUuY29udGVudCkgfHwgIXZhbHVlLmNvbnRlbnQuZXZlcnkoXG4gICAgICAoaXRlbSkgPT4gaXRlbSAhPSBudWxsICYmIHR5cGVvZiBpdGVtID09PSBcIm9iamVjdFwiICYmIFwidHlwZVwiIGluIGl0ZW0gJiYgaXRlbS50eXBlID09PSBcInRleHRcIiAmJiBcInRleHRcIiBpbiBpdGVtICYmIGl0ZW0udGV4dCAhPSBudWxsICYmIHR5cGVvZiBpdGVtLnRleHQgPT09IFwib2JqZWN0XCIgJiYgXCJ2YWx1ZVwiIGluIGl0ZW0udGV4dCAmJiB0eXBlb2YgaXRlbS50ZXh0LnZhbHVlID09PSBcInN0cmluZ1wiXG4gICAgKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJhc3Npc3RhbnRfbWVzc2FnZVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhbiBcImlkXCIsIFwicm9sZVwiLCBhbmQgXCJjb250ZW50XCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYXNzaXN0YW50X21lc3NhZ2VcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxufTtcbnZhciBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiNVwiLFxuICBuYW1lOiBcImFzc2lzdGFudF9jb250cm9sX2RhdGFcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwidGhyZWFkSWRcIiBpbiB2YWx1ZSkgfHwgIShcIm1lc3NhZ2VJZFwiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUudGhyZWFkSWQgIT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlLm1lc3NhZ2VJZCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJhc3Npc3RhbnRfY29udHJvbF9kYXRhXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJ0aHJlYWRJZFwiIGFuZCBcIm1lc3NhZ2VJZFwiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImFzc2lzdGFudF9jb250cm9sX2RhdGFcIixcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIHRocmVhZElkOiB2YWx1ZS50aHJlYWRJZCxcbiAgICAgICAgbWVzc2FnZUlkOiB2YWx1ZS5tZXNzYWdlSWRcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xudmFyIGRhdGFNZXNzYWdlU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCI2XCIsXG4gIG5hbWU6IFwiZGF0YV9tZXNzYWdlXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcInJvbGVcIiBpbiB2YWx1ZSkgfHwgIShcImRhdGFcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLnJvbGUgIT09IFwic3RyaW5nXCIgfHwgdmFsdWUucm9sZSAhPT0gXCJkYXRhXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiZGF0YV9tZXNzYWdlXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJyb2xlXCIgYW5kIFwiZGF0YVwiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImRhdGFfbWVzc2FnZVwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG59O1xudmFyIHRvb2xDYWxsc1N0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiN1wiLFxuICBuYW1lOiBcInRvb2xfY2FsbHNcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwidG9vbF9jYWxsc1wiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUudG9vbF9jYWxscyAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZS50b29sX2NhbGxzID09IG51bGwgfHwgIUFycmF5LmlzQXJyYXkodmFsdWUudG9vbF9jYWxscykgfHwgdmFsdWUudG9vbF9jYWxscy5zb21lKFxuICAgICAgKHRjKSA9PiB0YyA9PSBudWxsIHx8IHR5cGVvZiB0YyAhPT0gXCJvYmplY3RcIiB8fCAhKFwiaWRcIiBpbiB0YykgfHwgdHlwZW9mIHRjLmlkICE9PSBcInN0cmluZ1wiIHx8ICEoXCJ0eXBlXCIgaW4gdGMpIHx8IHR5cGVvZiB0Yy50eXBlICE9PSBcInN0cmluZ1wiIHx8ICEoXCJmdW5jdGlvblwiIGluIHRjKSB8fCB0Yy5mdW5jdGlvbiA9PSBudWxsIHx8IHR5cGVvZiB0Yy5mdW5jdGlvbiAhPT0gXCJvYmplY3RcIiB8fCAhKFwiYXJndW1lbnRzXCIgaW4gdGMuZnVuY3Rpb24pIHx8IHR5cGVvZiB0Yy5mdW5jdGlvbi5uYW1lICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB0Yy5mdW5jdGlvbi5hcmd1bWVudHMgIT09IFwic3RyaW5nXCJcbiAgICApKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcInRvb2xfY2FsbHNcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBUb29sQ2FsbFBheWxvYWQuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidG9vbF9jYWxsc1wiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG59O1xudmFyIG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiOFwiLFxuICBuYW1lOiBcIm1lc3NhZ2VfYW5ub3RhdGlvbnNcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJtZXNzYWdlX2Fubm90YXRpb25zXCIgcGFydHMgZXhwZWN0IGFuIGFycmF5IHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcIm1lc3NhZ2VfYW5ub3RhdGlvbnNcIiwgdmFsdWUgfTtcbiAgfVxufTtcbnZhciB0b29sQ2FsbFN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiOVwiLFxuICBuYW1lOiBcInRvb2xfY2FsbFwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJ0b29sQ2FsbElkXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS50b29sQ2FsbElkICE9PSBcInN0cmluZ1wiIHx8ICEoXCJ0b29sTmFtZVwiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUudG9vbE5hbWUgIT09IFwic3RyaW5nXCIgfHwgIShcImFyZ3NcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLmFyZ3MgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1widG9vbF9jYWxsXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJ0b29sQ2FsbElkXCIsIFwidG9vbE5hbWVcIiwgYW5kIFwiYXJnc1wiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInRvb2xfY2FsbFwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG59O1xudmFyIHRvb2xSZXN1bHRTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcImFcIixcbiAgbmFtZTogXCJ0b29sX3Jlc3VsdFwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJ0b29sQ2FsbElkXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS50b29sQ2FsbElkICE9PSBcInN0cmluZ1wiIHx8ICEoXCJ0b29sTmFtZVwiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUudG9vbE5hbWUgIT09IFwic3RyaW5nXCIgfHwgIShcImFyZ3NcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLmFyZ3MgIT09IFwib2JqZWN0XCIgfHwgIShcInJlc3VsdFwiIGluIHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJ0b29sX3Jlc3VsdFwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwidG9vbENhbGxJZFwiLCBcInRvb2xOYW1lXCIsIFwiYXJnc1wiLCBhbmQgXCJyZXN1bHRcIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ0b29sX3Jlc3VsdFwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG59O1xudmFyIHN0cmVhbVBhcnRzID0gW1xuICB0ZXh0U3RyZWFtUGFydCxcbiAgZnVuY3Rpb25DYWxsU3RyZWFtUGFydCxcbiAgZGF0YVN0cmVhbVBhcnQsXG4gIGVycm9yU3RyZWFtUGFydCxcbiAgYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQsXG4gIGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydCxcbiAgZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0LFxuICB0b29sQ2FsbHNTdHJlYW1QYXJ0LFxuICBtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0LFxuICB0b29sQ2FsbFN0cmVhbVBhcnQsXG4gIHRvb2xSZXN1bHRTdHJlYW1QYXJ0XG5dO1xudmFyIHN0cmVhbVBhcnRzQnlDb2RlID0ge1xuICBbdGV4dFN0cmVhbVBhcnQuY29kZV06IHRleHRTdHJlYW1QYXJ0LFxuICBbZnVuY3Rpb25DYWxsU3RyZWFtUGFydC5jb2RlXTogZnVuY3Rpb25DYWxsU3RyZWFtUGFydCxcbiAgW2RhdGFTdHJlYW1QYXJ0LmNvZGVdOiBkYXRhU3RyZWFtUGFydCxcbiAgW2Vycm9yU3RyZWFtUGFydC5jb2RlXTogZXJyb3JTdHJlYW1QYXJ0LFxuICBbYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQuY29kZV06IGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0LFxuICBbYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0LmNvZGVdOiBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQsXG4gIFtkYXRhTWVzc2FnZVN0cmVhbVBhcnQuY29kZV06IGRhdGFNZXNzYWdlU3RyZWFtUGFydCxcbiAgW3Rvb2xDYWxsc1N0cmVhbVBhcnQuY29kZV06IHRvb2xDYWxsc1N0cmVhbVBhcnQsXG4gIFttZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0LmNvZGVdOiBtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0LFxuICBbdG9vbENhbGxTdHJlYW1QYXJ0LmNvZGVdOiB0b29sQ2FsbFN0cmVhbVBhcnQsXG4gIFt0b29sUmVzdWx0U3RyZWFtUGFydC5jb2RlXTogdG9vbFJlc3VsdFN0cmVhbVBhcnRcbn07XG52YXIgU3RyZWFtU3RyaW5nUHJlZml4ZXMgPSB7XG4gIFt0ZXh0U3RyZWFtUGFydC5uYW1lXTogdGV4dFN0cmVhbVBhcnQuY29kZSxcbiAgW2Z1bmN0aW9uQ2FsbFN0cmVhbVBhcnQubmFtZV06IGZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQuY29kZSxcbiAgW2RhdGFTdHJlYW1QYXJ0Lm5hbWVdOiBkYXRhU3RyZWFtUGFydC5jb2RlLFxuICBbZXJyb3JTdHJlYW1QYXJ0Lm5hbWVdOiBlcnJvclN0cmVhbVBhcnQuY29kZSxcbiAgW2Fzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0Lm5hbWVdOiBhc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydC5jb2RlLFxuICBbYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0Lm5hbWVdOiBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQuY29kZSxcbiAgW2RhdGFNZXNzYWdlU3RyZWFtUGFydC5uYW1lXTogZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0LmNvZGUsXG4gIFt0b29sQ2FsbHNTdHJlYW1QYXJ0Lm5hbWVdOiB0b29sQ2FsbHNTdHJlYW1QYXJ0LmNvZGUsXG4gIFttZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0Lm5hbWVdOiBtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0LmNvZGUsXG4gIFt0b29sQ2FsbFN0cmVhbVBhcnQubmFtZV06IHRvb2xDYWxsU3RyZWFtUGFydC5jb2RlLFxuICBbdG9vbFJlc3VsdFN0cmVhbVBhcnQubmFtZV06IHRvb2xSZXN1bHRTdHJlYW1QYXJ0LmNvZGVcbn07XG52YXIgdmFsaWRDb2RlcyA9IHN0cmVhbVBhcnRzLm1hcCgocGFydCkgPT4gcGFydC5jb2RlKTtcbnZhciBwYXJzZVN0cmVhbVBhcnQgPSAobGluZSkgPT4ge1xuICBjb25zdCBmaXJzdFNlcGFyYXRvckluZGV4ID0gbGluZS5pbmRleE9mKFwiOlwiKTtcbiAgaWYgKGZpcnN0U2VwYXJhdG9ySW5kZXggPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIHN0cmVhbSBzdHJpbmcuIE5vIHNlcGFyYXRvciBmb3VuZC5cIik7XG4gIH1cbiAgY29uc3QgcHJlZml4ID0gbGluZS5zbGljZSgwLCBmaXJzdFNlcGFyYXRvckluZGV4KTtcbiAgaWYgKCF2YWxpZENvZGVzLmluY2x1ZGVzKHByZWZpeCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBzdHJlYW0gc3RyaW5nLiBJbnZhbGlkIGNvZGUgJHtwcmVmaXh9LmApO1xuICB9XG4gIGNvbnN0IGNvZGUgPSBwcmVmaXg7XG4gIGNvbnN0IHRleHRWYWx1ZSA9IGxpbmUuc2xpY2UoZmlyc3RTZXBhcmF0b3JJbmRleCArIDEpO1xuICBjb25zdCBqc29uVmFsdWUgPSBKU09OLnBhcnNlKHRleHRWYWx1ZSk7XG4gIHJldHVybiBzdHJlYW1QYXJ0c0J5Q29kZVtjb2RlXS5wYXJzZShqc29uVmFsdWUpO1xufTtcblxuLy8gc2hhcmVkL3JlYWQtZGF0YS1zdHJlYW0udHNcbnZhciBORVdMSU5FID0gXCJcXG5cIi5jaGFyQ29kZUF0KDApO1xuZnVuY3Rpb24gY29uY2F0Q2h1bmtzKGNodW5rcywgdG90YWxMZW5ndGgpIHtcbiAgY29uc3QgY29uY2F0ZW5hdGVkQ2h1bmtzID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZm9yIChjb25zdCBjaHVuayBvZiBjaHVua3MpIHtcbiAgICBjb25jYXRlbmF0ZWRDaHVua3Muc2V0KGNodW5rLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBjaHVuay5sZW5ndGg7XG4gIH1cbiAgY2h1bmtzLmxlbmd0aCA9IDA7XG4gIHJldHVybiBjb25jYXRlbmF0ZWRDaHVua3M7XG59XG5hc3luYyBmdW5jdGlvbiogcmVhZERhdGFTdHJlYW0ocmVhZGVyLCB7XG4gIGlzQWJvcnRlZFxufSA9IHt9KSB7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgY29uc3QgY2h1bmtzID0gW107XG4gIGxldCB0b3RhbExlbmd0aCA9IDA7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGNodW5rcy5wdXNoKHZhbHVlKTtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IHZhbHVlLmxlbmd0aDtcbiAgICAgIGlmICh2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSAhPT0gTkVXTElORSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBjb25jYXRlbmF0ZWRDaHVua3MgPSBjb25jYXRDaHVua3MoY2h1bmtzLCB0b3RhbExlbmd0aCk7XG4gICAgdG90YWxMZW5ndGggPSAwO1xuICAgIGNvbnN0IHN0cmVhbVBhcnRzMiA9IGRlY29kZXIuZGVjb2RlKGNvbmNhdGVuYXRlZENodW5rcywgeyBzdHJlYW06IHRydWUgfSkuc3BsaXQoXCJcXG5cIikuZmlsdGVyKChsaW5lKSA9PiBsaW5lICE9PSBcIlwiKS5tYXAocGFyc2VTdHJlYW1QYXJ0KTtcbiAgICBmb3IgKGNvbnN0IHN0cmVhbVBhcnQgb2Ygc3RyZWFtUGFydHMyKSB7XG4gICAgICB5aWVsZCBzdHJlYW1QYXJ0O1xuICAgIH1cbiAgICBpZiAoaXNBYm9ydGVkID09IG51bGwgPyB2b2lkIDAgOiBpc0Fib3J0ZWQoKSkge1xuICAgICAgcmVhZGVyLmNhbmNlbCgpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbi8vIHNoYXJlZC9wYXJzZS1jb21wbGV4LXJlc3BvbnNlLnRzXG5mdW5jdGlvbiBhc3NpZ25Bbm5vdGF0aW9uc1RvTWVzc2FnZShtZXNzYWdlLCBhbm5vdGF0aW9ucykge1xuICBpZiAoIW1lc3NhZ2UgfHwgIWFubm90YXRpb25zIHx8ICFhbm5vdGF0aW9ucy5sZW5ndGgpXG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIHJldHVybiB7IC4uLm1lc3NhZ2UsIGFubm90YXRpb25zOiBbLi4uYW5ub3RhdGlvbnNdIH07XG59XG5hc3luYyBmdW5jdGlvbiBwYXJzZUNvbXBsZXhSZXNwb25zZSh7XG4gIHJlYWRlcixcbiAgYWJvcnRDb250cm9sbGVyUmVmLFxuICB1cGRhdGUsXG4gIG9uRmluaXNoLFxuICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMiA9IGdlbmVyYXRlSWQsXG4gIGdldEN1cnJlbnREYXRlID0gKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKClcbn0pIHtcbiAgY29uc3QgY3JlYXRlZEF0ID0gZ2V0Q3VycmVudERhdGUoKTtcbiAgY29uc3QgcHJlZml4TWFwID0ge1xuICAgIGRhdGE6IFtdXG4gIH07XG4gIGxldCBtZXNzYWdlX2Fubm90YXRpb25zID0gdm9pZCAwO1xuICBmb3IgYXdhaXQgKGNvbnN0IHsgdHlwZSwgdmFsdWUgfSBvZiByZWFkRGF0YVN0cmVhbShyZWFkZXIsIHtcbiAgICBpc0Fib3J0ZWQ6ICgpID0+IChhYm9ydENvbnRyb2xsZXJSZWYgPT0gbnVsbCA/IHZvaWQgMCA6IGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50KSA9PT0gbnVsbFxuICB9KSkge1xuICAgIGlmICh0eXBlID09PSBcInRleHRcIikge1xuICAgICAgaWYgKHByZWZpeE1hcFtcInRleHRcIl0pIHtcbiAgICAgICAgcHJlZml4TWFwW1widGV4dFwiXSA9IHtcbiAgICAgICAgICAuLi5wcmVmaXhNYXBbXCJ0ZXh0XCJdLFxuICAgICAgICAgIGNvbnRlbnQ6IChwcmVmaXhNYXBbXCJ0ZXh0XCJdLmNvbnRlbnQgfHwgXCJcIikgKyB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJlZml4TWFwW1widGV4dFwiXSA9IHtcbiAgICAgICAgICBpZDogZ2VuZXJhdGVJZDIoKSxcbiAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgIGNvbnRlbnQ6IHZhbHVlLFxuICAgICAgICAgIGNyZWF0ZWRBdFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJ0b29sX2NhbGxcIikge1xuICAgICAgaWYgKHByZWZpeE1hcC50ZXh0ID09IG51bGwpIHtcbiAgICAgICAgcHJlZml4TWFwLnRleHQgPSB7XG4gICAgICAgICAgaWQ6IGdlbmVyYXRlSWQyKCksXG4gICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgICAgIGNyZWF0ZWRBdFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKHByZWZpeE1hcC50ZXh0LnRvb2xJbnZvY2F0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgIHByZWZpeE1hcC50ZXh0LnRvb2xJbnZvY2F0aW9ucyA9IFtdO1xuICAgICAgfVxuICAgICAgcHJlZml4TWFwLnRleHQudG9vbEludm9jYXRpb25zLnB1c2godmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ0b29sX3Jlc3VsdFwiKSB7XG4gICAgICBpZiAocHJlZml4TWFwLnRleHQgPT0gbnVsbCkge1xuICAgICAgICBwcmVmaXhNYXAudGV4dCA9IHtcbiAgICAgICAgICBpZDogZ2VuZXJhdGVJZDIoKSxcbiAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgICAgICAgY3JlYXRlZEF0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAocHJlZml4TWFwLnRleHQudG9vbEludm9jYXRpb25zID09IG51bGwpIHtcbiAgICAgICAgcHJlZml4TWFwLnRleHQudG9vbEludm9jYXRpb25zID0gW107XG4gICAgICB9XG4gICAgICBjb25zdCB0b29sSW52b2NhdGlvbkluZGV4ID0gcHJlZml4TWFwLnRleHQudG9vbEludm9jYXRpb25zLmZpbmRJbmRleChcbiAgICAgICAgKGludm9jYXRpb24pID0+IGludm9jYXRpb24udG9vbENhbGxJZCA9PT0gdmFsdWUudG9vbENhbGxJZFxuICAgICAgKTtcbiAgICAgIGlmICh0b29sSW52b2NhdGlvbkluZGV4ICE9PSAtMSkge1xuICAgICAgICBwcmVmaXhNYXAudGV4dC50b29sSW52b2NhdGlvbnNbdG9vbEludm9jYXRpb25JbmRleF0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZWZpeE1hcC50ZXh0LnRvb2xJbnZvY2F0aW9ucy5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGZ1bmN0aW9uQ2FsbE1lc3NhZ2UgPSBudWxsO1xuICAgIGlmICh0eXBlID09PSBcImZ1bmN0aW9uX2NhbGxcIikge1xuICAgICAgcHJlZml4TWFwW1wiZnVuY3Rpb25fY2FsbFwiXSA9IHtcbiAgICAgICAgaWQ6IGdlbmVyYXRlSWQyKCksXG4gICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgICAgIGZ1bmN0aW9uX2NhbGw6IHZhbHVlLmZ1bmN0aW9uX2NhbGwsXG4gICAgICAgIG5hbWU6IHZhbHVlLmZ1bmN0aW9uX2NhbGwubmFtZSxcbiAgICAgICAgY3JlYXRlZEF0XG4gICAgICB9O1xuICAgICAgZnVuY3Rpb25DYWxsTWVzc2FnZSA9IHByZWZpeE1hcFtcImZ1bmN0aW9uX2NhbGxcIl07XG4gICAgfVxuICAgIGxldCB0b29sQ2FsbE1lc3NhZ2UgPSBudWxsO1xuICAgIGlmICh0eXBlID09PSBcInRvb2xfY2FsbHNcIikge1xuICAgICAgcHJlZml4TWFwW1widG9vbF9jYWxsc1wiXSA9IHtcbiAgICAgICAgaWQ6IGdlbmVyYXRlSWQyKCksXG4gICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgICAgIHRvb2xfY2FsbHM6IHZhbHVlLnRvb2xfY2FsbHMsXG4gICAgICAgIGNyZWF0ZWRBdFxuICAgICAgfTtcbiAgICAgIHRvb2xDYWxsTWVzc2FnZSA9IHByZWZpeE1hcFtcInRvb2xfY2FsbHNcIl07XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcImRhdGFcIikge1xuICAgICAgcHJlZml4TWFwW1wiZGF0YVwiXS5wdXNoKC4uLnZhbHVlKTtcbiAgICB9XG4gICAgbGV0IHJlc3BvbnNlTWVzc2FnZSA9IHByZWZpeE1hcFtcInRleHRcIl07XG4gICAgaWYgKHR5cGUgPT09IFwibWVzc2FnZV9hbm5vdGF0aW9uc1wiKSB7XG4gICAgICBpZiAoIW1lc3NhZ2VfYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgbWVzc2FnZV9hbm5vdGF0aW9ucyA9IFsuLi52YWx1ZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXNzYWdlX2Fubm90YXRpb25zLnB1c2goLi4udmFsdWUpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb25DYWxsTWVzc2FnZSA9IGFzc2lnbkFubm90YXRpb25zVG9NZXNzYWdlKFxuICAgICAgICBwcmVmaXhNYXBbXCJmdW5jdGlvbl9jYWxsXCJdLFxuICAgICAgICBtZXNzYWdlX2Fubm90YXRpb25zXG4gICAgICApO1xuICAgICAgdG9vbENhbGxNZXNzYWdlID0gYXNzaWduQW5ub3RhdGlvbnNUb01lc3NhZ2UoXG4gICAgICAgIHByZWZpeE1hcFtcInRvb2xfY2FsbHNcIl0sXG4gICAgICAgIG1lc3NhZ2VfYW5ub3RhdGlvbnNcbiAgICAgICk7XG4gICAgICByZXNwb25zZU1lc3NhZ2UgPSBhc3NpZ25Bbm5vdGF0aW9uc1RvTWVzc2FnZShcbiAgICAgICAgcHJlZml4TWFwW1widGV4dFwiXSxcbiAgICAgICAgbWVzc2FnZV9hbm5vdGF0aW9uc1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2VfYW5ub3RhdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG1lc3NhZ2VfYW5ub3RhdGlvbnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBtZXNzYWdlUHJlZml4S2V5cyA9IFtcbiAgICAgICAgXCJ0ZXh0XCIsXG4gICAgICAgIFwiZnVuY3Rpb25fY2FsbFwiLFxuICAgICAgICBcInRvb2xfY2FsbHNcIlxuICAgICAgXTtcbiAgICAgIG1lc3NhZ2VQcmVmaXhLZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBpZiAocHJlZml4TWFwW2tleV0pIHtcbiAgICAgICAgICBwcmVmaXhNYXBba2V5XS5hbm5vdGF0aW9ucyA9IFsuLi5tZXNzYWdlX2Fubm90YXRpb25zXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG1lcmdlZCA9IFtmdW5jdGlvbkNhbGxNZXNzYWdlLCB0b29sQ2FsbE1lc3NhZ2UsIHJlc3BvbnNlTWVzc2FnZV0uZmlsdGVyKEJvb2xlYW4pLm1hcCgobWVzc2FnZSkgPT4gKHtcbiAgICAgIC4uLmFzc2lnbkFubm90YXRpb25zVG9NZXNzYWdlKG1lc3NhZ2UsIG1lc3NhZ2VfYW5ub3RhdGlvbnMpXG4gICAgfSkpO1xuICAgIHVwZGF0ZShtZXJnZWQsIFsuLi5wcmVmaXhNYXBbXCJkYXRhXCJdXSk7XG4gIH1cbiAgb25GaW5pc2ggPT0gbnVsbCA/IHZvaWQgMCA6IG9uRmluaXNoKHByZWZpeE1hcCk7XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZXM6IFtcbiAgICAgIHByZWZpeE1hcC50ZXh0LFxuICAgICAgcHJlZml4TWFwLmZ1bmN0aW9uX2NhbGwsXG4gICAgICBwcmVmaXhNYXAudG9vbF9jYWxsc1xuICAgIF0uZmlsdGVyKEJvb2xlYW4pLFxuICAgIGRhdGE6IHByZWZpeE1hcC5kYXRhXG4gIH07XG59XG5cbi8vIHNoYXJlZC91dGlscy50c1xuZnVuY3Rpb24gY3JlYXRlQ2h1bmtEZWNvZGVyKGNvbXBsZXgpIHtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICBpZiAoIWNvbXBsZXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgIGlmICghY2h1bmspXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlKGNodW5rLCB7IHN0cmVhbTogdHJ1ZSB9KTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihjaHVuaykge1xuICAgIGNvbnN0IGRlY29kZWQgPSBkZWNvZGVyLmRlY29kZShjaHVuaywgeyBzdHJlYW06IHRydWUgfSkuc3BsaXQoXCJcXG5cIikuZmlsdGVyKChsaW5lKSA9PiBsaW5lICE9PSBcIlwiKTtcbiAgICByZXR1cm4gZGVjb2RlZC5tYXAocGFyc2VTdHJlYW1QYXJ0KS5maWx0ZXIoQm9vbGVhbik7XG4gIH07XG59XG5cbi8vIHNoYXJlZC9jYWxsLWNoYXQtYXBpLnRzXG5hc3luYyBmdW5jdGlvbiBjYWxsQ2hhdEFwaSh7XG4gIGFwaSxcbiAgbWVzc2FnZXMsXG4gIGJvZHksXG4gIHN0cmVhbU1vZGUgPSBcInN0cmVhbS1kYXRhXCIsXG4gIGNyZWRlbnRpYWxzLFxuICBoZWFkZXJzLFxuICBhYm9ydENvbnRyb2xsZXIsXG4gIHJlc3RvcmVNZXNzYWdlc09uRmFpbHVyZSxcbiAgb25SZXNwb25zZSxcbiAgb25VcGRhdGUsXG4gIG9uRmluaXNoLFxuICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMlxufSkge1xuICB2YXIgX2E7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYXBpLCB7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBtZXNzYWdlcyxcbiAgICAgIC4uLmJvZHlcbiAgICB9KSxcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIC4uLmhlYWRlcnNcbiAgICB9LFxuICAgIHNpZ25hbDogKF9hID0gYWJvcnRDb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBhYm9ydENvbnRyb2xsZXIoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnNpZ25hbCxcbiAgICBjcmVkZW50aWFsc1xuICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgcmVzdG9yZU1lc3NhZ2VzT25GYWlsdXJlKCk7XG4gICAgdGhyb3cgZXJyO1xuICB9KTtcbiAgaWYgKG9uUmVzcG9uc2UpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgb25SZXNwb25zZShyZXNwb25zZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG4gIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICByZXN0b3JlTWVzc2FnZXNPbkZhaWx1cmUoKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBhd2FpdCByZXNwb25zZS50ZXh0KCkgfHwgXCJGYWlsZWQgdG8gZmV0Y2ggdGhlIGNoYXQgcmVzcG9uc2UuXCJcbiAgICApO1xuICB9XG4gIGlmICghcmVzcG9uc2UuYm9keSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSByZXNwb25zZSBib2R5IGlzIGVtcHR5LlwiKTtcbiAgfVxuICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICBzd2l0Y2ggKHN0cmVhbU1vZGUpIHtcbiAgICBjYXNlIFwidGV4dFwiOiB7XG4gICAgICBjb25zdCBkZWNvZGVyID0gY3JlYXRlQ2h1bmtEZWNvZGVyKCk7XG4gICAgICBjb25zdCByZXN1bHRNZXNzYWdlID0ge1xuICAgICAgICBpZDogZ2VuZXJhdGVJZDIoKSxcbiAgICAgICAgY3JlYXRlZEF0OiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSxcbiAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgY29udGVudDogXCJcIlxuICAgICAgfTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0TWVzc2FnZS5jb250ZW50ICs9IGRlY29kZXIodmFsdWUpO1xuICAgICAgICByZXN1bHRNZXNzYWdlLmlkID0gZ2VuZXJhdGVJZDIoKTtcbiAgICAgICAgb25VcGRhdGUoW3sgLi4ucmVzdWx0TWVzc2FnZSB9XSwgW10pO1xuICAgICAgICBpZiAoKGFib3J0Q29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogYWJvcnRDb250cm9sbGVyKCkpID09PSBudWxsKSB7XG4gICAgICAgICAgcmVhZGVyLmNhbmNlbCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvbkZpbmlzaCA9PSBudWxsID8gdm9pZCAwIDogb25GaW5pc2gocmVzdWx0TWVzc2FnZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtZXNzYWdlczogW3Jlc3VsdE1lc3NhZ2VdLFxuICAgICAgICBkYXRhOiBbXVxuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcInN0cmVhbS1kYXRhXCI6IHtcbiAgICAgIHJldHVybiBhd2FpdCBwYXJzZUNvbXBsZXhSZXNwb25zZSh7XG4gICAgICAgIHJlYWRlcixcbiAgICAgICAgYWJvcnRDb250cm9sbGVyUmVmOiBhYm9ydENvbnRyb2xsZXIgIT0gbnVsbCA/IHsgY3VycmVudDogYWJvcnRDb250cm9sbGVyKCkgfSA6IHZvaWQgMCxcbiAgICAgICAgdXBkYXRlOiBvblVwZGF0ZSxcbiAgICAgICAgb25GaW5pc2gocHJlZml4TWFwKSB7XG4gICAgICAgICAgaWYgKG9uRmluaXNoICYmIHByZWZpeE1hcC50ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIG9uRmluaXNoKHByZWZpeE1hcC50ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQyXG4gICAgICB9KTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrID0gc3RyZWFtTW9kZTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzdHJlYW0gbW9kZTogJHtleGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgfVxuICB9XG59XG5cbi8vIHNoYXJlZC9wcm9jZXNzLWNoYXQtc3RyZWFtLnRzXG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzQ2hhdFN0cmVhbSh7XG4gIGdldFN0cmVhbWVkUmVzcG9uc2U6IGdldFN0cmVhbWVkUmVzcG9uc2UyLFxuICBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwsXG4gIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsLFxuICB1cGRhdGVDaGF0UmVxdWVzdCxcbiAgZ2V0Q3VycmVudE1lc3NhZ2VzXG59KSB7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgbWVzc2FnZXNBbmREYXRhT3JKdXN0TWVzc2FnZSA9IGF3YWl0IGdldFN0cmVhbWVkUmVzcG9uc2UyKCk7XG4gICAgaWYgKFwibWVzc2FnZXNcIiBpbiBtZXNzYWdlc0FuZERhdGFPckp1c3RNZXNzYWdlKSB7XG4gICAgICBsZXQgaGFzRm9sbG93aW5nUmVzcG9uc2UgPSBmYWxzZTtcbiAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlc0FuZERhdGFPckp1c3RNZXNzYWdlLm1lc3NhZ2VzKSB7XG4gICAgICAgIGlmICgobWVzc2FnZS5mdW5jdGlvbl9jYWxsID09PSB2b2lkIDAgfHwgdHlwZW9mIG1lc3NhZ2UuZnVuY3Rpb25fY2FsbCA9PT0gXCJzdHJpbmdcIikgJiYgKG1lc3NhZ2UudG9vbF9jYWxscyA9PT0gdm9pZCAwIHx8IHR5cGVvZiBtZXNzYWdlLnRvb2xfY2FsbHMgPT09IFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaGFzRm9sbG93aW5nUmVzcG9uc2UgPSB0cnVlO1xuICAgICAgICBpZiAoZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKSB7XG4gICAgICAgICAgY29uc3QgZnVuY3Rpb25DYWxsID0gbWVzc2FnZS5mdW5jdGlvbl9jYWxsO1xuICAgICAgICAgIGlmICh0eXBlb2YgZnVuY3Rpb25DYWxsICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgIFwiZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHNob3VsZCBub3QgYmUgZGVmaW5lZCB3aGVuIHVzaW5nIHRvb2xzXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZnVuY3Rpb25DYWxsUmVzcG9uc2UgPSBhd2FpdCBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwoXG4gICAgICAgICAgICBnZXRDdXJyZW50TWVzc2FnZXMoKSxcbiAgICAgICAgICAgIGZ1bmN0aW9uQ2FsbFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGZ1bmN0aW9uQ2FsbFJlc3BvbnNlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGhhc0ZvbGxvd2luZ1Jlc3BvbnNlID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdXBkYXRlQ2hhdFJlcXVlc3QoZnVuY3Rpb25DYWxsUmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHBlcmltZW50YWxfb25Ub29sQ2FsbCkge1xuICAgICAgICAgIGNvbnN0IHRvb2xDYWxscyA9IG1lc3NhZ2UudG9vbF9jYWxscztcbiAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodG9vbENhbGxzKSB8fCB0b29sQ2FsbHMuc29tZSgodG9vbENhbGwpID0+IHR5cGVvZiB0b29sQ2FsbCAhPT0gXCJvYmplY3RcIikpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgXCJleHBlcmltZW50YWxfb25Ub29sQ2FsbCBzaG91bGQgbm90IGJlIGRlZmluZWQgd2hlbiB1c2luZyB0b29sc1wiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHRvb2xDYWxsUmVzcG9uc2UgPSBhd2FpdCBleHBlcmltZW50YWxfb25Ub29sQ2FsbChnZXRDdXJyZW50TWVzc2FnZXMoKSwgdG9vbENhbGxzKTtcbiAgICAgICAgICBpZiAodG9vbENhbGxSZXNwb25zZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBoYXNGb2xsb3dpbmdSZXNwb25zZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZUNoYXRSZXF1ZXN0KHRvb2xDYWxsUmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWhhc0ZvbGxvd2luZ1Jlc3BvbnNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZml4RnVuY3Rpb25DYWxsQXJndW1lbnRzMiA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiByZXNwb25zZS5tZXNzYWdlcykge1xuICAgICAgICAgIGlmIChtZXNzYWdlLnRvb2xfY2FsbHMgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCB0b29sQ2FsbCBvZiBtZXNzYWdlLnRvb2xfY2FsbHMpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b29sQ2FsbCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGlmICh0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMgJiYgdHlwZW9mIHRvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgdG9vbENhbGwuZnVuY3Rpb24uYXJndW1lbnRzID0gSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgICAgIHRvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50c1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZnVuY3Rpb25fY2FsbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuZnVuY3Rpb25fY2FsbCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICBpZiAobWVzc2FnZS5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50cyAmJiB0eXBlb2YgbWVzc2FnZS5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50cyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZnVuY3Rpb25fY2FsbC5hcmd1bWVudHMgPSBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZnVuY3Rpb25fY2FsbC5hcmd1bWVudHNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdmFyIGZpeEZ1bmN0aW9uQ2FsbEFyZ3VtZW50cyA9IGZpeEZ1bmN0aW9uQ2FsbEFyZ3VtZW50czI7XG4gICAgICBjb25zdCBzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZSA9IG1lc3NhZ2VzQW5kRGF0YU9ySnVzdE1lc3NhZ2U7XG4gICAgICBpZiAoKHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlLmZ1bmN0aW9uX2NhbGwgPT09IHZvaWQgMCB8fCB0eXBlb2Ygc3RyZWFtZWRSZXNwb25zZU1lc3NhZ2UuZnVuY3Rpb25fY2FsbCA9PT0gXCJzdHJpbmdcIikgJiYgKHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlLnRvb2xfY2FsbHMgPT09IHZvaWQgMCB8fCB0eXBlb2Ygc3RyZWFtZWRSZXNwb25zZU1lc3NhZ2UudG9vbF9jYWxscyA9PT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKSB7XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbCA9IHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlLmZ1bmN0aW9uX2NhbGw7XG4gICAgICAgIGlmICghKHR5cGVvZiBmdW5jdGlvbkNhbGwgPT09IFwib2JqZWN0XCIpKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgXCJleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgc2hvdWxkIG5vdCBiZSBkZWZpbmVkIHdoZW4gdXNpbmcgdG9vbHNcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnVuY3Rpb25DYWxsUmVzcG9uc2UgPSBhd2FpdCBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwoZ2V0Q3VycmVudE1lc3NhZ2VzKCksIGZ1bmN0aW9uQ2FsbCk7XG4gICAgICAgIGlmIChmdW5jdGlvbkNhbGxSZXNwb25zZSA9PT0gdm9pZCAwKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBmaXhGdW5jdGlvbkNhbGxBcmd1bWVudHMyKGZ1bmN0aW9uQ2FsbFJlc3BvbnNlKTtcbiAgICAgICAgdXBkYXRlQ2hhdFJlcXVlc3QoZnVuY3Rpb25DYWxsUmVzcG9uc2UpO1xuICAgICAgfVxuICAgICAgaWYgKGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKSB7XG4gICAgICAgIGNvbnN0IHRvb2xDYWxscyA9IHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlLnRvb2xfY2FsbHM7XG4gICAgICAgIGlmICghKHR5cGVvZiB0b29sQ2FsbHMgPT09IFwib2JqZWN0XCIpKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgXCJleHBlcmltZW50YWxfb25Ub29sQ2FsbCBzaG91bGQgbm90IGJlIGRlZmluZWQgd2hlbiB1c2luZyBmdW5jdGlvbnNcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9vbENhbGxSZXNwb25zZSA9IGF3YWl0IGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKGdldEN1cnJlbnRNZXNzYWdlcygpLCB0b29sQ2FsbHMpO1xuICAgICAgICBpZiAodG9vbENhbGxSZXNwb25zZSA9PT0gdm9pZCAwKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBmaXhGdW5jdGlvbkNhbGxBcmd1bWVudHMyKHRvb2xDYWxsUmVzcG9uc2UpO1xuICAgICAgICB1cGRhdGVDaGF0UmVxdWVzdCh0b29sQ2FsbFJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gcmVhY3QvdXNlLWNoYXQudHNcbnZhciBnZXRTdHJlYW1lZFJlc3BvbnNlID0gYXN5bmMgKGFwaSwgY2hhdFJlcXVlc3QsIG11dGF0ZSwgbXV0YXRlU3RyZWFtRGF0YSwgZXhpc3RpbmdEYXRhLCBleHRyYU1ldGFkYXRhUmVmLCBtZXNzYWdlc1JlZiwgYWJvcnRDb250cm9sbGVyUmVmLCBnZW5lcmF0ZUlkMiwgc3RyZWFtTW9kZSwgb25GaW5pc2gsIG9uUmVzcG9uc2UsIHNlbmRFeHRyYU1lc3NhZ2VGaWVsZHMpID0+IHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgcHJldmlvdXNNZXNzYWdlcyA9IG1lc3NhZ2VzUmVmLmN1cnJlbnQ7XG4gIG11dGF0ZShjaGF0UmVxdWVzdC5tZXNzYWdlcywgZmFsc2UpO1xuICBjb25zdCBjb25zdHJ1Y3RlZE1lc3NhZ2VzUGF5bG9hZCA9IHNlbmRFeHRyYU1lc3NhZ2VGaWVsZHMgPyBjaGF0UmVxdWVzdC5tZXNzYWdlcyA6IGNoYXRSZXF1ZXN0Lm1lc3NhZ2VzLm1hcChcbiAgICAoe1xuICAgICAgcm9sZSxcbiAgICAgIGNvbnRlbnQsXG4gICAgICBuYW1lLFxuICAgICAgdG9vbEludm9jYXRpb25zLFxuICAgICAgZnVuY3Rpb25fY2FsbCxcbiAgICAgIHRvb2xfY2FsbHMsXG4gICAgICB0b29sX2NhbGxfaWRcbiAgICB9KSA9PiAoe1xuICAgICAgcm9sZSxcbiAgICAgIGNvbnRlbnQsXG4gICAgICAuLi5uYW1lICE9PSB2b2lkIDAgJiYgeyBuYW1lIH0sXG4gICAgICAuLi50b29sSW52b2NhdGlvbnMgIT09IHZvaWQgMCAmJiB7IHRvb2xJbnZvY2F0aW9ucyB9LFxuICAgICAgLy8gb3V0ZGF0ZWQgZnVuY3Rpb24vdG9vbCBjYWxsIGhhbmRsaW5nIChUT0RPIGRlcHJlY2F0ZSk6XG4gICAgICB0b29sX2NhbGxfaWQsXG4gICAgICAuLi5mdW5jdGlvbl9jYWxsICE9PSB2b2lkIDAgJiYgeyBmdW5jdGlvbl9jYWxsIH0sXG4gICAgICAuLi50b29sX2NhbGxzICE9PSB2b2lkIDAgJiYgeyB0b29sX2NhbGxzIH1cbiAgICB9KVxuICApO1xuICBpZiAodHlwZW9mIGFwaSAhPT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnN0IHJlcGx5SWQgPSBnZW5lcmF0ZUlkMigpO1xuICAgIGNvbnN0IGNyZWF0ZWRBdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgIGxldCByZXNwb25zZU1lc3NhZ2UgPSB7XG4gICAgICBpZDogcmVwbHlJZCxcbiAgICAgIGNyZWF0ZWRBdCxcbiAgICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgICByb2xlOiBcImFzc2lzdGFudFwiXG4gICAgfTtcbiAgICBhc3luYyBmdW5jdGlvbiByZWFkUm93KHByb21pc2UpIHtcbiAgICAgIGNvbnN0IHsgY29udGVudCwgdWksIG5leHQgfSA9IGF3YWl0IHByb21pc2U7XG4gICAgICByZXNwb25zZU1lc3NhZ2VbXCJjb250ZW50XCJdID0gY29udGVudDtcbiAgICAgIHJlc3BvbnNlTWVzc2FnZVtcInVpXCJdID0gYXdhaXQgdWk7XG4gICAgICBtdXRhdGUoWy4uLmNoYXRSZXF1ZXN0Lm1lc3NhZ2VzLCB7IC4uLnJlc3BvbnNlTWVzc2FnZSB9XSwgZmFsc2UpO1xuICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgYXdhaXQgcmVhZFJvdyhuZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHByb21pc2UgPSBhcGkoe1xuICAgICAgICBtZXNzYWdlczogY29uc3RydWN0ZWRNZXNzYWdlc1BheWxvYWQsXG4gICAgICAgIGRhdGE6IGNoYXRSZXF1ZXN0LmRhdGFcbiAgICAgIH0pO1xuICAgICAgYXdhaXQgcmVhZFJvdyhwcm9taXNlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBtdXRhdGUocHJldmlvdXNNZXNzYWdlcywgZmFsc2UpO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgaWYgKG9uRmluaXNoKSB7XG4gICAgICBvbkZpbmlzaChyZXNwb25zZU1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2VNZXNzYWdlO1xuICB9XG4gIHJldHVybiBhd2FpdCBjYWxsQ2hhdEFwaSh7XG4gICAgYXBpLFxuICAgIG1lc3NhZ2VzOiBjb25zdHJ1Y3RlZE1lc3NhZ2VzUGF5bG9hZCxcbiAgICBib2R5OiB7XG4gICAgICBkYXRhOiBjaGF0UmVxdWVzdC5kYXRhLFxuICAgICAgLi4uZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LmJvZHksXG4gICAgICAuLi4oX2EgPSBjaGF0UmVxdWVzdC5vcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2EuYm9keSxcbiAgICAgIC4uLmNoYXRSZXF1ZXN0LmZ1bmN0aW9ucyAhPT0gdm9pZCAwICYmIHtcbiAgICAgICAgZnVuY3Rpb25zOiBjaGF0UmVxdWVzdC5mdW5jdGlvbnNcbiAgICAgIH0sXG4gICAgICAuLi5jaGF0UmVxdWVzdC5mdW5jdGlvbl9jYWxsICE9PSB2b2lkIDAgJiYge1xuICAgICAgICBmdW5jdGlvbl9jYWxsOiBjaGF0UmVxdWVzdC5mdW5jdGlvbl9jYWxsXG4gICAgICB9LFxuICAgICAgLi4uY2hhdFJlcXVlc3QudG9vbHMgIT09IHZvaWQgMCAmJiB7XG4gICAgICAgIHRvb2xzOiBjaGF0UmVxdWVzdC50b29sc1xuICAgICAgfSxcbiAgICAgIC4uLmNoYXRSZXF1ZXN0LnRvb2xfY2hvaWNlICE9PSB2b2lkIDAgJiYge1xuICAgICAgICB0b29sX2Nob2ljZTogY2hhdFJlcXVlc3QudG9vbF9jaG9pY2VcbiAgICAgIH1cbiAgICB9LFxuICAgIHN0cmVhbU1vZGUsXG4gICAgY3JlZGVudGlhbHM6IGV4dHJhTWV0YWRhdGFSZWYuY3VycmVudC5jcmVkZW50aWFscyxcbiAgICBoZWFkZXJzOiB7XG4gICAgICAuLi5leHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQuaGVhZGVycyxcbiAgICAgIC4uLihfYiA9IGNoYXRSZXF1ZXN0Lm9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5oZWFkZXJzXG4gICAgfSxcbiAgICBhYm9ydENvbnRyb2xsZXI6ICgpID0+IGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50LFxuICAgIHJlc3RvcmVNZXNzYWdlc09uRmFpbHVyZSgpIHtcbiAgICAgIG11dGF0ZShwcmV2aW91c01lc3NhZ2VzLCBmYWxzZSk7XG4gICAgfSxcbiAgICBvblJlc3BvbnNlLFxuICAgIG9uVXBkYXRlKG1lcmdlZCwgZGF0YSkge1xuICAgICAgbXV0YXRlKFsuLi5jaGF0UmVxdWVzdC5tZXNzYWdlcywgLi4ubWVyZ2VkXSwgZmFsc2UpO1xuICAgICAgbXV0YXRlU3RyZWFtRGF0YShbLi4uZXhpc3RpbmdEYXRhIHx8IFtdLCAuLi5kYXRhIHx8IFtdXSwgZmFsc2UpO1xuICAgIH0sXG4gICAgb25GaW5pc2gsXG4gICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDJcbiAgfSk7XG59O1xuZnVuY3Rpb24gdXNlQ2hhdCh7XG4gIGFwaSA9IFwiL2FwaS9jaGF0XCIsXG4gIGlkLFxuICBpbml0aWFsTWVzc2FnZXMsXG4gIGluaXRpYWxJbnB1dCA9IFwiXCIsXG4gIHNlbmRFeHRyYU1lc3NhZ2VGaWVsZHMsXG4gIGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCxcbiAgZXhwZXJpbWVudGFsX29uVG9vbENhbGwsXG4gIHN0cmVhbU1vZGUsXG4gIG9uUmVzcG9uc2UsXG4gIG9uRmluaXNoLFxuICBvbkVycm9yLFxuICBjcmVkZW50aWFscyxcbiAgaGVhZGVycyxcbiAgYm9keSxcbiAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDIgPSBnZW5lcmF0ZUlkXG59ID0ge30pIHtcbiAgY29uc3QgaG9va0lkID0gdXNlSWQoKTtcbiAgY29uc3QgaWRLZXkgPSBpZCAhPSBudWxsID8gaWQgOiBob29rSWQ7XG4gIGNvbnN0IGNoYXRLZXkgPSB0eXBlb2YgYXBpID09PSBcInN0cmluZ1wiID8gW2FwaSwgaWRLZXldIDogaWRLZXk7XG4gIGNvbnN0IFtpbml0aWFsTWVzc2FnZXNGYWxsYmFja10gPSB1c2VTdGF0ZShbXSk7XG4gIGNvbnN0IHsgZGF0YTogbWVzc2FnZXMsIG11dGF0ZSB9ID0gdXNlU1dSKFxuICAgIFtjaGF0S2V5LCBcIm1lc3NhZ2VzXCJdLFxuICAgIG51bGwsXG4gICAgeyBmYWxsYmFja0RhdGE6IGluaXRpYWxNZXNzYWdlcyAhPSBudWxsID8gaW5pdGlhbE1lc3NhZ2VzIDogaW5pdGlhbE1lc3NhZ2VzRmFsbGJhY2sgfVxuICApO1xuICBjb25zdCB7IGRhdGE6IGlzTG9hZGluZyA9IGZhbHNlLCBtdXRhdGU6IG11dGF0ZUxvYWRpbmcgfSA9IHVzZVNXUihcbiAgICBbY2hhdEtleSwgXCJsb2FkaW5nXCJdLFxuICAgIG51bGxcbiAgKTtcbiAgY29uc3QgeyBkYXRhOiBzdHJlYW1EYXRhLCBtdXRhdGU6IG11dGF0ZVN0cmVhbURhdGEgfSA9IHVzZVNXUihbY2hhdEtleSwgXCJzdHJlYW1EYXRhXCJdLCBudWxsKTtcbiAgY29uc3QgeyBkYXRhOiBlcnJvciA9IHZvaWQgMCwgbXV0YXRlOiBzZXRFcnJvciB9ID0gdXNlU1dSKFtjaGF0S2V5LCBcImVycm9yXCJdLCBudWxsKTtcbiAgY29uc3QgbWVzc2FnZXNSZWYgPSB1c2VSZWYobWVzc2FnZXMgfHwgW10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIG1lc3NhZ2VzUmVmLmN1cnJlbnQgPSBtZXNzYWdlcyB8fCBbXTtcbiAgfSwgW21lc3NhZ2VzXSk7XG4gIGNvbnN0IGFib3J0Q29udHJvbGxlclJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgZXh0cmFNZXRhZGF0YVJlZiA9IHVzZVJlZih7XG4gICAgY3JlZGVudGlhbHMsXG4gICAgaGVhZGVycyxcbiAgICBib2R5XG4gIH0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGV4dHJhTWV0YWRhdGFSZWYuY3VycmVudCA9IHtcbiAgICAgIGNyZWRlbnRpYWxzLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGJvZHlcbiAgICB9O1xuICB9LCBbY3JlZGVudGlhbHMsIGhlYWRlcnMsIGJvZHldKTtcbiAgY29uc3QgdHJpZ2dlclJlcXVlc3QgPSB1c2VDYWxsYmFjayhcbiAgICBhc3luYyAoY2hhdFJlcXVlc3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG11dGF0ZUxvYWRpbmcodHJ1ZSk7XG4gICAgICAgIHNldEVycm9yKHZvaWQgMCk7XG4gICAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQgPSBhYm9ydENvbnRyb2xsZXI7XG4gICAgICAgIGF3YWl0IHByb2Nlc3NDaGF0U3RyZWFtKHtcbiAgICAgICAgICBnZXRTdHJlYW1lZFJlc3BvbnNlOiAoKSA9PiBnZXRTdHJlYW1lZFJlc3BvbnNlKFxuICAgICAgICAgICAgYXBpLFxuICAgICAgICAgICAgY2hhdFJlcXVlc3QsXG4gICAgICAgICAgICBtdXRhdGUsXG4gICAgICAgICAgICBtdXRhdGVTdHJlYW1EYXRhLFxuICAgICAgICAgICAgc3RyZWFtRGF0YSxcbiAgICAgICAgICAgIGV4dHJhTWV0YWRhdGFSZWYsXG4gICAgICAgICAgICBtZXNzYWdlc1JlZixcbiAgICAgICAgICAgIGFib3J0Q29udHJvbGxlclJlZixcbiAgICAgICAgICAgIGdlbmVyYXRlSWQyLFxuICAgICAgICAgICAgc3RyZWFtTW9kZSxcbiAgICAgICAgICAgIG9uRmluaXNoLFxuICAgICAgICAgICAgb25SZXNwb25zZSxcbiAgICAgICAgICAgIHNlbmRFeHRyYU1lc3NhZ2VGaWVsZHNcbiAgICAgICAgICApLFxuICAgICAgICAgIGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCxcbiAgICAgICAgICBleHBlcmltZW50YWxfb25Ub29sQ2FsbCxcbiAgICAgICAgICB1cGRhdGVDaGF0UmVxdWVzdDogKGNoYXRSZXF1ZXN0UGFyYW0pID0+IHtcbiAgICAgICAgICAgIGNoYXRSZXF1ZXN0ID0gY2hhdFJlcXVlc3RQYXJhbTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldEN1cnJlbnRNZXNzYWdlczogKCkgPT4gbWVzc2FnZXNSZWYuY3VycmVudFxuICAgICAgICB9KTtcbiAgICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIpIHtcbiAgICAgICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uRXJyb3IgJiYgZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgc2V0RXJyb3IoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIG11dGF0ZUxvYWRpbmcoZmFsc2UpO1xuICAgICAgfVxuICAgIH0sXG4gICAgW1xuICAgICAgbXV0YXRlLFxuICAgICAgbXV0YXRlTG9hZGluZyxcbiAgICAgIGFwaSxcbiAgICAgIGV4dHJhTWV0YWRhdGFSZWYsXG4gICAgICBvblJlc3BvbnNlLFxuICAgICAgb25GaW5pc2gsXG4gICAgICBvbkVycm9yLFxuICAgICAgc2V0RXJyb3IsXG4gICAgICBtdXRhdGVTdHJlYW1EYXRhLFxuICAgICAgc3RyZWFtRGF0YSxcbiAgICAgIHN0cmVhbU1vZGUsXG4gICAgICBzZW5kRXh0cmFNZXNzYWdlRmllbGRzLFxuICAgICAgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsLFxuICAgICAgZXhwZXJpbWVudGFsX29uVG9vbENhbGwsXG4gICAgICBtZXNzYWdlc1JlZixcbiAgICAgIGFib3J0Q29udHJvbGxlclJlZixcbiAgICAgIGdlbmVyYXRlSWQyXG4gICAgXVxuICApO1xuICBjb25zdCBhcHBlbmQgPSB1c2VDYWxsYmFjayhcbiAgICBhc3luYyAobWVzc2FnZSwge1xuICAgICAgb3B0aW9ucyxcbiAgICAgIGZ1bmN0aW9ucyxcbiAgICAgIGZ1bmN0aW9uX2NhbGwsXG4gICAgICB0b29scyxcbiAgICAgIHRvb2xfY2hvaWNlLFxuICAgICAgZGF0YVxuICAgIH0gPSB7fSkgPT4ge1xuICAgICAgaWYgKCFtZXNzYWdlLmlkKSB7XG4gICAgICAgIG1lc3NhZ2UuaWQgPSBnZW5lcmF0ZUlkMigpO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hhdFJlcXVlc3QgPSB7XG4gICAgICAgIG1lc3NhZ2VzOiBtZXNzYWdlc1JlZi5jdXJyZW50LmNvbmNhdChtZXNzYWdlKSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgLi4uZnVuY3Rpb25zICE9PSB2b2lkIDAgJiYgeyBmdW5jdGlvbnMgfSxcbiAgICAgICAgLi4uZnVuY3Rpb25fY2FsbCAhPT0gdm9pZCAwICYmIHsgZnVuY3Rpb25fY2FsbCB9LFxuICAgICAgICAuLi50b29scyAhPT0gdm9pZCAwICYmIHsgdG9vbHMgfSxcbiAgICAgICAgLi4udG9vbF9jaG9pY2UgIT09IHZvaWQgMCAmJiB7IHRvb2xfY2hvaWNlIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gdHJpZ2dlclJlcXVlc3QoY2hhdFJlcXVlc3QpO1xuICAgIH0sXG4gICAgW3RyaWdnZXJSZXF1ZXN0LCBnZW5lcmF0ZUlkMl1cbiAgKTtcbiAgY29uc3QgcmVsb2FkID0gdXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKHtcbiAgICAgIG9wdGlvbnMsXG4gICAgICBmdW5jdGlvbnMsXG4gICAgICBmdW5jdGlvbl9jYWxsLFxuICAgICAgdG9vbHMsXG4gICAgICB0b29sX2Nob2ljZVxuICAgIH0gPSB7fSkgPT4ge1xuICAgICAgaWYgKG1lc3NhZ2VzUmVmLmN1cnJlbnQubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNvbnN0IGxhc3RNZXNzYWdlID0gbWVzc2FnZXNSZWYuY3VycmVudFttZXNzYWdlc1JlZi5jdXJyZW50Lmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGxhc3RNZXNzYWdlLnJvbGUgPT09IFwiYXNzaXN0YW50XCIpIHtcbiAgICAgICAgY29uc3QgY2hhdFJlcXVlc3QyID0ge1xuICAgICAgICAgIG1lc3NhZ2VzOiBtZXNzYWdlc1JlZi5jdXJyZW50LnNsaWNlKDAsIC0xKSxcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIC4uLmZ1bmN0aW9ucyAhPT0gdm9pZCAwICYmIHsgZnVuY3Rpb25zIH0sXG4gICAgICAgICAgLi4uZnVuY3Rpb25fY2FsbCAhPT0gdm9pZCAwICYmIHsgZnVuY3Rpb25fY2FsbCB9LFxuICAgICAgICAgIC4uLnRvb2xzICE9PSB2b2lkIDAgJiYgeyB0b29scyB9LFxuICAgICAgICAgIC4uLnRvb2xfY2hvaWNlICE9PSB2b2lkIDAgJiYgeyB0b29sX2Nob2ljZSB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0cmlnZ2VyUmVxdWVzdChjaGF0UmVxdWVzdDIpO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hhdFJlcXVlc3QgPSB7XG4gICAgICAgIG1lc3NhZ2VzOiBtZXNzYWdlc1JlZi5jdXJyZW50LFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICAuLi5mdW5jdGlvbnMgIT09IHZvaWQgMCAmJiB7IGZ1bmN0aW9ucyB9LFxuICAgICAgICAuLi5mdW5jdGlvbl9jYWxsICE9PSB2b2lkIDAgJiYgeyBmdW5jdGlvbl9jYWxsIH0sXG4gICAgICAgIC4uLnRvb2xzICE9PSB2b2lkIDAgJiYgeyB0b29scyB9LFxuICAgICAgICAuLi50b29sX2Nob2ljZSAhPT0gdm9pZCAwICYmIHsgdG9vbF9jaG9pY2UgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiB0cmlnZ2VyUmVxdWVzdChjaGF0UmVxdWVzdCk7XG4gICAgfSxcbiAgICBbdHJpZ2dlclJlcXVlc3RdXG4gICk7XG4gIGNvbnN0IHN0b3AgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50KSB7XG4gICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudC5hYm9ydCgpO1xuICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfSwgW10pO1xuICBjb25zdCBzZXRNZXNzYWdlcyA9IHVzZUNhbGxiYWNrKFxuICAgIChtZXNzYWdlczIpID0+IHtcbiAgICAgIG11dGF0ZShtZXNzYWdlczIsIGZhbHNlKTtcbiAgICAgIG1lc3NhZ2VzUmVmLmN1cnJlbnQgPSBtZXNzYWdlczI7XG4gICAgfSxcbiAgICBbbXV0YXRlXVxuICApO1xuICBjb25zdCBbaW5wdXQsIHNldElucHV0XSA9IHVzZVN0YXRlKGluaXRpYWxJbnB1dCk7XG4gIGNvbnN0IGhhbmRsZVN1Ym1pdCA9IHVzZUNhbGxiYWNrKFxuICAgIChlLCBvcHRpb25zID0ge30sIG1ldGFkYXRhKSA9PiB7XG4gICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50ID0ge1xuICAgICAgICAgIC4uLmV4dHJhTWV0YWRhdGFSZWYuY3VycmVudCxcbiAgICAgICAgICAuLi5tZXRhZGF0YVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgaWYgKCFpbnB1dClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgYXBwZW5kKFxuICAgICAgICB7XG4gICAgICAgICAgY29udGVudDogaW5wdXQsXG4gICAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgICAgY3JlYXRlZEF0OiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKVxuICAgICAgICB9LFxuICAgICAgICBvcHRpb25zXG4gICAgICApO1xuICAgICAgc2V0SW5wdXQoXCJcIik7XG4gICAgfSxcbiAgICBbaW5wdXQsIGFwcGVuZF1cbiAgKTtcbiAgY29uc3QgaGFuZGxlSW5wdXRDaGFuZ2UgPSAoZSkgPT4ge1xuICAgIHNldElucHV0KGUudGFyZ2V0LnZhbHVlKTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBtZXNzYWdlczogbWVzc2FnZXMgfHwgW10sXG4gICAgZXJyb3IsXG4gICAgYXBwZW5kLFxuICAgIHJlbG9hZCxcbiAgICBzdG9wLFxuICAgIHNldE1lc3NhZ2VzLFxuICAgIGlucHV0LFxuICAgIHNldElucHV0LFxuICAgIGhhbmRsZUlucHV0Q2hhbmdlLFxuICAgIGhhbmRsZVN1Ym1pdCxcbiAgICBpc0xvYWRpbmcsXG4gICAgZGF0YTogc3RyZWFtRGF0YSxcbiAgICBleHBlcmltZW50YWxfYWRkVG9vbFJlc3VsdDogKHtcbiAgICAgIHRvb2xDYWxsSWQsXG4gICAgICByZXN1bHRcbiAgICB9KSA9PiB7XG4gICAgICBjb25zdCB1cGRhdGVkTWVzc2FnZXMgPSBtZXNzYWdlc1JlZi5jdXJyZW50Lm1hcChcbiAgICAgICAgKG1lc3NhZ2UsIGluZGV4LCBhcnIpID0+IChcbiAgICAgICAgICAvLyB1cGRhdGUgdGhlIHRvb2wgY2FsbHMgaW4gdGhlIGxhc3QgYXNzaXN0YW50IG1lc3NhZ2U6XG4gICAgICAgICAgaW5kZXggPT09IGFyci5sZW5ndGggLSAxICYmIG1lc3NhZ2Uucm9sZSA9PT0gXCJhc3Npc3RhbnRcIiAmJiBtZXNzYWdlLnRvb2xJbnZvY2F0aW9ucyA/IHtcbiAgICAgICAgICAgIC4uLm1lc3NhZ2UsXG4gICAgICAgICAgICB0b29sSW52b2NhdGlvbnM6IG1lc3NhZ2UudG9vbEludm9jYXRpb25zLm1hcChcbiAgICAgICAgICAgICAgKHRvb2xJbnZvY2F0aW9uKSA9PiB0b29sSW52b2NhdGlvbi50b29sQ2FsbElkID09PSB0b29sQ2FsbElkID8geyAuLi50b29sSW52b2NhdGlvbiwgcmVzdWx0IH0gOiB0b29sSW52b2NhdGlvblxuICAgICAgICAgICAgKVxuICAgICAgICAgIH0gOiBtZXNzYWdlXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBtdXRhdGUodXBkYXRlZE1lc3NhZ2VzLCBmYWxzZSk7XG4gICAgICBjb25zdCBsYXN0TWVzc2FnZSA9IHVwZGF0ZWRNZXNzYWdlc1t1cGRhdGVkTWVzc2FnZXMubGVuZ3RoIC0gMV07XG4gICAgICBpZiAobGFzdE1lc3NhZ2Uucm9sZSA9PT0gXCJhc3Npc3RhbnRcIiAmJiBsYXN0TWVzc2FnZS50b29sSW52b2NhdGlvbnMgJiYgbGFzdE1lc3NhZ2UudG9vbEludm9jYXRpb25zLmxlbmd0aCA+IDAgJiYgbGFzdE1lc3NhZ2UudG9vbEludm9jYXRpb25zLmV2ZXJ5KFxuICAgICAgICAodG9vbEludm9jYXRpb24pID0+IFwicmVzdWx0XCIgaW4gdG9vbEludm9jYXRpb25cbiAgICAgICkpIHtcbiAgICAgICAgdHJpZ2dlclJlcXVlc3QoeyBtZXNzYWdlczogdXBkYXRlZE1lc3NhZ2VzIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuLy8gcmVhY3QvdXNlLWNvbXBsZXRpb24udHNcbmltcG9ydCB7IHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrMiwgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDIsIHVzZUlkIGFzIHVzZUlkMiwgdXNlUmVmIGFzIHVzZVJlZjIsIHVzZVN0YXRlIGFzIHVzZVN0YXRlMiB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHVzZVNXUjIgZnJvbSBcInN3clwiO1xuXG4vLyBzaGFyZWQvY2FsbC1jb21wbGV0aW9uLWFwaS50c1xuYXN5bmMgZnVuY3Rpb24gY2FsbENvbXBsZXRpb25BcGkoe1xuICBhcGksXG4gIHByb21wdCxcbiAgY3JlZGVudGlhbHMsXG4gIGhlYWRlcnMsXG4gIGJvZHksXG4gIHN0cmVhbU1vZGUgPSBcInN0cmVhbS1kYXRhXCIsXG4gIHNldENvbXBsZXRpb24sXG4gIHNldExvYWRpbmcsXG4gIHNldEVycm9yLFxuICBzZXRBYm9ydENvbnRyb2xsZXIsXG4gIG9uUmVzcG9uc2UsXG4gIG9uRmluaXNoLFxuICBvbkVycm9yLFxuICBvbkRhdGFcbn0pIHtcbiAgdHJ5IHtcbiAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgIHNldEVycm9yKHZvaWQgMCk7XG4gICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIHNldEFib3J0Q29udHJvbGxlcihhYm9ydENvbnRyb2xsZXIpO1xuICAgIHNldENvbXBsZXRpb24oXCJcIik7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYXBpLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBwcm9tcHQsXG4gICAgICAgIC4uLmJvZHlcbiAgICAgIH0pLFxuICAgICAgY3JlZGVudGlhbHMsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAuLi5oZWFkZXJzXG4gICAgICB9LFxuICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsXG4gICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0pO1xuICAgIGlmIChvblJlc3BvbnNlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBvblJlc3BvbnNlKHJlcyk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBhd2FpdCByZXMudGV4dCgpIHx8IFwiRmFpbGVkIHRvIGZldGNoIHRoZSBjaGF0IHJlc3BvbnNlLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIXJlcy5ib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcmVzcG9uc2UgYm9keSBpcyBlbXB0eS5cIik7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgIGNvbnN0IHJlYWRlciA9IHJlcy5ib2R5LmdldFJlYWRlcigpO1xuICAgIHN3aXRjaCAoc3RyZWFtTW9kZSkge1xuICAgICAgY2FzZSBcInRleHRcIjoge1xuICAgICAgICBjb25zdCBkZWNvZGVyID0gY3JlYXRlQ2h1bmtEZWNvZGVyKCk7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCArPSBkZWNvZGVyKHZhbHVlKTtcbiAgICAgICAgICBzZXRDb21wbGV0aW9uKHJlc3VsdCk7XG4gICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmVhZGVyLmNhbmNlbCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInN0cmVhbS1kYXRhXCI6IHtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCB7IHR5cGUsIHZhbHVlIH0gb2YgcmVhZERhdGFTdHJlYW0ocmVhZGVyLCB7XG4gICAgICAgICAgaXNBYm9ydGVkOiAoKSA9PiBhYm9ydENvbnRyb2xsZXIgPT09IG51bGxcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6IHtcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IHZhbHVlO1xuICAgICAgICAgICAgICBzZXRDb21wbGV0aW9uKHJlc3VsdCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImRhdGFcIjoge1xuICAgICAgICAgICAgICBvbkRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IG9uRGF0YSh2YWx1ZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrID0gc3RyZWFtTW9kZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHN0cmVhbSBtb2RlOiAke2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9uRmluaXNoKSB7XG4gICAgICBvbkZpbmlzaChwcm9tcHQsIHJlc3VsdCk7XG4gICAgfVxuICAgIHNldEFib3J0Q29udHJvbGxlcihudWxsKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiKSB7XG4gICAgICBzZXRBYm9ydENvbnRyb2xsZXIobnVsbCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICBpZiAob25FcnJvcikge1xuICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICB9XG4gICAgfVxuICAgIHNldEVycm9yKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gIH1cbn1cblxuLy8gcmVhY3QvdXNlLWNvbXBsZXRpb24udHNcbmZ1bmN0aW9uIHVzZUNvbXBsZXRpb24oe1xuICBhcGkgPSBcIi9hcGkvY29tcGxldGlvblwiLFxuICBpZCxcbiAgaW5pdGlhbENvbXBsZXRpb24gPSBcIlwiLFxuICBpbml0aWFsSW5wdXQgPSBcIlwiLFxuICBjcmVkZW50aWFscyxcbiAgaGVhZGVycyxcbiAgYm9keSxcbiAgc3RyZWFtTW9kZSxcbiAgb25SZXNwb25zZSxcbiAgb25GaW5pc2gsXG4gIG9uRXJyb3Jcbn0gPSB7fSkge1xuICBjb25zdCBob29rSWQgPSB1c2VJZDIoKTtcbiAgY29uc3QgY29tcGxldGlvbklkID0gaWQgfHwgaG9va0lkO1xuICBjb25zdCB7IGRhdGEsIG11dGF0ZSB9ID0gdXNlU1dSMihbYXBpLCBjb21wbGV0aW9uSWRdLCBudWxsLCB7XG4gICAgZmFsbGJhY2tEYXRhOiBpbml0aWFsQ29tcGxldGlvblxuICB9KTtcbiAgY29uc3QgeyBkYXRhOiBpc0xvYWRpbmcgPSBmYWxzZSwgbXV0YXRlOiBtdXRhdGVMb2FkaW5nIH0gPSB1c2VTV1IyKFxuICAgIFtjb21wbGV0aW9uSWQsIFwibG9hZGluZ1wiXSxcbiAgICBudWxsXG4gICk7XG4gIGNvbnN0IHsgZGF0YTogc3RyZWFtRGF0YSwgbXV0YXRlOiBtdXRhdGVTdHJlYW1EYXRhIH0gPSB1c2VTV1IyKFtjb21wbGV0aW9uSWQsIFwic3RyZWFtRGF0YVwiXSwgbnVsbCk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGUyKHZvaWQgMCk7XG4gIGNvbnN0IGNvbXBsZXRpb24gPSBkYXRhO1xuICBjb25zdCBbYWJvcnRDb250cm9sbGVyLCBzZXRBYm9ydENvbnRyb2xsZXJdID0gdXNlU3RhdGUyKG51bGwpO1xuICBjb25zdCBleHRyYU1ldGFkYXRhUmVmID0gdXNlUmVmMih7XG4gICAgY3JlZGVudGlhbHMsXG4gICAgaGVhZGVycyxcbiAgICBib2R5XG4gIH0pO1xuICB1c2VFZmZlY3QyKCgpID0+IHtcbiAgICBleHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQgPSB7XG4gICAgICBjcmVkZW50aWFscyxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBib2R5XG4gICAgfTtcbiAgfSwgW2NyZWRlbnRpYWxzLCBoZWFkZXJzLCBib2R5XSk7XG4gIGNvbnN0IHRyaWdnZXJSZXF1ZXN0ID0gdXNlQ2FsbGJhY2syKFxuICAgIGFzeW5jIChwcm9tcHQsIG9wdGlvbnMpID0+IGNhbGxDb21wbGV0aW9uQXBpKHtcbiAgICAgIGFwaSxcbiAgICAgIHByb21wdCxcbiAgICAgIGNyZWRlbnRpYWxzOiBleHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQuY3JlZGVudGlhbHMsXG4gICAgICBoZWFkZXJzOiB7IC4uLmV4dHJhTWV0YWRhdGFSZWYuY3VycmVudC5oZWFkZXJzLCAuLi5vcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMgfSxcbiAgICAgIGJvZHk6IHtcbiAgICAgICAgLi4uZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LmJvZHksXG4gICAgICAgIC4uLm9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuYm9keVxuICAgICAgfSxcbiAgICAgIHN0cmVhbU1vZGUsXG4gICAgICBzZXRDb21wbGV0aW9uOiAoY29tcGxldGlvbjIpID0+IG11dGF0ZShjb21wbGV0aW9uMiwgZmFsc2UpLFxuICAgICAgc2V0TG9hZGluZzogbXV0YXRlTG9hZGluZyxcbiAgICAgIHNldEVycm9yLFxuICAgICAgc2V0QWJvcnRDb250cm9sbGVyLFxuICAgICAgb25SZXNwb25zZSxcbiAgICAgIG9uRmluaXNoLFxuICAgICAgb25FcnJvcixcbiAgICAgIG9uRGF0YTogKGRhdGEyKSA9PiB7XG4gICAgICAgIG11dGF0ZVN0cmVhbURhdGEoWy4uLnN0cmVhbURhdGEgfHwgW10sIC4uLmRhdGEyIHx8IFtdXSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH0pLFxuICAgIFtcbiAgICAgIG11dGF0ZSxcbiAgICAgIG11dGF0ZUxvYWRpbmcsXG4gICAgICBhcGksXG4gICAgICBleHRyYU1ldGFkYXRhUmVmLFxuICAgICAgc2V0QWJvcnRDb250cm9sbGVyLFxuICAgICAgb25SZXNwb25zZSxcbiAgICAgIG9uRmluaXNoLFxuICAgICAgb25FcnJvcixcbiAgICAgIHNldEVycm9yLFxuICAgICAgc3RyZWFtRGF0YSxcbiAgICAgIHN0cmVhbU1vZGUsXG4gICAgICBtdXRhdGVTdHJlYW1EYXRhXG4gICAgXVxuICApO1xuICBjb25zdCBzdG9wID0gdXNlQ2FsbGJhY2syKCgpID0+IHtcbiAgICBpZiAoYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIHNldEFib3J0Q29udHJvbGxlcihudWxsKTtcbiAgICB9XG4gIH0sIFthYm9ydENvbnRyb2xsZXJdKTtcbiAgY29uc3Qgc2V0Q29tcGxldGlvbiA9IHVzZUNhbGxiYWNrMihcbiAgICAoY29tcGxldGlvbjIpID0+IHtcbiAgICAgIG11dGF0ZShjb21wbGV0aW9uMiwgZmFsc2UpO1xuICAgIH0sXG4gICAgW211dGF0ZV1cbiAgKTtcbiAgY29uc3QgY29tcGxldGUgPSB1c2VDYWxsYmFjazIoXG4gICAgYXN5bmMgKHByb21wdCwgb3B0aW9ucykgPT4ge1xuICAgICAgcmV0dXJuIHRyaWdnZXJSZXF1ZXN0KHByb21wdCwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBbdHJpZ2dlclJlcXVlc3RdXG4gICk7XG4gIGNvbnN0IFtpbnB1dCwgc2V0SW5wdXRdID0gdXNlU3RhdGUyKGluaXRpYWxJbnB1dCk7XG4gIGNvbnN0IGhhbmRsZVN1Ym1pdCA9IHVzZUNhbGxiYWNrMihcbiAgICAoZSkgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgaWYgKCFpbnB1dClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgcmV0dXJuIGNvbXBsZXRlKGlucHV0KTtcbiAgICB9LFxuICAgIFtpbnB1dCwgY29tcGxldGVdXG4gICk7XG4gIGNvbnN0IGhhbmRsZUlucHV0Q2hhbmdlID0gKGUpID0+IHtcbiAgICBzZXRJbnB1dChlLnRhcmdldC52YWx1ZSk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgY29tcGxldGlvbixcbiAgICBjb21wbGV0ZSxcbiAgICBlcnJvcixcbiAgICBzZXRDb21wbGV0aW9uLFxuICAgIHN0b3AsXG4gICAgaW5wdXQsXG4gICAgc2V0SW5wdXQsXG4gICAgaGFuZGxlSW5wdXRDaGFuZ2UsXG4gICAgaGFuZGxlU3VibWl0LFxuICAgIGlzTG9hZGluZyxcbiAgICBkYXRhOiBzdHJlYW1EYXRhXG4gIH07XG59XG5cbi8vIHJlYWN0L3VzZS1hc3Npc3RhbnQudHNcbmltcG9ydCB7IGlzQWJvcnRFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazMsIHVzZVJlZiBhcyB1c2VSZWYzLCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTMgfSBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIHVzZUFzc2lzdGFudCh7XG4gIGFwaSxcbiAgdGhyZWFkSWQ6IHRocmVhZElkUGFyYW0sXG4gIGNyZWRlbnRpYWxzLFxuICBoZWFkZXJzLFxuICBib2R5LFxuICBvbkVycm9yXG59KSB7XG4gIGNvbnN0IFttZXNzYWdlcywgc2V0TWVzc2FnZXNdID0gdXNlU3RhdGUzKFtdKTtcbiAgY29uc3QgW2lucHV0LCBzZXRJbnB1dF0gPSB1c2VTdGF0ZTMoXCJcIik7XG4gIGNvbnN0IFt0aHJlYWRJZCwgc2V0VGhyZWFkSWRdID0gdXNlU3RhdGUzKHZvaWQgMCk7XG4gIGNvbnN0IFtzdGF0dXMsIHNldFN0YXR1c10gPSB1c2VTdGF0ZTMoXCJhd2FpdGluZ19tZXNzYWdlXCIpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlMyh2b2lkIDApO1xuICBjb25zdCBoYW5kbGVJbnB1dENoYW5nZSA9IChldmVudCkgPT4ge1xuICAgIHNldElucHV0KGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gIH07XG4gIGNvbnN0IGFib3J0Q29udHJvbGxlclJlZiA9IHVzZVJlZjMobnVsbCk7XG4gIGNvbnN0IHN0b3AgPSB1c2VDYWxsYmFjazMoKCkgPT4ge1xuICAgIGlmIChhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCkge1xuICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQuYWJvcnQoKTtcbiAgICAgIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH0sIFtdKTtcbiAgY29uc3QgYXBwZW5kID0gYXN5bmMgKG1lc3NhZ2UsIHJlcXVlc3RPcHRpb25zKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHNldFN0YXR1cyhcImluX3Byb2dyZXNzXCIpO1xuICAgIHNldE1lc3NhZ2VzKChtZXNzYWdlczIpID0+IHtcbiAgICAgIHZhciBfYTI7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAuLi5tZXNzYWdlczIsXG4gICAgICAgIHtcbiAgICAgICAgICAuLi5tZXNzYWdlLFxuICAgICAgICAgIGlkOiAoX2EyID0gbWVzc2FnZS5pZCkgIT0gbnVsbCA/IF9hMiA6IGdlbmVyYXRlSWQoKVxuICAgICAgICB9XG4gICAgICBdO1xuICAgIH0pO1xuICAgIHNldElucHV0KFwiXCIpO1xuICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICB0cnkge1xuICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQgPSBhYm9ydENvbnRyb2xsZXI7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmZXRjaChhcGksIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgY3JlZGVudGlhbHMsXG4gICAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiwgLi4uaGVhZGVycyB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgLi4uYm9keSxcbiAgICAgICAgICAvLyBhbHdheXMgdXNlIHVzZXItcHJvdmlkZWQgdGhyZWFkSWQgd2hlbiBhdmFpbGFibGU6XG4gICAgICAgICAgdGhyZWFkSWQ6IChfYSA9IHRocmVhZElkUGFyYW0gIT0gbnVsbCA/IHRocmVhZElkUGFyYW0gOiB0aHJlYWRJZCkgIT0gbnVsbCA/IF9hIDogbnVsbCxcbiAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLmNvbnRlbnQsXG4gICAgICAgICAgLy8gb3B0aW9uYWwgcmVxdWVzdCBkYXRhOlxuICAgICAgICAgIGRhdGE6IHJlcXVlc3RPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiByZXF1ZXN0T3B0aW9ucy5kYXRhXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIGlmIChyZXN1bHQuYm9keSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSByZXNwb25zZSBib2R5IGlzIGVtcHR5LlwiKTtcbiAgICAgIH1cbiAgICAgIGZvciBhd2FpdCAoY29uc3QgeyB0eXBlLCB2YWx1ZSB9IG9mIHJlYWREYXRhU3RyZWFtKFxuICAgICAgICByZXN1bHQuYm9keS5nZXRSZWFkZXIoKVxuICAgICAgKSkge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwiYXNzaXN0YW50X21lc3NhZ2VcIjoge1xuICAgICAgICAgICAgc2V0TWVzc2FnZXMoKG1lc3NhZ2VzMikgPT4gW1xuICAgICAgICAgICAgICAuLi5tZXNzYWdlczIsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZDogdmFsdWUuaWQsXG4gICAgICAgICAgICAgICAgcm9sZTogdmFsdWUucm9sZSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiB2YWx1ZS5jb250ZW50WzBdLnRleHQudmFsdWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcInRleHRcIjoge1xuICAgICAgICAgICAgc2V0TWVzc2FnZXMoKG1lc3NhZ2VzMikgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBsYXN0TWVzc2FnZSA9IG1lc3NhZ2VzMlttZXNzYWdlczIubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgLi4ubWVzc2FnZXMyLnNsaWNlKDAsIG1lc3NhZ2VzMi5sZW5ndGggLSAxKSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZDogbGFzdE1lc3NhZ2UuaWQsXG4gICAgICAgICAgICAgICAgICByb2xlOiBsYXN0TWVzc2FnZS5yb2xlLFxuICAgICAgICAgICAgICAgICAgY29udGVudDogbGFzdE1lc3NhZ2UuY29udGVudCArIHZhbHVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImRhdGFfbWVzc2FnZVwiOiB7XG4gICAgICAgICAgICBzZXRNZXNzYWdlcygobWVzc2FnZXMyKSA9PiB7XG4gICAgICAgICAgICAgIHZhciBfYTI7XG4gICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgLi4ubWVzc2FnZXMyLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlkOiAoX2EyID0gdmFsdWUuaWQpICE9IG51bGwgPyBfYTIgOiBnZW5lcmF0ZUlkKCksXG4gICAgICAgICAgICAgICAgICByb2xlOiBcImRhdGFcIixcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgICBkYXRhOiB2YWx1ZS5kYXRhXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImFzc2lzdGFudF9jb250cm9sX2RhdGFcIjoge1xuICAgICAgICAgICAgc2V0VGhyZWFkSWQodmFsdWUudGhyZWFkSWQpO1xuICAgICAgICAgICAgc2V0TWVzc2FnZXMoKG1lc3NhZ2VzMikgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBsYXN0TWVzc2FnZSA9IG1lc3NhZ2VzMlttZXNzYWdlczIubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgIGxhc3RNZXNzYWdlLmlkID0gdmFsdWUubWVzc2FnZUlkO1xuICAgICAgICAgICAgICByZXR1cm4gWy4uLm1lc3NhZ2VzMi5zbGljZSgwLCBtZXNzYWdlczIubGVuZ3RoIC0gMSksIGxhc3RNZXNzYWdlXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJlcnJvclwiOiB7XG4gICAgICAgICAgICBjb25zdCBlcnJvck9iaiA9IG5ldyBFcnJvcih2YWx1ZSk7XG4gICAgICAgICAgICBzZXRFcnJvcihlcnJvck9iaik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICAgIGlmIChpc0Fib3J0RXJyb3IoZXJyb3IyKSAmJiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAob25FcnJvciAmJiBlcnJvcjIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBvbkVycm9yKGVycm9yMik7XG4gICAgICB9XG4gICAgICBzZXRFcnJvcihlcnJvcjIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICBzZXRTdGF0dXMoXCJhd2FpdGluZ19tZXNzYWdlXCIpO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3VibWl0TWVzc2FnZSA9IGFzeW5jIChldmVudCwgcmVxdWVzdE9wdGlvbnMpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgKF9hID0gZXZlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGV2ZW50LnByZXZlbnREZWZhdWx0KSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChldmVudCk7XG4gICAgaWYgKGlucHV0ID09PSBcIlwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFwcGVuZCh7IHJvbGU6IFwidXNlclwiLCBjb250ZW50OiBpbnB1dCB9LCByZXF1ZXN0T3B0aW9ucyk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgYXBwZW5kLFxuICAgIG1lc3NhZ2VzLFxuICAgIHNldE1lc3NhZ2VzLFxuICAgIHRocmVhZElkLFxuICAgIGlucHV0LFxuICAgIHNldElucHV0LFxuICAgIGhhbmRsZUlucHV0Q2hhbmdlLFxuICAgIHN1Ym1pdE1lc3NhZ2UsXG4gICAgc3RhdHVzLFxuICAgIGVycm9yLFxuICAgIHN0b3BcbiAgfTtcbn1cbnZhciBleHBlcmltZW50YWxfdXNlQXNzaXN0YW50ID0gdXNlQXNzaXN0YW50O1xuZXhwb3J0IHtcbiAgZXhwZXJpbWVudGFsX3VzZUFzc2lzdGFudCxcbiAgdXNlQXNzaXN0YW50LFxuICB1c2VDaGF0LFxuICB1c2VDb21wbGV0aW9uXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6WyJ1c2VDYWxsYmFjayIsInVzZUVmZmVjdCIsInVzZUlkIiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VTV1IiLCJjdXN0b21BbHBoYWJldCIsImdlbmVyYXRlSWQiLCJ0ZXh0U3RyZWFtUGFydCIsImNvZGUiLCJuYW1lIiwicGFyc2UiLCJ2YWx1ZSIsIkVycm9yIiwidHlwZSIsImZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQiLCJmdW5jdGlvbl9jYWxsIiwiYXJndW1lbnRzIiwiZGF0YVN0cmVhbVBhcnQiLCJBcnJheSIsImlzQXJyYXkiLCJlcnJvclN0cmVhbVBhcnQiLCJhc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydCIsImlkIiwicm9sZSIsImNvbnRlbnQiLCJldmVyeSIsIml0ZW0iLCJ0ZXh0IiwiYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0IiwidGhyZWFkSWQiLCJtZXNzYWdlSWQiLCJkYXRhTWVzc2FnZVN0cmVhbVBhcnQiLCJ0b29sQ2FsbHNTdHJlYW1QYXJ0IiwidG9vbF9jYWxscyIsInNvbWUiLCJ0YyIsImZ1bmN0aW9uIiwibWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydCIsInRvb2xDYWxsU3RyZWFtUGFydCIsInRvb2xDYWxsSWQiLCJ0b29sTmFtZSIsImFyZ3MiLCJ0b29sUmVzdWx0U3RyZWFtUGFydCIsInN0cmVhbVBhcnRzIiwic3RyZWFtUGFydHNCeUNvZGUiLCJTdHJlYW1TdHJpbmdQcmVmaXhlcyIsInZhbGlkQ29kZXMiLCJtYXAiLCJwYXJ0IiwicGFyc2VTdHJlYW1QYXJ0IiwibGluZSIsImZpcnN0U2VwYXJhdG9ySW5kZXgiLCJpbmRleE9mIiwicHJlZml4Iiwic2xpY2UiLCJpbmNsdWRlcyIsInRleHRWYWx1ZSIsImpzb25WYWx1ZSIsIkpTT04iLCJORVdMSU5FIiwiY2hhckNvZGVBdCIsImNvbmNhdENodW5rcyIsImNodW5rcyIsInRvdGFsTGVuZ3RoIiwiY29uY2F0ZW5hdGVkQ2h1bmtzIiwiVWludDhBcnJheSIsIm9mZnNldCIsImNodW5rIiwic2V0IiwibGVuZ3RoIiwicmVhZERhdGFTdHJlYW0iLCJyZWFkZXIiLCJpc0Fib3J0ZWQiLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJyZWFkIiwicHVzaCIsInN0cmVhbVBhcnRzMiIsImRlY29kZSIsInN0cmVhbSIsInNwbGl0IiwiZmlsdGVyIiwic3RyZWFtUGFydCIsImNhbmNlbCIsImFzc2lnbkFubm90YXRpb25zVG9NZXNzYWdlIiwibWVzc2FnZSIsImFubm90YXRpb25zIiwicGFyc2VDb21wbGV4UmVzcG9uc2UiLCJhYm9ydENvbnRyb2xsZXJSZWYiLCJ1cGRhdGUiLCJvbkZpbmlzaCIsImdlbmVyYXRlSWQyIiwiZ2V0Q3VycmVudERhdGUiLCJEYXRlIiwiY3JlYXRlZEF0IiwicHJlZml4TWFwIiwiZGF0YSIsIm1lc3NhZ2VfYW5ub3RhdGlvbnMiLCJjdXJyZW50IiwidG9vbEludm9jYXRpb25zIiwidG9vbEludm9jYXRpb25JbmRleCIsImZpbmRJbmRleCIsImludm9jYXRpb24iLCJmdW5jdGlvbkNhbGxNZXNzYWdlIiwidG9vbENhbGxNZXNzYWdlIiwicmVzcG9uc2VNZXNzYWdlIiwibWVzc2FnZVByZWZpeEtleXMiLCJmb3JFYWNoIiwia2V5IiwibWVyZ2VkIiwiQm9vbGVhbiIsIm1lc3NhZ2VzIiwiY3JlYXRlQ2h1bmtEZWNvZGVyIiwiY29tcGxleCIsImRlY29kZWQiLCJjYWxsQ2hhdEFwaSIsImFwaSIsImJvZHkiLCJzdHJlYW1Nb2RlIiwiY3JlZGVudGlhbHMiLCJoZWFkZXJzIiwiYWJvcnRDb250cm9sbGVyIiwicmVzdG9yZU1lc3NhZ2VzT25GYWlsdXJlIiwib25SZXNwb25zZSIsIm9uVXBkYXRlIiwiX2EiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwic3RyaW5naWZ5Iiwic2lnbmFsIiwiY2F0Y2giLCJlcnIiLCJvayIsImdldFJlYWRlciIsInJlc3VsdE1lc3NhZ2UiLCJkb25lIiwiZXhoYXVzdGl2ZUNoZWNrIiwicHJvY2Vzc0NoYXRTdHJlYW0iLCJnZXRTdHJlYW1lZFJlc3BvbnNlIiwiZ2V0U3RyZWFtZWRSZXNwb25zZTIiLCJleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwiLCJleHBlcmltZW50YWxfb25Ub29sQ2FsbCIsInVwZGF0ZUNoYXRSZXF1ZXN0IiwiZ2V0Q3VycmVudE1lc3NhZ2VzIiwibWVzc2FnZXNBbmREYXRhT3JKdXN0TWVzc2FnZSIsImhhc0ZvbGxvd2luZ1Jlc3BvbnNlIiwiZnVuY3Rpb25DYWxsIiwiY29uc29sZSIsIndhcm4iLCJmdW5jdGlvbkNhbGxSZXNwb25zZSIsInRvb2xDYWxscyIsInRvb2xDYWxsIiwidG9vbENhbGxSZXNwb25zZSIsImZpeEZ1bmN0aW9uQ2FsbEFyZ3VtZW50czIiLCJmaXhGdW5jdGlvbkNhbGxBcmd1bWVudHMiLCJzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZSIsImNoYXRSZXF1ZXN0IiwibXV0YXRlIiwibXV0YXRlU3RyZWFtRGF0YSIsImV4aXN0aW5nRGF0YSIsImV4dHJhTWV0YWRhdGFSZWYiLCJtZXNzYWdlc1JlZiIsInNlbmRFeHRyYU1lc3NhZ2VGaWVsZHMiLCJfYiIsInByZXZpb3VzTWVzc2FnZXMiLCJjb25zdHJ1Y3RlZE1lc3NhZ2VzUGF5bG9hZCIsInRvb2xfY2FsbF9pZCIsInJlcGx5SWQiLCJyZWFkUm93IiwicHJvbWlzZSIsInVpIiwibmV4dCIsImUiLCJvcHRpb25zIiwiZnVuY3Rpb25zIiwidG9vbHMiLCJ0b29sX2Nob2ljZSIsInVzZUNoYXQiLCJpbml0aWFsTWVzc2FnZXMiLCJpbml0aWFsSW5wdXQiLCJvbkVycm9yIiwiaG9va0lkIiwiaWRLZXkiLCJjaGF0S2V5IiwiaW5pdGlhbE1lc3NhZ2VzRmFsbGJhY2siLCJmYWxsYmFja0RhdGEiLCJpc0xvYWRpbmciLCJtdXRhdGVMb2FkaW5nIiwic3RyZWFtRGF0YSIsImVycm9yIiwic2V0RXJyb3IiLCJ0cmlnZ2VyUmVxdWVzdCIsIkFib3J0Q29udHJvbGxlciIsImNoYXRSZXF1ZXN0UGFyYW0iLCJhcHBlbmQiLCJjb25jYXQiLCJyZWxvYWQiLCJsYXN0TWVzc2FnZSIsImNoYXRSZXF1ZXN0MiIsInN0b3AiLCJhYm9ydCIsInNldE1lc3NhZ2VzIiwibWVzc2FnZXMyIiwiaW5wdXQiLCJzZXRJbnB1dCIsImhhbmRsZVN1Ym1pdCIsIm1ldGFkYXRhIiwicHJldmVudERlZmF1bHQiLCJoYW5kbGVJbnB1dENoYW5nZSIsInRhcmdldCIsImV4cGVyaW1lbnRhbF9hZGRUb29sUmVzdWx0IiwicmVzdWx0IiwidXBkYXRlZE1lc3NhZ2VzIiwiaW5kZXgiLCJhcnIiLCJ0b29sSW52b2NhdGlvbiIsInVzZUNhbGxiYWNrMiIsInVzZUVmZmVjdDIiLCJ1c2VJZDIiLCJ1c2VSZWYyIiwidXNlU3RhdGUyIiwidXNlU1dSMiIsImNhbGxDb21wbGV0aW9uQXBpIiwicHJvbXB0Iiwic2V0Q29tcGxldGlvbiIsInNldExvYWRpbmciLCJzZXRBYm9ydENvbnRyb2xsZXIiLCJvbkRhdGEiLCJyZXMiLCJ1c2VDb21wbGV0aW9uIiwiaW5pdGlhbENvbXBsZXRpb24iLCJjb21wbGV0aW9uSWQiLCJjb21wbGV0aW9uIiwiY29tcGxldGlvbjIiLCJkYXRhMiIsImNvbXBsZXRlIiwiaXNBYm9ydEVycm9yIiwidXNlQ2FsbGJhY2szIiwidXNlUmVmMyIsInVzZVN0YXRlMyIsInVzZUFzc2lzdGFudCIsInRocmVhZElkUGFyYW0iLCJzZXRUaHJlYWRJZCIsInN0YXR1cyIsInNldFN0YXR1cyIsImV2ZW50IiwicmVxdWVzdE9wdGlvbnMiLCJfYTIiLCJlcnJvck9iaiIsImVycm9yMiIsImFib3J0ZWQiLCJzdWJtaXRNZXNzYWdlIiwiY2FsbCIsImV4cGVyaW1lbnRhbF91c2VBc3Npc3RhbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ai/react/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/ai/dist/index.mjs":
/*!****************************************!*\
  !*** ./node_modules/ai/dist/index.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AIStream: () => (/* binding */ AIStream),\n/* harmony export */   APICallError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError),\n/* harmony export */   AWSBedrockAnthropicMessagesStream: () => (/* binding */ AWSBedrockAnthropicMessagesStream),\n/* harmony export */   AWSBedrockAnthropicStream: () => (/* binding */ AWSBedrockAnthropicStream),\n/* harmony export */   AWSBedrockCohereStream: () => (/* binding */ AWSBedrockCohereStream),\n/* harmony export */   AWSBedrockLlama2Stream: () => (/* binding */ AWSBedrockLlama2Stream),\n/* harmony export */   AWSBedrockStream: () => (/* binding */ AWSBedrockStream),\n/* harmony export */   AnthropicStream: () => (/* binding */ AnthropicStream),\n/* harmony export */   AssistantResponse: () => (/* binding */ AssistantResponse),\n/* harmony export */   CohereStream: () => (/* binding */ CohereStream),\n/* harmony export */   EmbedResult: () => (/* binding */ EmbedResult),\n/* harmony export */   EmptyResponseBodyError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.EmptyResponseBodyError),\n/* harmony export */   GenerateObjectResult: () => (/* binding */ GenerateObjectResult),\n/* harmony export */   GenerateTextResult: () => (/* binding */ GenerateTextResult),\n/* harmony export */   GoogleGenerativeAIStream: () => (/* binding */ GoogleGenerativeAIStream),\n/* harmony export */   HuggingFaceStream: () => (/* binding */ HuggingFaceStream),\n/* harmony export */   InkeepStream: () => (/* binding */ InkeepStream),\n/* harmony export */   InvalidArgumentError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError),\n/* harmony export */   InvalidDataContentError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidDataContentError),\n/* harmony export */   InvalidPromptError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError),\n/* harmony export */   InvalidResponseDataError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidResponseDataError),\n/* harmony export */   InvalidToolArgumentsError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidToolArgumentsError),\n/* harmony export */   JSONParseError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError),\n/* harmony export */   LangChainAdapter: () => (/* binding */ langchain_adapter_exports),\n/* harmony export */   LangChainStream: () => (/* binding */ LangChainStream),\n/* harmony export */   LoadAPIKeyError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadAPIKeyError),\n/* harmony export */   MistralStream: () => (/* binding */ MistralStream),\n/* harmony export */   NoObjectGeneratedError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoObjectGeneratedError),\n/* harmony export */   NoSuchToolError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchToolError),\n/* harmony export */   OpenAIStream: () => (/* binding */ OpenAIStream),\n/* harmony export */   ReplicateStream: () => (/* binding */ ReplicateStream),\n/* harmony export */   RetryError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.RetryError),\n/* harmony export */   StreamData: () => (/* binding */ StreamData),\n/* harmony export */   StreamObjectResult: () => (/* binding */ StreamObjectResult),\n/* harmony export */   StreamTextResult: () => (/* binding */ StreamTextResult),\n/* harmony export */   StreamingTextResponse: () => (/* binding */ StreamingTextResponse),\n/* harmony export */   ToolCallParseError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.ToolCallParseError),\n/* harmony export */   TypeValidationError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError),\n/* harmony export */   UnsupportedFunctionalityError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError),\n/* harmony export */   UnsupportedJSONSchemaError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedJSONSchemaError),\n/* harmony export */   convertDataContentToBase64String: () => (/* binding */ convertDataContentToBase64String),\n/* harmony export */   convertDataContentToUint8Array: () => (/* binding */ convertDataContentToUint8Array),\n/* harmony export */   convertToCoreMessages: () => (/* binding */ convertToCoreMessages),\n/* harmony export */   createCallbacksTransformer: () => (/* binding */ createCallbacksTransformer),\n/* harmony export */   createChunkDecoder: () => (/* binding */ createChunkDecoder),\n/* harmony export */   createEventStreamTransformer: () => (/* binding */ createEventStreamTransformer),\n/* harmony export */   createStreamDataTransformer: () => (/* binding */ createStreamDataTransformer),\n/* harmony export */   embed: () => (/* binding */ embed),\n/* harmony export */   experimental_AssistantResponse: () => (/* binding */ experimental_AssistantResponse),\n/* harmony export */   experimental_StreamData: () => (/* binding */ experimental_StreamData),\n/* harmony export */   experimental_StreamingReactResponse: () => (/* binding */ experimental_StreamingReactResponse),\n/* harmony export */   experimental_generateObject: () => (/* binding */ experimental_generateObject),\n/* harmony export */   experimental_generateText: () => (/* binding */ experimental_generateText),\n/* harmony export */   experimental_streamObject: () => (/* binding */ experimental_streamObject),\n/* harmony export */   experimental_streamText: () => (/* binding */ experimental_streamText),\n/* harmony export */   formatStreamPart: () => (/* binding */ formatStreamPart),\n/* harmony export */   generateId: () => (/* binding */ generateId),\n/* harmony export */   generateObject: () => (/* binding */ generateObject),\n/* harmony export */   generateText: () => (/* binding */ generateText),\n/* harmony export */   isStreamStringEqualToType: () => (/* binding */ isStreamStringEqualToType),\n/* harmony export */   nanoid: () => (/* binding */ generateId),\n/* harmony export */   parseStreamPart: () => (/* binding */ parseStreamPart),\n/* harmony export */   readDataStream: () => (/* binding */ readDataStream),\n/* harmony export */   readableFromAsyncIterable: () => (/* binding */ readableFromAsyncIterable),\n/* harmony export */   streamObject: () => (/* binding */ streamObject),\n/* harmony export */   streamText: () => (/* binding */ streamText),\n/* harmony export */   streamToResponse: () => (/* binding */ streamToResponse),\n/* harmony export */   tool: () => (/* binding */ tool),\n/* harmony export */   trimStartOfStreamHelper: () => (/* binding */ trimStartOfStreamHelper)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ai-sdk/provider */ \"(rsc)/./node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(rsc)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var zod_to_json_schema__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zod-to-json-schema */ \"(rsc)/./node_modules/zod-to-json-schema/dist/esm/index.js\");\n/* harmony import */ var secure_json_parse__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! secure-json-parse */ \"(rsc)/./node_modules/secure-json-parse/index.js\");\n/* harmony import */ var nanoid_non_secure__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! nanoid/non-secure */ \"(rsc)/./node_modules/ai/node_modules/nanoid/non-secure/index.js\");\n/* harmony import */ var eventsource_parser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! eventsource-parser */ \"(rsc)/./node_modules/eventsource-parser/dist/index.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// core/util/retry-with-exponential-backoff.ts\n\n\n\n// core/util/delay.ts\nasync function delay(delayInMs) {\n  return new Promise((resolve) => setTimeout(resolve, delayInMs));\n}\n\n// core/util/retry-with-exponential-backoff.ts\nvar retryWithExponentialBackoff = ({\n  maxRetries = 2,\n  initialDelayInMs = 2e3,\n  backoffFactor = 2\n} = {}) => async (f) => _retryWithExponentialBackoff(f, {\n  maxRetries,\n  delayInMs: initialDelayInMs,\n  backoffFactor\n});\nasync function _retryWithExponentialBackoff(f, {\n  maxRetries,\n  delayInMs,\n  backoffFactor\n}, errors = []) {\n  try {\n    return await f();\n  } catch (error) {\n    if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.isAbortError)(error)) {\n      throw error;\n    }\n    if (maxRetries === 0) {\n      throw error;\n    }\n    const errorMessage = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage)(error);\n    const newErrors = [...errors, error];\n    const tryNumber = newErrors.length;\n    if (tryNumber > maxRetries) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.RetryError({\n        message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,\n        reason: \"maxRetriesExceeded\",\n        errors: newErrors\n      });\n    }\n    if (error instanceof Error && _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError.isAPICallError(error) && error.isRetryable === true && tryNumber <= maxRetries) {\n      await delay(delayInMs);\n      return _retryWithExponentialBackoff(\n        f,\n        { maxRetries, delayInMs: backoffFactor * delayInMs, backoffFactor },\n        newErrors\n      );\n    }\n    if (tryNumber === 1) {\n      throw error;\n    }\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.RetryError({\n      message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,\n      reason: \"errorNotRetryable\",\n      errors: newErrors\n    });\n  }\n}\n\n// core/embed/embed.ts\nasync function embed({\n  model,\n  value,\n  maxRetries,\n  abortSignal\n}) {\n  const retry = retryWithExponentialBackoff({ maxRetries });\n  const modelResponse = await retry(\n    () => model.doEmbed({\n      values: [value],\n      abortSignal\n    })\n  );\n  return new EmbedResult({\n    value,\n    embedding: modelResponse.embeddings[0],\n    rawResponse: modelResponse.rawResponse\n  });\n}\nvar EmbedResult = class {\n  constructor(options) {\n    this.value = options.value;\n    this.embedding = options.embedding;\n    this.rawResponse = options.rawResponse;\n  }\n};\n\n// core/generate-object/generate-object.ts\n\n\n\n// core/generate-text/token-usage.ts\nfunction calculateTokenUsage(usage) {\n  return {\n    promptTokens: usage.promptTokens,\n    completionTokens: usage.completionTokens,\n    totalTokens: usage.promptTokens + usage.completionTokens\n  };\n}\n\n// core/util/detect-image-mimetype.ts\nvar mimeTypeSignatures = [\n  { mimeType: \"image/gif\", bytes: [71, 73, 70] },\n  { mimeType: \"image/png\", bytes: [137, 80, 78, 71] },\n  { mimeType: \"image/jpeg\", bytes: [255, 216] },\n  { mimeType: \"image/webp\", bytes: [82, 73, 70, 70] }\n];\nfunction detectImageMimeType(image) {\n  for (const { bytes, mimeType } of mimeTypeSignatures) {\n    if (image.length >= bytes.length && bytes.every((byte, index) => image[index] === byte)) {\n      return mimeType;\n    }\n  }\n  return void 0;\n}\n\n// core/prompt/data-content.ts\n\n\nfunction convertDataContentToBase64String(content) {\n  if (typeof content === \"string\") {\n    return content;\n  }\n  if (content instanceof ArrayBuffer) {\n    return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.convertUint8ArrayToBase64)(new Uint8Array(content));\n  }\n  return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.convertUint8ArrayToBase64)(content);\n}\nfunction convertDataContentToUint8Array(content) {\n  if (content instanceof Uint8Array) {\n    return content;\n  }\n  if (typeof content === \"string\") {\n    try {\n      return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.convertBase64ToUint8Array)(content);\n    } catch (error) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidDataContentError({\n        message: \"Invalid data content. Content string is not a base64-encoded image.\",\n        content,\n        cause: error\n      });\n    }\n  }\n  if (content instanceof ArrayBuffer) {\n    return new Uint8Array(content);\n  }\n  throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidDataContentError({ content });\n}\n\n// core/prompt/convert-to-language-model-prompt.ts\nfunction convertToLanguageModelPrompt(prompt) {\n  const languageModelMessages = [];\n  if (prompt.system != null) {\n    languageModelMessages.push({ role: \"system\", content: prompt.system });\n  }\n  switch (prompt.type) {\n    case \"prompt\": {\n      languageModelMessages.push({\n        role: \"user\",\n        content: [{ type: \"text\", text: prompt.prompt }]\n      });\n      break;\n    }\n    case \"messages\": {\n      languageModelMessages.push(\n        ...prompt.messages.map((message) => {\n          switch (message.role) {\n            case \"system\": {\n              return { role: \"system\", content: message.content };\n            }\n            case \"user\": {\n              if (typeof message.content === \"string\") {\n                return {\n                  role: \"user\",\n                  content: [{ type: \"text\", text: message.content }]\n                };\n              }\n              return {\n                role: \"user\",\n                content: message.content.map(\n                  (part) => {\n                    var _a;\n                    switch (part.type) {\n                      case \"text\": {\n                        return part;\n                      }\n                      case \"image\": {\n                        if (part.image instanceof URL) {\n                          return {\n                            type: \"image\",\n                            image: part.image,\n                            mimeType: part.mimeType\n                          };\n                        }\n                        const imageUint8 = convertDataContentToUint8Array(\n                          part.image\n                        );\n                        return {\n                          type: \"image\",\n                          image: imageUint8,\n                          mimeType: (_a = part.mimeType) != null ? _a : detectImageMimeType(imageUint8)\n                        };\n                      }\n                    }\n                  }\n                )\n              };\n            }\n            case \"assistant\": {\n              if (typeof message.content === \"string\") {\n                return {\n                  role: \"assistant\",\n                  content: [{ type: \"text\", text: message.content }]\n                };\n              }\n              return { role: \"assistant\", content: message.content };\n            }\n            case \"tool\": {\n              return message;\n            }\n          }\n        })\n      );\n      break;\n    }\n    default: {\n      const _exhaustiveCheck = prompt;\n      throw new Error(`Unsupported prompt type: ${_exhaustiveCheck}`);\n    }\n  }\n  return languageModelMessages;\n}\n\n// core/prompt/get-validated-prompt.ts\n\nfunction getValidatedPrompt(prompt) {\n  if (prompt.prompt == null && prompt.messages == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError({\n      prompt,\n      message: \"prompt or messages must be defined\"\n    });\n  }\n  if (prompt.prompt != null && prompt.messages != null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError({\n      prompt,\n      message: \"prompt and messages cannot be defined at the same time\"\n    });\n  }\n  return prompt.prompt != null ? {\n    type: \"prompt\",\n    prompt: prompt.prompt,\n    messages: void 0,\n    system: prompt.system\n  } : {\n    type: \"messages\",\n    prompt: void 0,\n    messages: prompt.messages,\n    // only possible case bc of checks above\n    system: prompt.system\n  };\n}\n\n// core/prompt/prepare-call-settings.ts\n\nfunction prepareCallSettings({\n  maxTokens,\n  temperature,\n  topP,\n  presencePenalty,\n  frequencyPenalty,\n  seed,\n  maxRetries\n}) {\n  if (maxTokens != null) {\n    if (!Number.isInteger(maxTokens)) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n        parameter: \"maxTokens\",\n        value: maxTokens,\n        message: \"maxTokens must be an integer\"\n      });\n    }\n    if (maxTokens < 1) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n        parameter: \"maxTokens\",\n        value: maxTokens,\n        message: \"maxTokens must be >= 1\"\n      });\n    }\n  }\n  if (temperature != null) {\n    if (typeof temperature !== \"number\") {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n        parameter: \"temperature\",\n        value: temperature,\n        message: \"temperature must be a number\"\n      });\n    }\n  }\n  if (topP != null) {\n    if (typeof topP !== \"number\") {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n        parameter: \"topP\",\n        value: topP,\n        message: \"topP must be a number\"\n      });\n    }\n  }\n  if (presencePenalty != null) {\n    if (typeof presencePenalty !== \"number\") {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n        parameter: \"presencePenalty\",\n        value: presencePenalty,\n        message: \"presencePenalty must be a number\"\n      });\n    }\n  }\n  if (frequencyPenalty != null) {\n    if (typeof frequencyPenalty !== \"number\") {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n        parameter: \"frequencyPenalty\",\n        value: frequencyPenalty,\n        message: \"frequencyPenalty must be a number\"\n      });\n    }\n  }\n  if (seed != null) {\n    if (!Number.isInteger(seed)) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n        parameter: \"seed\",\n        value: seed,\n        message: \"seed must be an integer\"\n      });\n    }\n  }\n  if (maxRetries != null) {\n    if (!Number.isInteger(maxRetries)) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n        parameter: \"maxRetries\",\n        value: maxRetries,\n        message: \"maxRetries must be an integer\"\n      });\n    }\n    if (maxRetries < 0) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n        parameter: \"maxRetries\",\n        value: maxRetries,\n        message: \"maxRetries must be >= 0\"\n      });\n    }\n  }\n  return {\n    maxTokens,\n    temperature: temperature != null ? temperature : 0,\n    topP,\n    presencePenalty,\n    frequencyPenalty,\n    seed,\n    maxRetries: maxRetries != null ? maxRetries : 2\n  };\n}\n\n// core/util/convert-zod-to-json-schema.ts\n\nfunction convertZodToJSONSchema(zodSchema) {\n  return (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(zodSchema);\n}\n\n// core/generate-object/inject-json-schema-into-system.ts\nvar DEFAULT_SCHEMA_PREFIX = \"JSON schema:\";\nvar DEFAULT_SCHEMA_SUFFIX = \"You MUST answer with a JSON object that matches the JSON schema above.\";\nfunction injectJsonSchemaIntoSystem({\n  system,\n  schema,\n  schemaPrefix = DEFAULT_SCHEMA_PREFIX,\n  schemaSuffix = DEFAULT_SCHEMA_SUFFIX\n}) {\n  return [\n    system,\n    system != null ? \"\" : null,\n    // add a newline if system is not null\n    schemaPrefix,\n    JSON.stringify(schema),\n    schemaSuffix\n  ].filter((line) => line != null).join(\"\\n\");\n}\n\n// core/generate-object/generate-object.ts\nasync function generateObject({\n  model,\n  schema,\n  mode,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  ...settings\n}) {\n  var _a, _b;\n  const retry = retryWithExponentialBackoff({ maxRetries });\n  const jsonSchema = convertZodToJSONSchema(schema);\n  if (mode === \"auto\" || mode == null) {\n    mode = model.defaultObjectGenerationMode;\n  }\n  let result;\n  let finishReason;\n  let usage;\n  let warnings;\n  let rawResponse;\n  let logprobs;\n  switch (mode) {\n    case \"json\": {\n      const validatedPrompt = getValidatedPrompt({\n        system: injectJsonSchemaIntoSystem({ system, schema: jsonSchema }),\n        prompt,\n        messages\n      });\n      const generateResult = await retry(() => {\n        return model.doGenerate({\n          mode: { type: \"object-json\" },\n          ...prepareCallSettings(settings),\n          inputFormat: validatedPrompt.type,\n          prompt: convertToLanguageModelPrompt(validatedPrompt),\n          abortSignal\n        });\n      });\n      if (generateResult.text === void 0) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoObjectGeneratedError();\n      }\n      result = generateResult.text;\n      finishReason = generateResult.finishReason;\n      usage = generateResult.usage;\n      warnings = generateResult.warnings;\n      rawResponse = generateResult.rawResponse;\n      logprobs = generateResult.logprobs;\n      break;\n    }\n    case \"grammar\": {\n      const validatedPrompt = getValidatedPrompt({\n        system: injectJsonSchemaIntoSystem({ system, schema: jsonSchema }),\n        prompt,\n        messages\n      });\n      const generateResult = await retry(\n        () => model.doGenerate({\n          mode: { type: \"object-grammar\", schema: jsonSchema },\n          ...settings,\n          inputFormat: validatedPrompt.type,\n          prompt: convertToLanguageModelPrompt(validatedPrompt),\n          abortSignal\n        })\n      );\n      if (generateResult.text === void 0) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoObjectGeneratedError();\n      }\n      result = generateResult.text;\n      finishReason = generateResult.finishReason;\n      usage = generateResult.usage;\n      warnings = generateResult.warnings;\n      rawResponse = generateResult.rawResponse;\n      logprobs = generateResult.logprobs;\n      break;\n    }\n    case \"tool\": {\n      const validatedPrompt = getValidatedPrompt({\n        system,\n        prompt,\n        messages\n      });\n      const generateResult = await retry(\n        () => model.doGenerate({\n          mode: {\n            type: \"object-tool\",\n            tool: {\n              type: \"function\",\n              name: \"json\",\n              description: \"Respond with a JSON object.\",\n              parameters: jsonSchema\n            }\n          },\n          ...settings,\n          inputFormat: validatedPrompt.type,\n          prompt: convertToLanguageModelPrompt(validatedPrompt),\n          abortSignal\n        })\n      );\n      const functionArgs = (_b = (_a = generateResult.toolCalls) == null ? void 0 : _a[0]) == null ? void 0 : _b.args;\n      if (functionArgs === void 0) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoObjectGeneratedError();\n      }\n      result = functionArgs;\n      finishReason = generateResult.finishReason;\n      usage = generateResult.usage;\n      warnings = generateResult.warnings;\n      rawResponse = generateResult.rawResponse;\n      logprobs = generateResult.logprobs;\n      break;\n    }\n    case void 0: {\n      throw new Error(\"Model does not have a default object generation mode.\");\n    }\n    default: {\n      const _exhaustiveCheck = mode;\n      throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);\n    }\n  }\n  const parseResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.safeParseJSON)({ text: result, schema });\n  if (!parseResult.success) {\n    throw parseResult.error;\n  }\n  return new GenerateObjectResult({\n    object: parseResult.value,\n    finishReason,\n    usage: calculateTokenUsage(usage),\n    warnings,\n    rawResponse,\n    logprobs\n  });\n}\nvar GenerateObjectResult = class {\n  constructor(options) {\n    this.object = options.object;\n    this.finishReason = options.finishReason;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.rawResponse = options.rawResponse;\n    this.logprobs = options.logprobs;\n  }\n};\nvar experimental_generateObject = generateObject;\n\n// core/util/async-iterable-stream.ts\nfunction createAsyncIterableStream(source, transformer) {\n  const transformedStream = source.pipeThrough(\n    new TransformStream(transformer)\n  );\n  transformedStream[Symbol.asyncIterator] = () => {\n    const reader = transformedStream.getReader();\n    return {\n      async next() {\n        const { done, value } = await reader.read();\n        return done ? { done: true, value: void 0 } : { done: false, value };\n      }\n    };\n  };\n  return transformedStream;\n}\n\n// core/util/is-deep-equal-data.ts\nfunction isDeepEqualData(obj1, obj2) {\n  if (obj1 === obj2)\n    return true;\n  if (obj1 == null || obj2 == null)\n    return false;\n  if (typeof obj1 !== \"object\" && typeof obj2 !== \"object\")\n    return obj1 === obj2;\n  if (obj1.constructor !== obj2.constructor)\n    return false;\n  if (obj1 instanceof Date && obj2 instanceof Date) {\n    return obj1.getTime() === obj2.getTime();\n  }\n  if (Array.isArray(obj1)) {\n    if (obj1.length !== obj2.length)\n      return false;\n    for (let i = 0; i < obj1.length; i++) {\n      if (!isDeepEqualData(obj1[i], obj2[i]))\n        return false;\n    }\n    return true;\n  }\n  const keys1 = Object.keys(obj1);\n  const keys2 = Object.keys(obj2);\n  if (keys1.length !== keys2.length)\n    return false;\n  for (const key of keys1) {\n    if (!keys2.includes(key))\n      return false;\n    if (!isDeepEqualData(obj1[key], obj2[key]))\n      return false;\n  }\n  return true;\n}\n\n// core/util/parse-partial-json.ts\n\n\n// core/util/fix-json.ts\nfunction fixJson(input) {\n  const stack = [\"ROOT\"];\n  let lastValidIndex = -1;\n  let literalStart = null;\n  function processValueStart(char, i, swapState) {\n    {\n      switch (char) {\n        case '\"': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_STRING\");\n          break;\n        }\n        case \"f\":\n        case \"t\":\n        case \"n\": {\n          lastValidIndex = i;\n          literalStart = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_LITERAL\");\n          break;\n        }\n        case \"-\": {\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_NUMBER\");\n          break;\n        }\n        case \"0\":\n        case \"1\":\n        case \"2\":\n        case \"3\":\n        case \"4\":\n        case \"5\":\n        case \"6\":\n        case \"7\":\n        case \"8\":\n        case \"9\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_NUMBER\");\n          break;\n        }\n        case \"{\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_OBJECT_START\");\n          break;\n        }\n        case \"[\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_ARRAY_START\");\n          break;\n        }\n      }\n    }\n  }\n  function processAfterObjectValue(char, i) {\n    switch (char) {\n      case \",\": {\n        stack.pop();\n        stack.push(\"INSIDE_OBJECT_AFTER_COMMA\");\n        break;\n      }\n      case \"}\": {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n  function processAfterArrayValue(char, i) {\n    switch (char) {\n      case \",\": {\n        stack.pop();\n        stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n        break;\n      }\n      case \"]\": {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i];\n    const currentState = stack[stack.length - 1];\n    switch (currentState) {\n      case \"ROOT\":\n        processValueStart(char, i, \"FINISH\");\n        break;\n      case \"INSIDE_OBJECT_START\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_KEY\");\n            break;\n          }\n          case \"}\": {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_AFTER_COMMA\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_KEY\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_KEY\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_AFTER_KEY\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_AFTER_KEY\": {\n        switch (char) {\n          case \":\": {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_BEFORE_VALUE\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_BEFORE_VALUE\": {\n        processValueStart(char, i, \"INSIDE_OBJECT_AFTER_VALUE\");\n        break;\n      }\n      case \"INSIDE_OBJECT_AFTER_VALUE\": {\n        processAfterObjectValue(char, i);\n        break;\n      }\n      case \"INSIDE_STRING\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            lastValidIndex = i;\n            break;\n          }\n          case \"\\\\\": {\n            stack.push(\"INSIDE_STRING_ESCAPE\");\n            break;\n          }\n          default: {\n            lastValidIndex = i;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_ARRAY_START\": {\n        switch (char) {\n          case \"]\": {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n          default: {\n            lastValidIndex = i;\n            processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_ARRAY_AFTER_VALUE\": {\n        switch (char) {\n          case \",\": {\n            stack.pop();\n            stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n            break;\n          }\n          case \"]\": {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n          default: {\n            lastValidIndex = i;\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_ARRAY_AFTER_COMMA\": {\n        processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n        break;\n      }\n      case \"INSIDE_STRING_ESCAPE\": {\n        stack.pop();\n        lastValidIndex = i;\n        break;\n      }\n      case \"INSIDE_NUMBER\": {\n        switch (char) {\n          case \"0\":\n          case \"1\":\n          case \"2\":\n          case \"3\":\n          case \"4\":\n          case \"5\":\n          case \"6\":\n          case \"7\":\n          case \"8\":\n          case \"9\": {\n            lastValidIndex = i;\n            break;\n          }\n          case \"e\":\n          case \"E\":\n          case \"-\":\n          case \".\": {\n            break;\n          }\n          case \",\": {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n              processAfterArrayValue(char, i);\n            }\n            if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n              processAfterObjectValue(char, i);\n            }\n            break;\n          }\n          case \"}\": {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n              processAfterObjectValue(char, i);\n            }\n            break;\n          }\n          case \"]\": {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n              processAfterArrayValue(char, i);\n            }\n            break;\n          }\n          default: {\n            stack.pop();\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_LITERAL\": {\n        const partialLiteral = input.substring(literalStart, i + 1);\n        if (!\"false\".startsWith(partialLiteral) && !\"true\".startsWith(partialLiteral) && !\"null\".startsWith(partialLiteral)) {\n          stack.pop();\n          if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n            processAfterObjectValue(char, i);\n          } else if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n            processAfterArrayValue(char, i);\n          }\n        } else {\n          lastValidIndex = i;\n        }\n        break;\n      }\n    }\n  }\n  let result = input.slice(0, lastValidIndex + 1);\n  for (let i = stack.length - 1; i >= 0; i--) {\n    const state = stack[i];\n    switch (state) {\n      case \"INSIDE_STRING\": {\n        result += '\"';\n        break;\n      }\n      case \"INSIDE_OBJECT_KEY\":\n      case \"INSIDE_OBJECT_AFTER_KEY\":\n      case \"INSIDE_OBJECT_AFTER_COMMA\":\n      case \"INSIDE_OBJECT_START\":\n      case \"INSIDE_OBJECT_BEFORE_VALUE\":\n      case \"INSIDE_OBJECT_AFTER_VALUE\": {\n        result += \"}\";\n        break;\n      }\n      case \"INSIDE_ARRAY_START\":\n      case \"INSIDE_ARRAY_AFTER_COMMA\":\n      case \"INSIDE_ARRAY_AFTER_VALUE\": {\n        result += \"]\";\n        break;\n      }\n      case \"INSIDE_LITERAL\": {\n        const partialLiteral = input.substring(literalStart, input.length);\n        if (\"true\".startsWith(partialLiteral)) {\n          result += \"true\".slice(partialLiteral.length);\n        } else if (\"false\".startsWith(partialLiteral)) {\n          result += \"false\".slice(partialLiteral.length);\n        } else if (\"null\".startsWith(partialLiteral)) {\n          result += \"null\".slice(partialLiteral.length);\n        }\n      }\n    }\n  }\n  return result;\n}\n\n// core/util/parse-partial-json.ts\nfunction parsePartialJson(jsonText) {\n  if (jsonText == null) {\n    return void 0;\n  }\n  try {\n    return secure_json_parse__WEBPACK_IMPORTED_MODULE_3__.parse(jsonText);\n  } catch (ignored) {\n    try {\n      const fixedJsonText = fixJson(jsonText);\n      return secure_json_parse__WEBPACK_IMPORTED_MODULE_3__.parse(fixedJsonText);\n    } catch (ignored2) {\n    }\n  }\n  return void 0;\n}\n\n// core/generate-object/stream-object.ts\nasync function streamObject({\n  model,\n  schema,\n  mode,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  ...settings\n}) {\n  const retry = retryWithExponentialBackoff({ maxRetries });\n  const jsonSchema = convertZodToJSONSchema(schema);\n  if (mode === \"auto\" || mode == null) {\n    mode = model.defaultObjectGenerationMode;\n  }\n  let callOptions;\n  let transformer;\n  switch (mode) {\n    case \"json\": {\n      const validatedPrompt = getValidatedPrompt({\n        system: injectJsonSchemaIntoSystem({ system, schema: jsonSchema }),\n        prompt,\n        messages\n      });\n      callOptions = {\n        mode: { type: \"object-json\" },\n        ...prepareCallSettings(settings),\n        inputFormat: validatedPrompt.type,\n        prompt: convertToLanguageModelPrompt(validatedPrompt),\n        abortSignal\n      };\n      transformer = {\n        transform: (chunk, controller) => {\n          switch (chunk.type) {\n            case \"text-delta\":\n              controller.enqueue(chunk.textDelta);\n              break;\n            case \"finish\":\n            case \"error\":\n              controller.enqueue(chunk);\n              break;\n          }\n        }\n      };\n      break;\n    }\n    case \"grammar\": {\n      const validatedPrompt = getValidatedPrompt({\n        system: injectJsonSchemaIntoSystem({ system, schema: jsonSchema }),\n        prompt,\n        messages\n      });\n      callOptions = {\n        mode: { type: \"object-grammar\", schema: jsonSchema },\n        ...settings,\n        inputFormat: validatedPrompt.type,\n        prompt: convertToLanguageModelPrompt(validatedPrompt),\n        abortSignal\n      };\n      transformer = {\n        transform: (chunk, controller) => {\n          switch (chunk.type) {\n            case \"text-delta\":\n              controller.enqueue(chunk.textDelta);\n              break;\n            case \"finish\":\n            case \"error\":\n              controller.enqueue(chunk);\n              break;\n          }\n        }\n      };\n      break;\n    }\n    case \"tool\": {\n      const validatedPrompt = getValidatedPrompt({\n        system,\n        prompt,\n        messages\n      });\n      callOptions = {\n        mode: {\n          type: \"object-tool\",\n          tool: {\n            type: \"function\",\n            name: \"json\",\n            description: \"Respond with a JSON object.\",\n            parameters: jsonSchema\n          }\n        },\n        ...settings,\n        inputFormat: validatedPrompt.type,\n        prompt: convertToLanguageModelPrompt(validatedPrompt),\n        abortSignal\n      };\n      transformer = {\n        transform(chunk, controller) {\n          switch (chunk.type) {\n            case \"tool-call-delta\":\n              controller.enqueue(chunk.argsTextDelta);\n              break;\n            case \"finish\":\n            case \"error\":\n              controller.enqueue(chunk);\n              break;\n          }\n        }\n      };\n      break;\n    }\n    case void 0: {\n      throw new Error(\"Model does not have a default object generation mode.\");\n    }\n    default: {\n      const _exhaustiveCheck = mode;\n      throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);\n    }\n  }\n  const result = await retry(() => model.doStream(callOptions));\n  return new StreamObjectResult({\n    stream: result.stream.pipeThrough(new TransformStream(transformer)),\n    warnings: result.warnings,\n    rawResponse: result.rawResponse\n  });\n}\nvar StreamObjectResult = class {\n  constructor({\n    stream,\n    warnings,\n    rawResponse\n  }) {\n    this.originalStream = stream;\n    this.warnings = warnings;\n    this.rawResponse = rawResponse;\n  }\n  get partialObjectStream() {\n    let accumulatedText = \"\";\n    let latestObject = void 0;\n    return createAsyncIterableStream(this.originalStream, {\n      transform(chunk, controller) {\n        if (typeof chunk === \"string\") {\n          accumulatedText += chunk;\n          const currentObject = parsePartialJson(\n            accumulatedText\n          );\n          if (!isDeepEqualData(latestObject, currentObject)) {\n            latestObject = currentObject;\n            controller.enqueue(currentObject);\n          }\n        } else if (chunk.type === \"error\") {\n          throw chunk.error;\n        }\n      }\n    });\n  }\n  get fullStream() {\n    let accumulatedText = \"\";\n    let latestObject = void 0;\n    return createAsyncIterableStream(this.originalStream, {\n      transform(chunk, controller) {\n        if (typeof chunk === \"string\") {\n          accumulatedText += chunk;\n          const currentObject = parsePartialJson(\n            accumulatedText\n          );\n          if (!isDeepEqualData(latestObject, currentObject)) {\n            latestObject = currentObject;\n            controller.enqueue({ type: \"object\", object: currentObject });\n          }\n        } else {\n          switch (chunk.type) {\n            case \"finish\":\n              controller.enqueue({\n                ...chunk,\n                usage: calculateTokenUsage(chunk.usage)\n              });\n              break;\n            default:\n              controller.enqueue(chunk);\n              break;\n          }\n        }\n      }\n    });\n  }\n};\nvar experimental_streamObject = streamObject;\n\n// core/generate-text/tool-call.ts\n\n\nfunction parseToolCall({\n  toolCall,\n  tools\n}) {\n  const toolName = toolCall.toolName;\n  if (tools == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchToolError({ toolName: toolCall.toolName });\n  }\n  const tool2 = tools[toolName];\n  if (tool2 == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchToolError({\n      toolName: toolCall.toolName,\n      availableTools: Object.keys(tools)\n    });\n  }\n  const parseResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.safeParseJSON)({\n    text: toolCall.args,\n    schema: tool2.parameters\n  });\n  if (parseResult.success === false) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidToolArgumentsError({\n      toolName,\n      toolArgs: toolCall.args,\n      cause: parseResult.error\n    });\n  }\n  return {\n    type: \"tool-call\",\n    toolCallId: toolCall.toolCallId,\n    toolName,\n    args: parseResult.value\n  };\n}\n\n// core/generate-text/generate-text.ts\nasync function generateText({\n  model,\n  tools,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  ...settings\n}) {\n  var _a, _b;\n  const retry = retryWithExponentialBackoff({ maxRetries });\n  const validatedPrompt = getValidatedPrompt({ system, prompt, messages });\n  const modelResponse = await retry(() => {\n    return model.doGenerate({\n      mode: {\n        type: \"regular\",\n        tools: tools == null ? void 0 : Object.entries(tools).map(([name, tool2]) => ({\n          type: \"function\",\n          name,\n          description: tool2.description,\n          parameters: convertZodToJSONSchema(tool2.parameters)\n        }))\n      },\n      ...prepareCallSettings(settings),\n      inputFormat: validatedPrompt.type,\n      prompt: convertToLanguageModelPrompt(validatedPrompt),\n      abortSignal\n    });\n  });\n  const toolCalls = [];\n  for (const modelToolCall of (_a = modelResponse.toolCalls) != null ? _a : []) {\n    toolCalls.push(parseToolCall({ toolCall: modelToolCall, tools }));\n  }\n  const toolResults = tools == null ? [] : await executeTools({ toolCalls, tools });\n  return new GenerateTextResult({\n    // Always return a string so that the caller doesn't have to check for undefined.\n    // If they need to check if the model did not return any text,\n    // they can check the length of the string:\n    text: (_b = modelResponse.text) != null ? _b : \"\",\n    toolCalls,\n    toolResults,\n    finishReason: modelResponse.finishReason,\n    usage: calculateTokenUsage(modelResponse.usage),\n    warnings: modelResponse.warnings,\n    rawResponse: modelResponse.rawResponse,\n    logprobs: modelResponse.logprobs\n  });\n}\nasync function executeTools({\n  toolCalls,\n  tools\n}) {\n  const toolResults = await Promise.all(\n    toolCalls.map(async (toolCall) => {\n      const tool2 = tools[toolCall.toolName];\n      if ((tool2 == null ? void 0 : tool2.execute) == null) {\n        return void 0;\n      }\n      const result = await tool2.execute(toolCall.args);\n      return {\n        toolCallId: toolCall.toolCallId,\n        toolName: toolCall.toolName,\n        args: toolCall.args,\n        result\n      };\n    })\n  );\n  return toolResults.filter(\n    (result) => result != null\n  );\n}\nvar GenerateTextResult = class {\n  constructor(options) {\n    this.text = options.text;\n    this.toolCalls = options.toolCalls;\n    this.toolResults = options.toolResults;\n    this.finishReason = options.finishReason;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.rawResponse = options.rawResponse;\n    this.logprobs = options.logprobs;\n  }\n};\nvar experimental_generateText = generateText;\n\n// core/generate-text/run-tools-transformation.ts\n\n\n// shared/generate-id.ts\n\nvar generateId = (0,nanoid_non_secure__WEBPACK_IMPORTED_MODULE_4__.customAlphabet)(\n  \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\",\n  7\n);\n\n// core/generate-text/run-tools-transformation.ts\nfunction runToolsTransformation({\n  tools,\n  generatorStream\n}) {\n  let canClose = false;\n  const outstandingToolCalls = /* @__PURE__ */ new Set();\n  let toolResultsStreamController = null;\n  const toolResultsStream = new ReadableStream({\n    start(controller) {\n      toolResultsStreamController = controller;\n    }\n  });\n  const forwardStream = new TransformStream({\n    transform(chunk, controller) {\n      const chunkType = chunk.type;\n      switch (chunkType) {\n        case \"text-delta\":\n        case \"error\": {\n          controller.enqueue(chunk);\n          break;\n        }\n        case \"tool-call\": {\n          const toolName = chunk.toolName;\n          if (tools == null) {\n            toolResultsStreamController.enqueue({\n              type: \"error\",\n              error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchToolError({ toolName: chunk.toolName })\n            });\n            break;\n          }\n          const tool2 = tools[toolName];\n          if (tool2 == null) {\n            toolResultsStreamController.enqueue({\n              type: \"error\",\n              error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchToolError({\n                toolName: chunk.toolName,\n                availableTools: Object.keys(tools)\n              })\n            });\n            break;\n          }\n          try {\n            const toolCall = parseToolCall({\n              toolCall: chunk,\n              tools\n            });\n            controller.enqueue(toolCall);\n            if (tool2.execute != null) {\n              const toolExecutionId = generateId();\n              outstandingToolCalls.add(toolExecutionId);\n              tool2.execute(toolCall.args).then(\n                (result) => {\n                  toolResultsStreamController.enqueue({\n                    ...toolCall,\n                    type: \"tool-result\",\n                    result\n                  });\n                  outstandingToolCalls.delete(toolExecutionId);\n                  if (canClose && outstandingToolCalls.size === 0) {\n                    toolResultsStreamController.close();\n                  }\n                },\n                (error) => {\n                  toolResultsStreamController.enqueue({\n                    type: \"error\",\n                    error\n                  });\n                  outstandingToolCalls.delete(toolExecutionId);\n                  if (canClose && outstandingToolCalls.size === 0) {\n                    toolResultsStreamController.close();\n                  }\n                }\n              );\n            }\n          } catch (error) {\n            toolResultsStreamController.enqueue({\n              type: \"error\",\n              error\n            });\n          }\n          break;\n        }\n        case \"finish\": {\n          controller.enqueue({\n            type: \"finish\",\n            finishReason: chunk.finishReason,\n            logprobs: chunk.logprobs,\n            usage: calculateTokenUsage(chunk.usage)\n          });\n          break;\n        }\n        case \"tool-call-delta\": {\n          break;\n        }\n        default: {\n          const _exhaustiveCheck = chunkType;\n          throw new Error(`Unhandled chunk type: ${_exhaustiveCheck}`);\n        }\n      }\n    },\n    flush() {\n      canClose = true;\n      if (outstandingToolCalls.size === 0) {\n        toolResultsStreamController.close();\n      }\n    }\n  });\n  return new ReadableStream({\n    async start(controller) {\n      return Promise.all([\n        generatorStream.pipeThrough(forwardStream).pipeTo(\n          new WritableStream({\n            write(chunk) {\n              controller.enqueue(chunk);\n            },\n            close() {\n            }\n          })\n        ),\n        toolResultsStream.pipeTo(\n          new WritableStream({\n            write(chunk) {\n              controller.enqueue(chunk);\n            },\n            close() {\n              controller.close();\n            }\n          })\n        )\n      ]);\n    }\n  });\n}\n\n// core/generate-text/stream-text.ts\nasync function streamText({\n  model,\n  tools,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  ...settings\n}) {\n  const retry = retryWithExponentialBackoff({ maxRetries });\n  const validatedPrompt = getValidatedPrompt({ system, prompt, messages });\n  const { stream, warnings, rawResponse } = await retry(\n    () => model.doStream({\n      mode: {\n        type: \"regular\",\n        tools: tools == null ? void 0 : Object.entries(tools).map(([name, tool2]) => ({\n          type: \"function\",\n          name,\n          description: tool2.description,\n          parameters: convertZodToJSONSchema(tool2.parameters)\n        }))\n      },\n      ...prepareCallSettings(settings),\n      inputFormat: validatedPrompt.type,\n      prompt: convertToLanguageModelPrompt(validatedPrompt),\n      abortSignal\n    })\n  );\n  return new StreamTextResult({\n    stream: runToolsTransformation({\n      tools,\n      generatorStream: stream\n    }),\n    warnings,\n    rawResponse\n  });\n}\nvar StreamTextResult = class {\n  constructor({\n    stream,\n    warnings,\n    rawResponse\n  }) {\n    this.warnings = warnings;\n    this.rawResponse = rawResponse;\n    let resolveUsage;\n    this.usage = new Promise((resolve) => {\n      resolveUsage = resolve;\n    });\n    let resolveFinishReason;\n    this.finishReason = new Promise((resolve) => {\n      resolveFinishReason = resolve;\n    });\n    this.originalStream = stream.pipeThrough(\n      new TransformStream({\n        async transform(chunk, controller) {\n          controller.enqueue(chunk);\n          if (chunk.type === \"finish\") {\n            resolveUsage(chunk.usage);\n            resolveFinishReason(chunk.finishReason);\n          }\n        }\n      })\n    );\n  }\n  /**\n  Split out a new stream from the original stream.\n  The original stream is replaced to allow for further splitting,\n  since we do not know how many times the stream will be split.\n  \n  Note: this leads to buffering the stream content on the server.\n  However, the LLM results are expected to be small enough to not cause issues.\n     */\n  teeStream() {\n    const [stream1, stream2] = this.originalStream.tee();\n    this.originalStream = stream2;\n    return stream1;\n  }\n  /**\n  A text stream that returns only the generated text deltas. You can use it\n  as either an AsyncIterable or a ReadableStream. When an error occurs, the\n  stream will throw the error.\n     */\n  get textStream() {\n    return createAsyncIterableStream(this.teeStream(), {\n      transform(chunk, controller) {\n        if (chunk.type === \"text-delta\") {\n          if (chunk.textDelta.length > 0) {\n            controller.enqueue(chunk.textDelta);\n          }\n        } else if (chunk.type === \"error\") {\n          throw chunk.error;\n        }\n      }\n    });\n  }\n  /**\n  A stream with all events, including text deltas, tool calls, tool results, and\n  errors.\n  You can use it as either an AsyncIterable or a ReadableStream. When an error occurs, the\n  stream will throw the error.\n     */\n  get fullStream() {\n    return createAsyncIterableStream(this.teeStream(), {\n      transform(chunk, controller) {\n        if (chunk.type === \"text-delta\") {\n          if (chunk.textDelta.length > 0) {\n            controller.enqueue(chunk);\n          }\n        } else {\n          controller.enqueue(chunk);\n        }\n      }\n    });\n  }\n  /**\n  Converts the result to an `AIStream` object that is compatible with `StreamingTextResponse`.\n  It can be used with the `useChat` and `useCompletion` hooks.\n  \n  @param callbacks \n  Stream callbacks that will be called when the stream emits events.\n  \n  @returns an `AIStream` object.\n     */\n  toAIStream(callbacks = {}) {\n    let aggregatedResponse = \"\";\n    const callbackTransformer = new TransformStream({\n      async start() {\n        if (callbacks.onStart)\n          await callbacks.onStart();\n      },\n      async transform(chunk, controller) {\n        controller.enqueue(chunk);\n        if (chunk.type === \"text-delta\") {\n          const textDelta = chunk.textDelta;\n          aggregatedResponse += textDelta;\n          if (callbacks.onToken)\n            await callbacks.onToken(textDelta);\n          if (callbacks.onText)\n            await callbacks.onText(textDelta);\n        }\n      },\n      async flush() {\n        if (callbacks.onCompletion)\n          await callbacks.onCompletion(aggregatedResponse);\n        if (callbacks.onFinal)\n          await callbacks.onFinal(aggregatedResponse);\n      }\n    });\n    const streamDataTransformer = new TransformStream({\n      transform: async (chunk, controller) => {\n        switch (chunk.type) {\n          case \"text-delta\":\n            controller.enqueue(formatStreamPart(\"text\", chunk.textDelta));\n            break;\n          case \"tool-call\":\n            controller.enqueue(\n              formatStreamPart(\"tool_call\", {\n                toolCallId: chunk.toolCallId,\n                toolName: chunk.toolName,\n                args: chunk.args\n              })\n            );\n            break;\n          case \"tool-result\":\n            controller.enqueue(\n              formatStreamPart(\"tool_result\", {\n                toolCallId: chunk.toolCallId,\n                toolName: chunk.toolName,\n                args: chunk.args,\n                result: chunk.result\n              })\n            );\n            break;\n          case \"error\":\n            controller.enqueue(\n              formatStreamPart(\"error\", JSON.stringify(chunk.error))\n            );\n            break;\n        }\n      }\n    });\n    return this.fullStream.pipeThrough(callbackTransformer).pipeThrough(streamDataTransformer).pipeThrough(new TextEncoderStream());\n  }\n  /**\n  Writes stream data output to a Node.js response-like object.\n  It sets a `Content-Type` header to `text/plain; charset=utf-8` and \n  writes each stream data part as a separate chunk.\n  \n  @param response A Node.js response-like object (ServerResponse).\n  @param init Optional headers and status code.\n     */\n  pipeAIStreamToResponse(response, init) {\n    var _a;\n    response.writeHead((_a = init == null ? void 0 : init.status) != null ? _a : 200, {\n      \"Content-Type\": \"text/plain; charset=utf-8\",\n      ...init == null ? void 0 : init.headers\n    });\n    const reader = this.textStream.pipeThrough(createCallbacksTransformer(void 0)).pipeThrough(createStreamDataTransformer()).getReader();\n    const read = async () => {\n      try {\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done)\n            break;\n          response.write(value);\n        }\n      } catch (error) {\n        throw error;\n      } finally {\n        response.end();\n      }\n    };\n    read();\n  }\n  /**\n  Writes text delta output to a Node.js response-like object.\n  It sets a `Content-Type` header to `text/plain; charset=utf-8` and \n  writes each text delta as a separate chunk.\n  \n  @param response A Node.js response-like object (ServerResponse).\n  @param init Optional headers and status code.\n     */\n  pipeTextStreamToResponse(response, init) {\n    var _a;\n    response.writeHead((_a = init == null ? void 0 : init.status) != null ? _a : 200, {\n      \"Content-Type\": \"text/plain; charset=utf-8\",\n      ...init == null ? void 0 : init.headers\n    });\n    const reader = this.textStream.getReader();\n    const read = async () => {\n      const encoder = new TextEncoder();\n      try {\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done)\n            break;\n          response.write(encoder.encode(value));\n        }\n      } catch (error) {\n        throw error;\n      } finally {\n        response.end();\n      }\n    };\n    read();\n  }\n  /**\n  Converts the result to a streamed response object with a stream data part stream.\n  It can be used with the `useChat` and `useCompletion` hooks.\n  \n  @param init Optional headers.\n  \n  @return A response object.\n     */\n  toAIStreamResponse(init) {\n    return new StreamingTextResponse(this.toAIStream(), init);\n  }\n  /**\n  Creates a simple text stream response.\n  Each text delta is encoded as UTF-8 and sent as a separate chunk.\n  Non-text-delta events are ignored.\n  \n  @param init Optional headers and status code.\n     */\n  toTextStreamResponse(init) {\n    var _a;\n    const encoder = new TextEncoder();\n    return new Response(\n      this.textStream.pipeThrough(\n        new TransformStream({\n          transform(chunk, controller) {\n            controller.enqueue(encoder.encode(chunk));\n          }\n        })\n      ),\n      {\n        status: (_a = init == null ? void 0 : init.status) != null ? _a : 200,\n        headers: {\n          \"Content-Type\": \"text/plain; charset=utf-8\",\n          ...init == null ? void 0 : init.headers\n        }\n      }\n    );\n  }\n};\nvar experimental_streamText = streamText;\n\n// core/prompt/convert-to-core-messages.ts\nfunction convertToCoreMessages(messages) {\n  const coreMessages = [];\n  for (const { role, content, toolInvocations } of messages) {\n    switch (role) {\n      case \"user\": {\n        coreMessages.push({ role: \"user\", content });\n        break;\n      }\n      case \"assistant\": {\n        if (toolInvocations == null) {\n          coreMessages.push({ role: \"assistant\", content });\n          break;\n        }\n        coreMessages.push({\n          role: \"assistant\",\n          content: [\n            { type: \"text\", text: content },\n            ...toolInvocations.map(({ toolCallId, toolName, args }) => ({\n              type: \"tool-call\",\n              toolCallId,\n              toolName,\n              args\n            }))\n          ]\n        });\n        coreMessages.push({\n          role: \"tool\",\n          content: toolInvocations.map(\n            ({ toolCallId, toolName, args, result }) => ({\n              type: \"tool-result\",\n              toolCallId,\n              toolName,\n              args,\n              result\n            })\n          )\n        });\n        break;\n      }\n      default: {\n        const _exhaustiveCheck = role;\n        throw new Error(`Unhandled role: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n  return coreMessages;\n}\n\n// core/tool/tool.ts\nfunction tool(tool2) {\n  return tool2;\n}\n\n// core/types/errors.ts\n\n\n// shared/stream-parts.ts\nvar textStreamPart = {\n  code: \"0\",\n  name: \"text\",\n  parse: (value) => {\n    if (typeof value !== \"string\") {\n      throw new Error('\"text\" parts expect a string value.');\n    }\n    return { type: \"text\", value };\n  }\n};\nvar functionCallStreamPart = {\n  code: \"1\",\n  name: \"function_call\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"function_call\" in value) || typeof value.function_call !== \"object\" || value.function_call == null || !(\"name\" in value.function_call) || !(\"arguments\" in value.function_call) || typeof value.function_call.name !== \"string\" || typeof value.function_call.arguments !== \"string\") {\n      throw new Error(\n        '\"function_call\" parts expect an object with a \"function_call\" property.'\n      );\n    }\n    return {\n      type: \"function_call\",\n      value\n    };\n  }\n};\nvar dataStreamPart = {\n  code: \"2\",\n  name: \"data\",\n  parse: (value) => {\n    if (!Array.isArray(value)) {\n      throw new Error('\"data\" parts expect an array value.');\n    }\n    return { type: \"data\", value };\n  }\n};\nvar errorStreamPart = {\n  code: \"3\",\n  name: \"error\",\n  parse: (value) => {\n    if (typeof value !== \"string\") {\n      throw new Error('\"error\" parts expect a string value.');\n    }\n    return { type: \"error\", value };\n  }\n};\nvar assistantMessageStreamPart = {\n  code: \"4\",\n  name: \"assistant_message\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"id\" in value) || !(\"role\" in value) || !(\"content\" in value) || typeof value.id !== \"string\" || typeof value.role !== \"string\" || value.role !== \"assistant\" || !Array.isArray(value.content) || !value.content.every(\n      (item) => item != null && typeof item === \"object\" && \"type\" in item && item.type === \"text\" && \"text\" in item && item.text != null && typeof item.text === \"object\" && \"value\" in item.text && typeof item.text.value === \"string\"\n    )) {\n      throw new Error(\n        '\"assistant_message\" parts expect an object with an \"id\", \"role\", and \"content\" property.'\n      );\n    }\n    return {\n      type: \"assistant_message\",\n      value\n    };\n  }\n};\nvar assistantControlDataStreamPart = {\n  code: \"5\",\n  name: \"assistant_control_data\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"threadId\" in value) || !(\"messageId\" in value) || typeof value.threadId !== \"string\" || typeof value.messageId !== \"string\") {\n      throw new Error(\n        '\"assistant_control_data\" parts expect an object with a \"threadId\" and \"messageId\" property.'\n      );\n    }\n    return {\n      type: \"assistant_control_data\",\n      value: {\n        threadId: value.threadId,\n        messageId: value.messageId\n      }\n    };\n  }\n};\nvar dataMessageStreamPart = {\n  code: \"6\",\n  name: \"data_message\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"role\" in value) || !(\"data\" in value) || typeof value.role !== \"string\" || value.role !== \"data\") {\n      throw new Error(\n        '\"data_message\" parts expect an object with a \"role\" and \"data\" property.'\n      );\n    }\n    return {\n      type: \"data_message\",\n      value\n    };\n  }\n};\nvar toolCallsStreamPart = {\n  code: \"7\",\n  name: \"tool_calls\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"tool_calls\" in value) || typeof value.tool_calls !== \"object\" || value.tool_calls == null || !Array.isArray(value.tool_calls) || value.tool_calls.some(\n      (tc) => tc == null || typeof tc !== \"object\" || !(\"id\" in tc) || typeof tc.id !== \"string\" || !(\"type\" in tc) || typeof tc.type !== \"string\" || !(\"function\" in tc) || tc.function == null || typeof tc.function !== \"object\" || !(\"arguments\" in tc.function) || typeof tc.function.name !== \"string\" || typeof tc.function.arguments !== \"string\"\n    )) {\n      throw new Error(\n        '\"tool_calls\" parts expect an object with a ToolCallPayload.'\n      );\n    }\n    return {\n      type: \"tool_calls\",\n      value\n    };\n  }\n};\nvar messageAnnotationsStreamPart = {\n  code: \"8\",\n  name: \"message_annotations\",\n  parse: (value) => {\n    if (!Array.isArray(value)) {\n      throw new Error('\"message_annotations\" parts expect an array value.');\n    }\n    return { type: \"message_annotations\", value };\n  }\n};\nvar toolCallStreamPart = {\n  code: \"9\",\n  name: \"tool_call\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"toolCallId\" in value) || typeof value.toolCallId !== \"string\" || !(\"toolName\" in value) || typeof value.toolName !== \"string\" || !(\"args\" in value) || typeof value.args !== \"object\") {\n      throw new Error(\n        '\"tool_call\" parts expect an object with a \"toolCallId\", \"toolName\", and \"args\" property.'\n      );\n    }\n    return {\n      type: \"tool_call\",\n      value\n    };\n  }\n};\nvar toolResultStreamPart = {\n  code: \"a\",\n  name: \"tool_result\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"toolCallId\" in value) || typeof value.toolCallId !== \"string\" || !(\"toolName\" in value) || typeof value.toolName !== \"string\" || !(\"args\" in value) || typeof value.args !== \"object\" || !(\"result\" in value)) {\n      throw new Error(\n        '\"tool_result\" parts expect an object with a \"toolCallId\", \"toolName\", \"args\", and \"result\" property.'\n      );\n    }\n    return {\n      type: \"tool_result\",\n      value\n    };\n  }\n};\nvar streamParts = [\n  textStreamPart,\n  functionCallStreamPart,\n  dataStreamPart,\n  errorStreamPart,\n  assistantMessageStreamPart,\n  assistantControlDataStreamPart,\n  dataMessageStreamPart,\n  toolCallsStreamPart,\n  messageAnnotationsStreamPart,\n  toolCallStreamPart,\n  toolResultStreamPart\n];\nvar streamPartsByCode = {\n  [textStreamPart.code]: textStreamPart,\n  [functionCallStreamPart.code]: functionCallStreamPart,\n  [dataStreamPart.code]: dataStreamPart,\n  [errorStreamPart.code]: errorStreamPart,\n  [assistantMessageStreamPart.code]: assistantMessageStreamPart,\n  [assistantControlDataStreamPart.code]: assistantControlDataStreamPart,\n  [dataMessageStreamPart.code]: dataMessageStreamPart,\n  [toolCallsStreamPart.code]: toolCallsStreamPart,\n  [messageAnnotationsStreamPart.code]: messageAnnotationsStreamPart,\n  [toolCallStreamPart.code]: toolCallStreamPart,\n  [toolResultStreamPart.code]: toolResultStreamPart\n};\nvar StreamStringPrefixes = {\n  [textStreamPart.name]: textStreamPart.code,\n  [functionCallStreamPart.name]: functionCallStreamPart.code,\n  [dataStreamPart.name]: dataStreamPart.code,\n  [errorStreamPart.name]: errorStreamPart.code,\n  [assistantMessageStreamPart.name]: assistantMessageStreamPart.code,\n  [assistantControlDataStreamPart.name]: assistantControlDataStreamPart.code,\n  [dataMessageStreamPart.name]: dataMessageStreamPart.code,\n  [toolCallsStreamPart.name]: toolCallsStreamPart.code,\n  [messageAnnotationsStreamPart.name]: messageAnnotationsStreamPart.code,\n  [toolCallStreamPart.name]: toolCallStreamPart.code,\n  [toolResultStreamPart.name]: toolResultStreamPart.code\n};\nvar validCodes = streamParts.map((part) => part.code);\nvar parseStreamPart = (line) => {\n  const firstSeparatorIndex = line.indexOf(\":\");\n  if (firstSeparatorIndex === -1) {\n    throw new Error(\"Failed to parse stream string. No separator found.\");\n  }\n  const prefix = line.slice(0, firstSeparatorIndex);\n  if (!validCodes.includes(prefix)) {\n    throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n  }\n  const code = prefix;\n  const textValue = line.slice(firstSeparatorIndex + 1);\n  const jsonValue = JSON.parse(textValue);\n  return streamPartsByCode[code].parse(jsonValue);\n};\nfunction formatStreamPart(type, value) {\n  const streamPart = streamParts.find((part) => part.name === type);\n  if (!streamPart) {\n    throw new Error(`Invalid stream part type: ${type}`);\n  }\n  return `${streamPart.code}:${JSON.stringify(value)}\n`;\n}\n\n// shared/read-data-stream.ts\nvar NEWLINE = \"\\n\".charCodeAt(0);\nfunction concatChunks(chunks, totalLength) {\n  const concatenatedChunks = new Uint8Array(totalLength);\n  let offset = 0;\n  for (const chunk of chunks) {\n    concatenatedChunks.set(chunk, offset);\n    offset += chunk.length;\n  }\n  chunks.length = 0;\n  return concatenatedChunks;\n}\nasync function* readDataStream(reader, {\n  isAborted\n} = {}) {\n  const decoder = new TextDecoder();\n  const chunks = [];\n  let totalLength = 0;\n  while (true) {\n    const { value } = await reader.read();\n    if (value) {\n      chunks.push(value);\n      totalLength += value.length;\n      if (value[value.length - 1] !== NEWLINE) {\n        continue;\n      }\n    }\n    if (chunks.length === 0) {\n      break;\n    }\n    const concatenatedChunks = concatChunks(chunks, totalLength);\n    totalLength = 0;\n    const streamParts2 = decoder.decode(concatenatedChunks, { stream: true }).split(\"\\n\").filter((line) => line !== \"\").map(parseStreamPart);\n    for (const streamPart of streamParts2) {\n      yield streamPart;\n    }\n    if (isAborted == null ? void 0 : isAborted()) {\n      reader.cancel();\n      break;\n    }\n  }\n}\n\n// shared/utils.ts\nfunction createChunkDecoder(complex) {\n  const decoder = new TextDecoder();\n  if (!complex) {\n    return function(chunk) {\n      if (!chunk)\n        return \"\";\n      return decoder.decode(chunk, { stream: true });\n    };\n  }\n  return function(chunk) {\n    const decoded = decoder.decode(chunk, { stream: true }).split(\"\\n\").filter((line) => line !== \"\");\n    return decoded.map(parseStreamPart).filter(Boolean);\n  };\n}\nvar isStreamStringEqualToType = (type, value) => value.startsWith(`${StreamStringPrefixes[type]}:`) && value.endsWith(\"\\n\");\n\n// streams/ai-stream.ts\n\nfunction createEventStreamTransformer(customParser) {\n  const textDecoder = new TextDecoder();\n  let eventSourceParser;\n  return new TransformStream({\n    async start(controller) {\n      eventSourceParser = (0,eventsource_parser__WEBPACK_IMPORTED_MODULE_5__.createParser)(\n        (event) => {\n          if (\"data\" in event && event.type === \"event\" && event.data === \"[DONE]\" || // Replicate doesn't send [DONE] but does send a 'done' event\n          // @see https://replicate.com/docs/streaming\n          event.event === \"done\") {\n            controller.terminate();\n            return;\n          }\n          if (\"data\" in event) {\n            const parsedMessage = customParser ? customParser(event.data, {\n              event: event.event\n            }) : event.data;\n            if (parsedMessage)\n              controller.enqueue(parsedMessage);\n          }\n        }\n      );\n    },\n    transform(chunk) {\n      eventSourceParser.feed(textDecoder.decode(chunk));\n    }\n  });\n}\nfunction createCallbacksTransformer(cb) {\n  const textEncoder = new TextEncoder();\n  let aggregatedResponse = \"\";\n  const callbacks = cb || {};\n  return new TransformStream({\n    async start() {\n      if (callbacks.onStart)\n        await callbacks.onStart();\n    },\n    async transform(message, controller) {\n      const content = typeof message === \"string\" ? message : message.content;\n      controller.enqueue(textEncoder.encode(content));\n      aggregatedResponse += content;\n      if (callbacks.onToken)\n        await callbacks.onToken(content);\n      if (callbacks.onText && typeof message === \"string\") {\n        await callbacks.onText(message);\n      }\n    },\n    async flush() {\n      const isOpenAICallbacks = isOfTypeOpenAIStreamCallbacks(callbacks);\n      if (callbacks.onCompletion) {\n        await callbacks.onCompletion(aggregatedResponse);\n      }\n      if (callbacks.onFinal && !isOpenAICallbacks) {\n        await callbacks.onFinal(aggregatedResponse);\n      }\n    }\n  });\n}\nfunction isOfTypeOpenAIStreamCallbacks(callbacks) {\n  return \"experimental_onFunctionCall\" in callbacks;\n}\nfunction trimStartOfStreamHelper() {\n  let isStreamStart = true;\n  return (text) => {\n    if (isStreamStart) {\n      text = text.trimStart();\n      if (text)\n        isStreamStart = false;\n    }\n    return text;\n  };\n}\nfunction AIStream(response, customParser, callbacks) {\n  if (!response.ok) {\n    if (response.body) {\n      const reader = response.body.getReader();\n      return new ReadableStream({\n        async start(controller) {\n          const { done, value } = await reader.read();\n          if (!done) {\n            const errorText = new TextDecoder().decode(value);\n            controller.error(new Error(`Response error: ${errorText}`));\n          }\n        }\n      });\n    } else {\n      return new ReadableStream({\n        start(controller) {\n          controller.error(new Error(\"Response error: No response body\"));\n        }\n      });\n    }\n  }\n  const responseBodyStream = response.body || createEmptyReadableStream();\n  return responseBodyStream.pipeThrough(createEventStreamTransformer(customParser)).pipeThrough(createCallbacksTransformer(callbacks));\n}\nfunction createEmptyReadableStream() {\n  return new ReadableStream({\n    start(controller) {\n      controller.close();\n    }\n  });\n}\nfunction readableFromAsyncIterable(iterable) {\n  let it = iterable[Symbol.asyncIterator]();\n  return new ReadableStream({\n    async pull(controller) {\n      const { done, value } = await it.next();\n      if (done)\n        controller.close();\n      else\n        controller.enqueue(value);\n    },\n    async cancel(reason) {\n      var _a;\n      await ((_a = it.return) == null ? void 0 : _a.call(it, reason));\n    }\n  });\n}\n\n// streams/stream-data.ts\nvar StreamData = class {\n  constructor() {\n    this.encoder = new TextEncoder();\n    this.controller = null;\n    // closing the stream is synchronous, but we want to return a promise\n    // in case we're doing async work\n    this.isClosedPromise = null;\n    this.isClosedPromiseResolver = void 0;\n    this.isClosed = false;\n    // array to store appended data\n    this.data = [];\n    this.messageAnnotations = [];\n    this.isClosedPromise = new Promise((resolve) => {\n      this.isClosedPromiseResolver = resolve;\n    });\n    const self = this;\n    this.stream = new TransformStream({\n      start: async (controller) => {\n        self.controller = controller;\n      },\n      transform: async (chunk, controller) => {\n        if (self.data.length > 0) {\n          const encodedData = self.encoder.encode(\n            formatStreamPart(\"data\", self.data)\n          );\n          self.data = [];\n          controller.enqueue(encodedData);\n        }\n        if (self.messageAnnotations.length) {\n          const encodedMessageAnnotations = self.encoder.encode(\n            formatStreamPart(\"message_annotations\", self.messageAnnotations)\n          );\n          self.messageAnnotations = [];\n          controller.enqueue(encodedMessageAnnotations);\n        }\n        controller.enqueue(chunk);\n      },\n      async flush(controller) {\n        const warningTimeout =  true ? setTimeout(() => {\n          console.warn(\n            \"The data stream is hanging. Did you forget to close it with `data.close()`?\"\n          );\n        }, 3e3) : 0;\n        await self.isClosedPromise;\n        if (warningTimeout !== null) {\n          clearTimeout(warningTimeout);\n        }\n        if (self.data.length) {\n          const encodedData = self.encoder.encode(\n            formatStreamPart(\"data\", self.data)\n          );\n          controller.enqueue(encodedData);\n        }\n        if (self.messageAnnotations.length) {\n          const encodedData = self.encoder.encode(\n            formatStreamPart(\"message_annotations\", self.messageAnnotations)\n          );\n          controller.enqueue(encodedData);\n        }\n      }\n    });\n  }\n  async close() {\n    var _a;\n    if (this.isClosed) {\n      throw new Error(\"Data Stream has already been closed.\");\n    }\n    if (!this.controller) {\n      throw new Error(\"Stream controller is not initialized.\");\n    }\n    (_a = this.isClosedPromiseResolver) == null ? void 0 : _a.call(this);\n    this.isClosed = true;\n  }\n  append(value) {\n    if (this.isClosed) {\n      throw new Error(\"Data Stream has already been closed.\");\n    }\n    this.data.push(value);\n  }\n  appendMessageAnnotation(value) {\n    if (this.isClosed) {\n      throw new Error(\"Data Stream has already been closed.\");\n    }\n    this.messageAnnotations.push(value);\n  }\n};\nfunction createStreamDataTransformer() {\n  const encoder = new TextEncoder();\n  const decoder = new TextDecoder();\n  return new TransformStream({\n    transform: async (chunk, controller) => {\n      const message = decoder.decode(chunk);\n      controller.enqueue(encoder.encode(formatStreamPart(\"text\", message)));\n    }\n  });\n}\nvar experimental_StreamData = class extends StreamData {\n};\n\n// streams/anthropic-stream.ts\nfunction parseAnthropicStream() {\n  let previous = \"\";\n  return (data) => {\n    const json = JSON.parse(data);\n    if (\"error\" in json) {\n      throw new Error(`${json.error.type}: ${json.error.message}`);\n    }\n    if (!(\"completion\" in json)) {\n      return;\n    }\n    const text = json.completion;\n    if (!previous || text.length > previous.length && text.startsWith(previous)) {\n      const delta = text.slice(previous.length);\n      previous = text;\n      return delta;\n    }\n    return text;\n  };\n}\nasync function* streamable(stream) {\n  for await (const chunk of stream) {\n    if (\"completion\" in chunk) {\n      const text = chunk.completion;\n      if (text)\n        yield text;\n    } else if (\"delta\" in chunk) {\n      const { delta } = chunk;\n      if (\"text\" in delta) {\n        const text = delta.text;\n        if (text)\n          yield text;\n      }\n    }\n  }\n}\nfunction AnthropicStream(res, cb) {\n  if (Symbol.asyncIterator in res) {\n    return readableFromAsyncIterable(streamable(res)).pipeThrough(createCallbacksTransformer(cb)).pipeThrough(createStreamDataTransformer());\n  } else {\n    return AIStream(res, parseAnthropicStream(), cb).pipeThrough(\n      createStreamDataTransformer()\n    );\n  }\n}\n\n// streams/assistant-response.ts\nfunction AssistantResponse({ threadId, messageId }, process2) {\n  const stream = new ReadableStream({\n    async start(controller) {\n      var _a;\n      const textEncoder = new TextEncoder();\n      const sendMessage = (message) => {\n        controller.enqueue(\n          textEncoder.encode(formatStreamPart(\"assistant_message\", message))\n        );\n      };\n      const sendDataMessage = (message) => {\n        controller.enqueue(\n          textEncoder.encode(formatStreamPart(\"data_message\", message))\n        );\n      };\n      const sendError = (errorMessage) => {\n        controller.enqueue(\n          textEncoder.encode(formatStreamPart(\"error\", errorMessage))\n        );\n      };\n      const forwardStream = async (stream2) => {\n        var _a2, _b;\n        let result = void 0;\n        for await (const value of stream2) {\n          switch (value.event) {\n            case \"thread.message.created\": {\n              controller.enqueue(\n                textEncoder.encode(\n                  formatStreamPart(\"assistant_message\", {\n                    id: value.data.id,\n                    role: \"assistant\",\n                    content: [{ type: \"text\", text: { value: \"\" } }]\n                  })\n                )\n              );\n              break;\n            }\n            case \"thread.message.delta\": {\n              const content = (_a2 = value.data.delta.content) == null ? void 0 : _a2[0];\n              if ((content == null ? void 0 : content.type) === \"text\" && ((_b = content.text) == null ? void 0 : _b.value) != null) {\n                controller.enqueue(\n                  textEncoder.encode(\n                    formatStreamPart(\"text\", content.text.value)\n                  )\n                );\n              }\n              break;\n            }\n            case \"thread.run.completed\":\n            case \"thread.run.requires_action\": {\n              result = value.data;\n              break;\n            }\n          }\n        }\n        return result;\n      };\n      controller.enqueue(\n        textEncoder.encode(\n          formatStreamPart(\"assistant_control_data\", {\n            threadId,\n            messageId\n          })\n        )\n      );\n      try {\n        await process2({\n          threadId,\n          messageId,\n          sendMessage,\n          sendDataMessage,\n          forwardStream\n        });\n      } catch (error) {\n        sendError((_a = error.message) != null ? _a : `${error}`);\n      } finally {\n        controller.close();\n      }\n    },\n    pull(controller) {\n    },\n    cancel() {\n    }\n  });\n  return new Response(stream, {\n    status: 200,\n    headers: {\n      \"Content-Type\": \"text/plain; charset=utf-8\"\n    }\n  });\n}\nvar experimental_AssistantResponse = AssistantResponse;\n\n// streams/aws-bedrock-stream.ts\nasync function* asDeltaIterable(response, extractTextDeltaFromChunk) {\n  var _a, _b;\n  const decoder = new TextDecoder();\n  for await (const chunk of (_a = response.body) != null ? _a : []) {\n    const bytes = (_b = chunk.chunk) == null ? void 0 : _b.bytes;\n    if (bytes != null) {\n      const chunkText = decoder.decode(bytes);\n      const chunkJSON = JSON.parse(chunkText);\n      const delta = extractTextDeltaFromChunk(chunkJSON);\n      if (delta != null) {\n        yield delta;\n      }\n    }\n  }\n}\nfunction AWSBedrockAnthropicMessagesStream(response, callbacks) {\n  return AWSBedrockStream(response, callbacks, (chunk) => {\n    var _a;\n    return (_a = chunk.delta) == null ? void 0 : _a.text;\n  });\n}\nfunction AWSBedrockAnthropicStream(response, callbacks) {\n  return AWSBedrockStream(response, callbacks, (chunk) => chunk.completion);\n}\nfunction AWSBedrockCohereStream(response, callbacks) {\n  return AWSBedrockStream(response, callbacks, (chunk) => chunk == null ? void 0 : chunk.text);\n}\nfunction AWSBedrockLlama2Stream(response, callbacks) {\n  return AWSBedrockStream(response, callbacks, (chunk) => chunk.generation);\n}\nfunction AWSBedrockStream(response, callbacks, extractTextDeltaFromChunk) {\n  return readableFromAsyncIterable(\n    asDeltaIterable(response, extractTextDeltaFromChunk)\n  ).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\n\n// streams/cohere-stream.ts\nvar utf8Decoder = new TextDecoder(\"utf-8\");\nasync function processLines(lines, controller) {\n  for (const line of lines) {\n    const { text, is_finished } = JSON.parse(line);\n    if (!is_finished) {\n      controller.enqueue(text);\n    }\n  }\n}\nasync function readAndProcessLines(reader, controller) {\n  let segment = \"\";\n  while (true) {\n    const { value: chunk, done } = await reader.read();\n    if (done) {\n      break;\n    }\n    segment += utf8Decoder.decode(chunk, { stream: true });\n    const linesArray = segment.split(/\\r\\n|\\n|\\r/g);\n    segment = linesArray.pop() || \"\";\n    await processLines(linesArray, controller);\n  }\n  if (segment) {\n    const linesArray = [segment];\n    await processLines(linesArray, controller);\n  }\n  controller.close();\n}\nfunction createParser2(res) {\n  var _a;\n  const reader = (_a = res.body) == null ? void 0 : _a.getReader();\n  return new ReadableStream({\n    async start(controller) {\n      if (!reader) {\n        controller.close();\n        return;\n      }\n      await readAndProcessLines(reader, controller);\n    }\n  });\n}\nasync function* streamable2(stream) {\n  for await (const chunk of stream) {\n    if (chunk.eventType === \"text-generation\") {\n      const text = chunk.text;\n      if (text)\n        yield text;\n    }\n  }\n}\nfunction CohereStream(reader, callbacks) {\n  if (Symbol.asyncIterator in reader) {\n    return readableFromAsyncIterable(streamable2(reader)).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n  } else {\n    return createParser2(reader).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n  }\n}\n\n// streams/google-generative-ai-stream.ts\nasync function* streamable3(response) {\n  var _a, _b, _c;\n  for await (const chunk of response.stream) {\n    const parts = (_c = (_b = (_a = chunk.candidates) == null ? void 0 : _a[0]) == null ? void 0 : _b.content) == null ? void 0 : _c.parts;\n    if (parts === void 0) {\n      continue;\n    }\n    const firstPart = parts[0];\n    if (typeof firstPart.text === \"string\") {\n      yield firstPart.text;\n    }\n  }\n}\nfunction GoogleGenerativeAIStream(response, cb) {\n  return readableFromAsyncIterable(streamable3(response)).pipeThrough(createCallbacksTransformer(cb)).pipeThrough(createStreamDataTransformer());\n}\n\n// streams/huggingface-stream.ts\nfunction createParser3(res) {\n  const trimStartOfStream = trimStartOfStreamHelper();\n  return new ReadableStream({\n    async pull(controller) {\n      var _a, _b;\n      const { value, done } = await res.next();\n      if (done) {\n        controller.close();\n        return;\n      }\n      const text = trimStartOfStream((_b = (_a = value.token) == null ? void 0 : _a.text) != null ? _b : \"\");\n      if (!text)\n        return;\n      if (value.generated_text != null && value.generated_text.length > 0) {\n        return;\n      }\n      if (text === \"</s>\" || text === \"<|endoftext|>\" || text === \"<|end|>\") {\n        return;\n      }\n      controller.enqueue(text);\n    }\n  });\n}\nfunction HuggingFaceStream(res, callbacks) {\n  return createParser3(res).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\n\n// streams/inkeep-stream.ts\nfunction InkeepStream(res, callbacks) {\n  if (!res.body) {\n    throw new Error(\"Response body is null\");\n  }\n  let chat_session_id = \"\";\n  let records_cited;\n  const inkeepEventParser = (data, options) => {\n    var _a, _b;\n    const { event } = options;\n    if (event === \"records_cited\") {\n      records_cited = JSON.parse(data);\n      (_a = callbacks == null ? void 0 : callbacks.onRecordsCited) == null ? void 0 : _a.call(callbacks, records_cited);\n    }\n    if (event === \"message_chunk\") {\n      const inkeepMessageChunk = JSON.parse(data);\n      chat_session_id = (_b = inkeepMessageChunk.chat_session_id) != null ? _b : chat_session_id;\n      return inkeepMessageChunk.content_chunk;\n    }\n    return;\n  };\n  let { onRecordsCited, ...passThroughCallbacks } = callbacks || {};\n  passThroughCallbacks = {\n    ...passThroughCallbacks,\n    onFinal: (completion) => {\n      var _a;\n      const inkeepOnFinalMetadata = {\n        chat_session_id,\n        records_cited\n      };\n      (_a = callbacks == null ? void 0 : callbacks.onFinal) == null ? void 0 : _a.call(callbacks, completion, inkeepOnFinalMetadata);\n    }\n  };\n  return AIStream(res, inkeepEventParser, passThroughCallbacks).pipeThrough(\n    createStreamDataTransformer()\n  );\n}\n\n// streams/langchain-adapter.ts\nvar langchain_adapter_exports = {};\n__export(langchain_adapter_exports, {\n  toAIStream: () => toAIStream\n});\nfunction toAIStream(stream, callbacks) {\n  return stream.pipeThrough(\n    new TransformStream({\n      transform: async (chunk, controller) => {\n        if (typeof chunk.content === \"string\") {\n          controller.enqueue(chunk.content);\n        } else {\n          const content = chunk.content;\n          for (const item of content) {\n            if (item.type === \"text\") {\n              controller.enqueue(item.text);\n            }\n          }\n        }\n      }\n    })\n  ).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\n\n// streams/langchain-stream.ts\nfunction LangChainStream(callbacks) {\n  const stream = new TransformStream();\n  const writer = stream.writable.getWriter();\n  const runs = /* @__PURE__ */ new Set();\n  const handleError = async (e, runId) => {\n    runs.delete(runId);\n    await writer.ready;\n    await writer.abort(e);\n  };\n  const handleStart = async (runId) => {\n    runs.add(runId);\n  };\n  const handleEnd = async (runId) => {\n    runs.delete(runId);\n    if (runs.size === 0) {\n      await writer.ready;\n      await writer.close();\n    }\n  };\n  return {\n    stream: stream.readable.pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer()),\n    writer,\n    handlers: {\n      handleLLMNewToken: async (token) => {\n        await writer.ready;\n        await writer.write(token);\n      },\n      handleLLMStart: async (_llm, _prompts, runId) => {\n        handleStart(runId);\n      },\n      handleLLMEnd: async (_output, runId) => {\n        await handleEnd(runId);\n      },\n      handleLLMError: async (e, runId) => {\n        await handleError(e, runId);\n      },\n      handleChainStart: async (_chain, _inputs, runId) => {\n        handleStart(runId);\n      },\n      handleChainEnd: async (_outputs, runId) => {\n        await handleEnd(runId);\n      },\n      handleChainError: async (e, runId) => {\n        await handleError(e, runId);\n      },\n      handleToolStart: async (_tool, _input, runId) => {\n        handleStart(runId);\n      },\n      handleToolEnd: async (_output, runId) => {\n        await handleEnd(runId);\n      },\n      handleToolError: async (e, runId) => {\n        await handleError(e, runId);\n      }\n    }\n  };\n}\n\n// streams/mistral-stream.ts\nasync function* streamable4(stream) {\n  var _a, _b;\n  for await (const chunk of stream) {\n    const content = (_b = (_a = chunk.choices[0]) == null ? void 0 : _a.delta) == null ? void 0 : _b.content;\n    if (content === void 0 || content === \"\") {\n      continue;\n    }\n    yield content;\n  }\n}\nfunction MistralStream(response, callbacks) {\n  const stream = readableFromAsyncIterable(streamable4(response));\n  return stream.pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\n\n// streams/openai-stream.ts\nfunction parseOpenAIStream() {\n  const extract = chunkToText();\n  return (data) => extract(JSON.parse(data));\n}\nasync function* streamable5(stream) {\n  const extract = chunkToText();\n  for await (let chunk of stream) {\n    if (\"promptFilterResults\" in chunk) {\n      chunk = {\n        id: chunk.id,\n        created: chunk.created.getDate(),\n        object: chunk.object,\n        // not exposed by Azure API\n        model: chunk.model,\n        // not exposed by Azure API\n        choices: chunk.choices.map((choice) => {\n          var _a, _b, _c, _d, _e, _f, _g;\n          return {\n            delta: {\n              content: (_a = choice.delta) == null ? void 0 : _a.content,\n              function_call: (_b = choice.delta) == null ? void 0 : _b.functionCall,\n              role: (_c = choice.delta) == null ? void 0 : _c.role,\n              tool_calls: ((_e = (_d = choice.delta) == null ? void 0 : _d.toolCalls) == null ? void 0 : _e.length) ? (_g = (_f = choice.delta) == null ? void 0 : _f.toolCalls) == null ? void 0 : _g.map((toolCall, index) => ({\n                index,\n                id: toolCall.id,\n                function: toolCall.function,\n                type: toolCall.type\n              })) : void 0\n            },\n            finish_reason: choice.finishReason,\n            index: choice.index\n          };\n        })\n      };\n    }\n    const text = extract(chunk);\n    if (text)\n      yield text;\n  }\n}\nfunction chunkToText() {\n  const trimStartOfStream = trimStartOfStreamHelper();\n  let isFunctionStreamingIn;\n  return (json) => {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;\n    if (isChatCompletionChunk(json)) {\n      const delta = (_a = json.choices[0]) == null ? void 0 : _a.delta;\n      if ((_b = delta.function_call) == null ? void 0 : _b.name) {\n        isFunctionStreamingIn = true;\n        return {\n          isText: false,\n          content: `{\"function_call\": {\"name\": \"${delta.function_call.name}\", \"arguments\": \"`\n        };\n      } else if ((_e = (_d = (_c = delta.tool_calls) == null ? void 0 : _c[0]) == null ? void 0 : _d.function) == null ? void 0 : _e.name) {\n        isFunctionStreamingIn = true;\n        const toolCall = delta.tool_calls[0];\n        if (toolCall.index === 0) {\n          return {\n            isText: false,\n            content: `{\"tool_calls\":[ {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_f = toolCall.function) == null ? void 0 : _f.name}\", \"arguments\": \"`\n          };\n        } else {\n          return {\n            isText: false,\n            content: `\"}}, {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_g = toolCall.function) == null ? void 0 : _g.name}\", \"arguments\": \"`\n          };\n        }\n      } else if ((_h = delta.function_call) == null ? void 0 : _h.arguments) {\n        return {\n          isText: false,\n          content: cleanupArguments((_i = delta.function_call) == null ? void 0 : _i.arguments)\n        };\n      } else if ((_l = (_k = (_j = delta.tool_calls) == null ? void 0 : _j[0]) == null ? void 0 : _k.function) == null ? void 0 : _l.arguments) {\n        return {\n          isText: false,\n          content: cleanupArguments((_o = (_n = (_m = delta.tool_calls) == null ? void 0 : _m[0]) == null ? void 0 : _n.function) == null ? void 0 : _o.arguments)\n        };\n      } else if (isFunctionStreamingIn && (((_p = json.choices[0]) == null ? void 0 : _p.finish_reason) === \"function_call\" || ((_q = json.choices[0]) == null ? void 0 : _q.finish_reason) === \"stop\")) {\n        isFunctionStreamingIn = false;\n        return {\n          isText: false,\n          content: '\"}}'\n        };\n      } else if (isFunctionStreamingIn && ((_r = json.choices[0]) == null ? void 0 : _r.finish_reason) === \"tool_calls\") {\n        isFunctionStreamingIn = false;\n        return {\n          isText: false,\n          content: '\"}}]}'\n        };\n      }\n    }\n    const text = trimStartOfStream(\n      isChatCompletionChunk(json) && json.choices[0].delta.content ? json.choices[0].delta.content : isCompletion(json) ? json.choices[0].text : \"\"\n    );\n    return text;\n  };\n  function cleanupArguments(argumentChunk) {\n    let escapedPartialJson = argumentChunk.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\//g, \"\\\\/\").replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/\\t/g, \"\\\\t\").replace(/\\f/g, \"\\\\f\");\n    return `${escapedPartialJson}`;\n  }\n}\nvar __internal__OpenAIFnMessagesSymbol = Symbol(\n  \"internal_openai_fn_messages\"\n);\nfunction isChatCompletionChunk(data) {\n  return \"choices\" in data && data.choices && data.choices[0] && \"delta\" in data.choices[0];\n}\nfunction isCompletion(data) {\n  return \"choices\" in data && data.choices && data.choices[0] && \"text\" in data.choices[0];\n}\nfunction OpenAIStream(res, callbacks) {\n  const cb = callbacks;\n  let stream;\n  if (Symbol.asyncIterator in res) {\n    stream = readableFromAsyncIterable(streamable5(res)).pipeThrough(\n      createCallbacksTransformer(\n        (cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n          ...cb,\n          onFinal: void 0\n        } : {\n          ...cb\n        }\n      )\n    );\n  } else {\n    stream = AIStream(\n      res,\n      parseOpenAIStream(),\n      (cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n        ...cb,\n        onFinal: void 0\n      } : {\n        ...cb\n      }\n    );\n  }\n  if (cb && (cb.experimental_onFunctionCall || cb.experimental_onToolCall)) {\n    const functionCallTransformer = createFunctionCallTransformer(cb);\n    return stream.pipeThrough(functionCallTransformer);\n  } else {\n    return stream.pipeThrough(createStreamDataTransformer());\n  }\n}\nfunction createFunctionCallTransformer(callbacks) {\n  const textEncoder = new TextEncoder();\n  let isFirstChunk = true;\n  let aggregatedResponse = \"\";\n  let aggregatedFinalCompletionResponse = \"\";\n  let isFunctionStreamingIn = false;\n  let functionCallMessages = callbacks[__internal__OpenAIFnMessagesSymbol] || [];\n  const decode = createChunkDecoder();\n  return new TransformStream({\n    async transform(chunk, controller) {\n      const message = decode(chunk);\n      aggregatedFinalCompletionResponse += message;\n      const shouldHandleAsFunction = isFirstChunk && (message.startsWith('{\"function_call\":') || message.startsWith('{\"tool_calls\":'));\n      if (shouldHandleAsFunction) {\n        isFunctionStreamingIn = true;\n        aggregatedResponse += message;\n        isFirstChunk = false;\n        return;\n      }\n      if (!isFunctionStreamingIn) {\n        controller.enqueue(\n          textEncoder.encode(formatStreamPart(\"text\", message))\n        );\n        return;\n      } else {\n        aggregatedResponse += message;\n      }\n    },\n    async flush(controller) {\n      try {\n        if (!isFirstChunk && isFunctionStreamingIn && (callbacks.experimental_onFunctionCall || callbacks.experimental_onToolCall)) {\n          isFunctionStreamingIn = false;\n          const payload = JSON.parse(aggregatedResponse);\n          let newFunctionCallMessages = [\n            ...functionCallMessages\n          ];\n          let functionResponse = void 0;\n          if (callbacks.experimental_onFunctionCall) {\n            if (payload.function_call === void 0) {\n              console.warn(\n                \"experimental_onFunctionCall should not be defined when using tools\"\n              );\n            }\n            const argumentsPayload = JSON.parse(\n              payload.function_call.arguments\n            );\n            functionResponse = await callbacks.experimental_onFunctionCall(\n              {\n                name: payload.function_call.name,\n                arguments: argumentsPayload\n              },\n              (result) => {\n                newFunctionCallMessages = [\n                  ...functionCallMessages,\n                  {\n                    role: \"assistant\",\n                    content: \"\",\n                    function_call: payload.function_call\n                  },\n                  {\n                    role: \"function\",\n                    name: payload.function_call.name,\n                    content: JSON.stringify(result)\n                  }\n                ];\n                return newFunctionCallMessages;\n              }\n            );\n          }\n          if (callbacks.experimental_onToolCall) {\n            const toolCalls = {\n              tools: []\n            };\n            for (const tool2 of payload.tool_calls) {\n              toolCalls.tools.push({\n                id: tool2.id,\n                type: \"function\",\n                func: {\n                  name: tool2.function.name,\n                  arguments: JSON.parse(tool2.function.arguments)\n                }\n              });\n            }\n            let responseIndex = 0;\n            try {\n              functionResponse = await callbacks.experimental_onToolCall(\n                toolCalls,\n                (result) => {\n                  if (result) {\n                    const { tool_call_id, function_name, tool_call_result } = result;\n                    newFunctionCallMessages = [\n                      ...newFunctionCallMessages,\n                      // Only append the assistant message if it's the first response\n                      ...responseIndex === 0 ? [\n                        {\n                          role: \"assistant\",\n                          content: \"\",\n                          tool_calls: payload.tool_calls.map(\n                            (tc) => ({\n                              id: tc.id,\n                              type: \"function\",\n                              function: {\n                                name: tc.function.name,\n                                // we send the arguments an object to the user, but as the API expects a string, we need to stringify it\n                                arguments: JSON.stringify(\n                                  tc.function.arguments\n                                )\n                              }\n                            })\n                          )\n                        }\n                      ] : [],\n                      // Append the function call result message\n                      {\n                        role: \"tool\",\n                        tool_call_id,\n                        name: function_name,\n                        content: JSON.stringify(tool_call_result)\n                      }\n                    ];\n                    responseIndex++;\n                  }\n                  return newFunctionCallMessages;\n                }\n              );\n            } catch (e) {\n              console.error(\"Error calling experimental_onToolCall:\", e);\n            }\n          }\n          if (!functionResponse) {\n            controller.enqueue(\n              textEncoder.encode(\n                formatStreamPart(\n                  payload.function_call ? \"function_call\" : \"tool_calls\",\n                  // parse to prevent double-encoding:\n                  JSON.parse(aggregatedResponse)\n                )\n              )\n            );\n            return;\n          } else if (typeof functionResponse === \"string\") {\n            controller.enqueue(\n              textEncoder.encode(formatStreamPart(\"text\", functionResponse))\n            );\n            aggregatedFinalCompletionResponse = functionResponse;\n            return;\n          }\n          const filteredCallbacks = {\n            ...callbacks,\n            onStart: void 0\n          };\n          callbacks.onFinal = void 0;\n          const openAIStream = OpenAIStream(functionResponse, {\n            ...filteredCallbacks,\n            [__internal__OpenAIFnMessagesSymbol]: newFunctionCallMessages\n          });\n          const reader = openAIStream.getReader();\n          while (true) {\n            const { done, value } = await reader.read();\n            if (done) {\n              break;\n            }\n            controller.enqueue(value);\n          }\n        }\n      } finally {\n        if (callbacks.onFinal && aggregatedFinalCompletionResponse) {\n          await callbacks.onFinal(aggregatedFinalCompletionResponse);\n        }\n      }\n    }\n  });\n}\n\n// streams/replicate-stream.ts\nasync function ReplicateStream(res, cb, options) {\n  var _a;\n  const url = (_a = res.urls) == null ? void 0 : _a.stream;\n  if (!url) {\n    if (res.error)\n      throw new Error(res.error);\n    else\n      throw new Error(\"Missing stream URL in Replicate response\");\n  }\n  const eventStream = await fetch(url, {\n    method: \"GET\",\n    headers: {\n      Accept: \"text/event-stream\",\n      ...options == null ? void 0 : options.headers\n    }\n  });\n  return AIStream(eventStream, void 0, cb).pipeThrough(\n    createStreamDataTransformer()\n  );\n}\n\n// shared/parse-complex-response.ts\nfunction assignAnnotationsToMessage(message, annotations) {\n  if (!message || !annotations || !annotations.length)\n    return message;\n  return { ...message, annotations: [...annotations] };\n}\nasync function parseComplexResponse({\n  reader,\n  abortControllerRef,\n  update,\n  onFinish,\n  generateId: generateId2 = generateId,\n  getCurrentDate = () => /* @__PURE__ */ new Date()\n}) {\n  const createdAt = getCurrentDate();\n  const prefixMap = {\n    data: []\n  };\n  let message_annotations = void 0;\n  for await (const { type, value } of readDataStream(reader, {\n    isAborted: () => (abortControllerRef == null ? void 0 : abortControllerRef.current) === null\n  })) {\n    if (type === \"text\") {\n      if (prefixMap[\"text\"]) {\n        prefixMap[\"text\"] = {\n          ...prefixMap[\"text\"],\n          content: (prefixMap[\"text\"].content || \"\") + value\n        };\n      } else {\n        prefixMap[\"text\"] = {\n          id: generateId2(),\n          role: \"assistant\",\n          content: value,\n          createdAt\n        };\n      }\n    }\n    if (type === \"tool_call\") {\n      if (prefixMap.text == null) {\n        prefixMap.text = {\n          id: generateId2(),\n          role: \"assistant\",\n          content: \"\",\n          createdAt\n        };\n      }\n      if (prefixMap.text.toolInvocations == null) {\n        prefixMap.text.toolInvocations = [];\n      }\n      prefixMap.text.toolInvocations.push(value);\n    } else if (type === \"tool_result\") {\n      if (prefixMap.text == null) {\n        prefixMap.text = {\n          id: generateId2(),\n          role: \"assistant\",\n          content: \"\",\n          createdAt\n        };\n      }\n      if (prefixMap.text.toolInvocations == null) {\n        prefixMap.text.toolInvocations = [];\n      }\n      const toolInvocationIndex = prefixMap.text.toolInvocations.findIndex(\n        (invocation) => invocation.toolCallId === value.toolCallId\n      );\n      if (toolInvocationIndex !== -1) {\n        prefixMap.text.toolInvocations[toolInvocationIndex] = value;\n      } else {\n        prefixMap.text.toolInvocations.push(value);\n      }\n    }\n    let functionCallMessage = null;\n    if (type === \"function_call\") {\n      prefixMap[\"function_call\"] = {\n        id: generateId2(),\n        role: \"assistant\",\n        content: \"\",\n        function_call: value.function_call,\n        name: value.function_call.name,\n        createdAt\n      };\n      functionCallMessage = prefixMap[\"function_call\"];\n    }\n    let toolCallMessage = null;\n    if (type === \"tool_calls\") {\n      prefixMap[\"tool_calls\"] = {\n        id: generateId2(),\n        role: \"assistant\",\n        content: \"\",\n        tool_calls: value.tool_calls,\n        createdAt\n      };\n      toolCallMessage = prefixMap[\"tool_calls\"];\n    }\n    if (type === \"data\") {\n      prefixMap[\"data\"].push(...value);\n    }\n    let responseMessage = prefixMap[\"text\"];\n    if (type === \"message_annotations\") {\n      if (!message_annotations) {\n        message_annotations = [...value];\n      } else {\n        message_annotations.push(...value);\n      }\n      functionCallMessage = assignAnnotationsToMessage(\n        prefixMap[\"function_call\"],\n        message_annotations\n      );\n      toolCallMessage = assignAnnotationsToMessage(\n        prefixMap[\"tool_calls\"],\n        message_annotations\n      );\n      responseMessage = assignAnnotationsToMessage(\n        prefixMap[\"text\"],\n        message_annotations\n      );\n    }\n    if (message_annotations == null ? void 0 : message_annotations.length) {\n      const messagePrefixKeys = [\n        \"text\",\n        \"function_call\",\n        \"tool_calls\"\n      ];\n      messagePrefixKeys.forEach((key) => {\n        if (prefixMap[key]) {\n          prefixMap[key].annotations = [...message_annotations];\n        }\n      });\n    }\n    const merged = [functionCallMessage, toolCallMessage, responseMessage].filter(Boolean).map((message) => ({\n      ...assignAnnotationsToMessage(message, message_annotations)\n    }));\n    update(merged, [...prefixMap[\"data\"]]);\n  }\n  onFinish == null ? void 0 : onFinish(prefixMap);\n  return {\n    messages: [\n      prefixMap.text,\n      prefixMap.function_call,\n      prefixMap.tool_calls\n    ].filter(Boolean),\n    data: prefixMap.data\n  };\n}\n\n// streams/streaming-react-response.ts\nvar experimental_StreamingReactResponse = class {\n  constructor(res, options) {\n    var _a, _b;\n    let resolveFunc = () => {\n    };\n    let next = new Promise((resolve) => {\n      resolveFunc = resolve;\n    });\n    const processedStream = (options == null ? void 0 : options.data) != null ? res.pipeThrough((_a = options == null ? void 0 : options.data) == null ? void 0 : _a.stream) : res;\n    let lastPayload = void 0;\n    parseComplexResponse({\n      reader: processedStream.getReader(),\n      update: (merged, data) => {\n        var _a2, _b2, _c;\n        const content = (_b2 = (_a2 = merged[0]) == null ? void 0 : _a2.content) != null ? _b2 : \"\";\n        const ui = ((_c = options == null ? void 0 : options.ui) == null ? void 0 : _c.call(options, { content, data })) || content;\n        const payload = { ui, content };\n        const resolvePrevious = resolveFunc;\n        const nextRow = new Promise((resolve) => {\n          resolveFunc = resolve;\n        });\n        resolvePrevious({\n          next: nextRow,\n          ...payload\n        });\n        lastPayload = payload;\n      },\n      generateId: (_b = options == null ? void 0 : options.generateId) != null ? _b : generateId,\n      onFinish: () => {\n        if (lastPayload !== void 0) {\n          resolveFunc({\n            next: null,\n            ...lastPayload\n          });\n        }\n      }\n    });\n    return next;\n  }\n};\n\n// streams/streaming-text-response.ts\nvar StreamingTextResponse = class extends Response {\n  constructor(res, init, data) {\n    let processedStream = res;\n    if (data) {\n      processedStream = res.pipeThrough(data.stream);\n    }\n    super(processedStream, {\n      ...init,\n      status: 200,\n      headers: {\n        \"Content-Type\": \"text/plain; charset=utf-8\",\n        ...init == null ? void 0 : init.headers\n      }\n    });\n  }\n};\nfunction streamToResponse(res, response, init) {\n  response.writeHead((init == null ? void 0 : init.status) || 200, {\n    \"Content-Type\": \"text/plain; charset=utf-8\",\n    ...init == null ? void 0 : init.headers\n  });\n  const reader = res.getReader();\n  function read() {\n    reader.read().then(({ done, value }) => {\n      if (done) {\n        response.end();\n        return;\n      }\n      response.write(value);\n      read();\n    });\n  }\n  read();\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWkvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTs7QUFFQTtBQUM0RDtBQUNXOztBQUV2RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxJQUFJO0FBQ0osUUFBUSxvRUFBWTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVFQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3REFBVTtBQUMxQixpQ0FBaUMsV0FBVyx3QkFBd0IsYUFBYTtBQUNqRjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esa0NBQWtDLDBEQUFZO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUVBQWlFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0RBQVU7QUFDeEIsK0JBQStCLFdBQVcsc0NBQXNDLGFBQWE7QUFDN0Y7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBOEMsWUFBWTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDMEQ7QUFDSDs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSSw0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a0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlDQUFpQztBQUNoRDtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw0QkFBNEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkJBQTZCO0FBQzNDLHNDQUFzQyw0QkFBNEI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxpQkFBaUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQWtCMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxPQUFPO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxLQUFLO0FBQ3REO0FBQ0EsWUFBWSxnQkFBZ0IsR0FBRztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUk7QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsY0FBYztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsY0FBYztBQUNuRDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsY0FBYztBQUMxRDtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsMkJBQTJCOztBQUVoRztBQUc0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdFQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQSwwREFBMEQsVUFBVTtBQUNwRTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxjQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLCtCQUErQixLQUFzQztBQUNyRTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFNBQVMsQ0FBSTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVHQUF1RyxlQUFlO0FBQ3RILDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDBCQUEwQixhQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUF1RUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2FhLy4vbm9kZV9tb2R1bGVzL2FpL2Rpc3QvaW5kZXgubWpzP2JhMmQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcblxuLy8gY29yZS91dGlsL3JldHJ5LXdpdGgtZXhwb25lbnRpYWwtYmFja29mZi50c1xuaW1wb3J0IHsgQVBJQ2FsbEVycm9yLCBSZXRyeUVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7IGdldEVycm9yTWVzc2FnZSwgaXNBYm9ydEVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gY29yZS91dGlsL2RlbGF5LnRzXG5hc3luYyBmdW5jdGlvbiBkZWxheShkZWxheUluTXMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5SW5NcykpO1xufVxuXG4vLyBjb3JlL3V0aWwvcmV0cnktd2l0aC1leHBvbmVudGlhbC1iYWNrb2ZmLnRzXG52YXIgcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmID0gKHtcbiAgbWF4UmV0cmllcyA9IDIsXG4gIGluaXRpYWxEZWxheUluTXMgPSAyZTMsXG4gIGJhY2tvZmZGYWN0b3IgPSAyXG59ID0ge30pID0+IGFzeW5jIChmKSA9PiBfcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKGYsIHtcbiAgbWF4UmV0cmllcyxcbiAgZGVsYXlJbk1zOiBpbml0aWFsRGVsYXlJbk1zLFxuICBiYWNrb2ZmRmFjdG9yXG59KTtcbmFzeW5jIGZ1bmN0aW9uIF9yZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoZiwge1xuICBtYXhSZXRyaWVzLFxuICBkZWxheUluTXMsXG4gIGJhY2tvZmZGYWN0b3Jcbn0sIGVycm9ycyA9IFtdKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IGYoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoaXNBYm9ydEVycm9yKGVycm9yKSkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGlmIChtYXhSZXRyaWVzID09PSAwKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZ2V0RXJyb3JNZXNzYWdlKGVycm9yKTtcbiAgICBjb25zdCBuZXdFcnJvcnMgPSBbLi4uZXJyb3JzLCBlcnJvcl07XG4gICAgY29uc3QgdHJ5TnVtYmVyID0gbmV3RXJyb3JzLmxlbmd0aDtcbiAgICBpZiAodHJ5TnVtYmVyID4gbWF4UmV0cmllcykge1xuICAgICAgdGhyb3cgbmV3IFJldHJ5RXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBgRmFpbGVkIGFmdGVyICR7dHJ5TnVtYmVyfSBhdHRlbXB0cy4gTGFzdCBlcnJvcjogJHtlcnJvck1lc3NhZ2V9YCxcbiAgICAgICAgcmVhc29uOiBcIm1heFJldHJpZXNFeGNlZWRlZFwiLFxuICAgICAgICBlcnJvcnM6IG5ld0Vycm9yc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIEFQSUNhbGxFcnJvci5pc0FQSUNhbGxFcnJvcihlcnJvcikgJiYgZXJyb3IuaXNSZXRyeWFibGUgPT09IHRydWUgJiYgdHJ5TnVtYmVyIDw9IG1heFJldHJpZXMpIHtcbiAgICAgIGF3YWl0IGRlbGF5KGRlbGF5SW5Ncyk7XG4gICAgICByZXR1cm4gX3JldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZihcbiAgICAgICAgZixcbiAgICAgICAgeyBtYXhSZXRyaWVzLCBkZWxheUluTXM6IGJhY2tvZmZGYWN0b3IgKiBkZWxheUluTXMsIGJhY2tvZmZGYWN0b3IgfSxcbiAgICAgICAgbmV3RXJyb3JzXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAodHJ5TnVtYmVyID09PSAxKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFJldHJ5RXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYEZhaWxlZCBhZnRlciAke3RyeU51bWJlcn0gYXR0ZW1wdHMgd2l0aCBub24tcmV0cnlhYmxlIGVycm9yOiAnJHtlcnJvck1lc3NhZ2V9J2AsXG4gICAgICByZWFzb246IFwiZXJyb3JOb3RSZXRyeWFibGVcIixcbiAgICAgIGVycm9yczogbmV3RXJyb3JzXG4gICAgfSk7XG4gIH1cbn1cblxuLy8gY29yZS9lbWJlZC9lbWJlZC50c1xuYXN5bmMgZnVuY3Rpb24gZW1iZWQoe1xuICBtb2RlbCxcbiAgdmFsdWUsXG4gIG1heFJldHJpZXMsXG4gIGFib3J0U2lnbmFsXG59KSB7XG4gIGNvbnN0IHJldHJ5ID0gcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKHsgbWF4UmV0cmllcyB9KTtcbiAgY29uc3QgbW9kZWxSZXNwb25zZSA9IGF3YWl0IHJldHJ5KFxuICAgICgpID0+IG1vZGVsLmRvRW1iZWQoe1xuICAgICAgdmFsdWVzOiBbdmFsdWVdLFxuICAgICAgYWJvcnRTaWduYWxcbiAgICB9KVxuICApO1xuICByZXR1cm4gbmV3IEVtYmVkUmVzdWx0KHtcbiAgICB2YWx1ZSxcbiAgICBlbWJlZGRpbmc6IG1vZGVsUmVzcG9uc2UuZW1iZWRkaW5nc1swXSxcbiAgICByYXdSZXNwb25zZTogbW9kZWxSZXNwb25zZS5yYXdSZXNwb25zZVxuICB9KTtcbn1cbnZhciBFbWJlZFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMudmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIHRoaXMuZW1iZWRkaW5nID0gb3B0aW9ucy5lbWJlZGRpbmc7XG4gICAgdGhpcy5yYXdSZXNwb25zZSA9IG9wdGlvbnMucmF3UmVzcG9uc2U7XG4gIH1cbn07XG5cbi8vIGNvcmUvZ2VuZXJhdGUtb2JqZWN0L2dlbmVyYXRlLW9iamVjdC50c1xuaW1wb3J0IHsgTm9PYmplY3RHZW5lcmF0ZWRFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5pbXBvcnQgeyBzYWZlUGFyc2VKU09OIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gY29yZS9nZW5lcmF0ZS10ZXh0L3Rva2VuLXVzYWdlLnRzXG5mdW5jdGlvbiBjYWxjdWxhdGVUb2tlblVzYWdlKHVzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgcHJvbXB0VG9rZW5zOiB1c2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgY29tcGxldGlvblRva2VuczogdXNhZ2UuY29tcGxldGlvblRva2VucyxcbiAgICB0b3RhbFRva2VuczogdXNhZ2UucHJvbXB0VG9rZW5zICsgdXNhZ2UuY29tcGxldGlvblRva2Vuc1xuICB9O1xufVxuXG4vLyBjb3JlL3V0aWwvZGV0ZWN0LWltYWdlLW1pbWV0eXBlLnRzXG52YXIgbWltZVR5cGVTaWduYXR1cmVzID0gW1xuICB7IG1pbWVUeXBlOiBcImltYWdlL2dpZlwiLCBieXRlczogWzcxLCA3MywgNzBdIH0sXG4gIHsgbWltZVR5cGU6IFwiaW1hZ2UvcG5nXCIsIGJ5dGVzOiBbMTM3LCA4MCwgNzgsIDcxXSB9LFxuICB7IG1pbWVUeXBlOiBcImltYWdlL2pwZWdcIiwgYnl0ZXM6IFsyNTUsIDIxNl0gfSxcbiAgeyBtaW1lVHlwZTogXCJpbWFnZS93ZWJwXCIsIGJ5dGVzOiBbODIsIDczLCA3MCwgNzBdIH1cbl07XG5mdW5jdGlvbiBkZXRlY3RJbWFnZU1pbWVUeXBlKGltYWdlKSB7XG4gIGZvciAoY29uc3QgeyBieXRlcywgbWltZVR5cGUgfSBvZiBtaW1lVHlwZVNpZ25hdHVyZXMpIHtcbiAgICBpZiAoaW1hZ2UubGVuZ3RoID49IGJ5dGVzLmxlbmd0aCAmJiBieXRlcy5ldmVyeSgoYnl0ZSwgaW5kZXgpID0+IGltYWdlW2luZGV4XSA9PT0gYnl0ZSkpIHtcbiAgICAgIHJldHVybiBtaW1lVHlwZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cblxuLy8gY29yZS9wcm9tcHQvZGF0YS1jb250ZW50LnRzXG5pbXBvcnQgeyBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5pbXBvcnQge1xuICBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5LFxuICBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0XG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5mdW5jdGlvbiBjb252ZXJ0RGF0YUNvbnRlbnRUb0Jhc2U2NFN0cmluZyhjb250ZW50KSB7XG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NChuZXcgVWludDhBcnJheShjb250ZW50KSk7XG4gIH1cbiAgcmV0dXJuIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQoY29udGVudCk7XG59XG5mdW5jdGlvbiBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkoY29udGVudCkge1xuICBpZiAoY29udGVudCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkoY29udGVudCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBkYXRhIGNvbnRlbnQuIENvbnRlbnQgc3RyaW5nIGlzIG5vdCBhIGJhc2U2NC1lbmNvZGVkIGltYWdlLlwiLFxuICAgICAgICBjb250ZW50LFxuICAgICAgICBjYXVzZTogZXJyb3JcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAoY29udGVudCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGNvbnRlbnQpO1xuICB9XG4gIHRocm93IG5ldyBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvcih7IGNvbnRlbnQgfSk7XG59XG5cbi8vIGNvcmUvcHJvbXB0L2NvbnZlcnQtdG8tbGFuZ3VhZ2UtbW9kZWwtcHJvbXB0LnRzXG5mdW5jdGlvbiBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHByb21wdCkge1xuICBjb25zdCBsYW5ndWFnZU1vZGVsTWVzc2FnZXMgPSBbXTtcbiAgaWYgKHByb21wdC5zeXN0ZW0gIT0gbnVsbCkge1xuICAgIGxhbmd1YWdlTW9kZWxNZXNzYWdlcy5wdXNoKHsgcm9sZTogXCJzeXN0ZW1cIiwgY29udGVudDogcHJvbXB0LnN5c3RlbSB9KTtcbiAgfVxuICBzd2l0Y2ggKHByb21wdC50eXBlKSB7XG4gICAgY2FzZSBcInByb21wdFwiOiB7XG4gICAgICBsYW5ndWFnZU1vZGVsTWVzc2FnZXMucHVzaCh7XG4gICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICBjb250ZW50OiBbeyB0eXBlOiBcInRleHRcIiwgdGV4dDogcHJvbXB0LnByb21wdCB9XVxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIm1lc3NhZ2VzXCI6IHtcbiAgICAgIGxhbmd1YWdlTW9kZWxNZXNzYWdlcy5wdXNoKFxuICAgICAgICAuLi5wcm9tcHQubWVzc2FnZXMubWFwKChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgc3dpdGNoIChtZXNzYWdlLnJvbGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJzeXN0ZW1cIjoge1xuICAgICAgICAgICAgICByZXR1cm4geyByb2xlOiBcInN5c3RlbVwiLCBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ1c2VyXCI6IHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgICAgICAgICAgICBjb250ZW50OiBbeyB0eXBlOiBcInRleHRcIiwgdGV4dDogbWVzc2FnZS5jb250ZW50IH1dXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudC5tYXAoXG4gICAgICAgICAgICAgICAgICAocGFydCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocGFydC50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRleHRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpbWFnZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFydC5pbWFnZSBpbnN0YW5jZW9mIFVSTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaW1hZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZTogcGFydC5pbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZTogcGFydC5taW1lVHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1hZ2VVaW50OCA9IGNvbnZlcnREYXRhQ29udGVudFRvVWludDhBcnJheShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydC5pbWFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaW1hZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IGltYWdlVWludDgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiAoX2EgPSBwYXJ0Lm1pbWVUeXBlKSAhPSBudWxsID8gX2EgOiBkZXRlY3RJbWFnZU1pbWVUeXBlKGltYWdlVWludDgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJhc3Npc3RhbnRcIjoge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgICAgICAgICAgY29udGVudDogW3sgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IG1lc3NhZ2UuY29udGVudCB9XVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHsgcm9sZTogXCJhc3Npc3RhbnRcIiwgY29udGVudDogbWVzc2FnZS5jb250ZW50IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbFwiOiB7XG4gICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IHByb21wdDtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgcHJvbXB0IHR5cGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxhbmd1YWdlTW9kZWxNZXNzYWdlcztcbn1cblxuLy8gY29yZS9wcm9tcHQvZ2V0LXZhbGlkYXRlZC1wcm9tcHQudHNcbmltcG9ydCB7IEludmFsaWRQcm9tcHRFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5mdW5jdGlvbiBnZXRWYWxpZGF0ZWRQcm9tcHQocHJvbXB0KSB7XG4gIGlmIChwcm9tcHQucHJvbXB0ID09IG51bGwgJiYgcHJvbXB0Lm1lc3NhZ2VzID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6IFwicHJvbXB0IG9yIG1lc3NhZ2VzIG11c3QgYmUgZGVmaW5lZFwiXG4gICAgfSk7XG4gIH1cbiAgaWYgKHByb21wdC5wcm9tcHQgIT0gbnVsbCAmJiBwcm9tcHQubWVzc2FnZXMgIT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3Ioe1xuICAgICAgcHJvbXB0LFxuICAgICAgbWVzc2FnZTogXCJwcm9tcHQgYW5kIG1lc3NhZ2VzIGNhbm5vdCBiZSBkZWZpbmVkIGF0IHRoZSBzYW1lIHRpbWVcIlxuICAgIH0pO1xuICB9XG4gIHJldHVybiBwcm9tcHQucHJvbXB0ICE9IG51bGwgPyB7XG4gICAgdHlwZTogXCJwcm9tcHRcIixcbiAgICBwcm9tcHQ6IHByb21wdC5wcm9tcHQsXG4gICAgbWVzc2FnZXM6IHZvaWQgMCxcbiAgICBzeXN0ZW06IHByb21wdC5zeXN0ZW1cbiAgfSA6IHtcbiAgICB0eXBlOiBcIm1lc3NhZ2VzXCIsXG4gICAgcHJvbXB0OiB2b2lkIDAsXG4gICAgbWVzc2FnZXM6IHByb21wdC5tZXNzYWdlcyxcbiAgICAvLyBvbmx5IHBvc3NpYmxlIGNhc2UgYmMgb2YgY2hlY2tzIGFib3ZlXG4gICAgc3lzdGVtOiBwcm9tcHQuc3lzdGVtXG4gIH07XG59XG5cbi8vIGNvcmUvcHJvbXB0L3ByZXBhcmUtY2FsbC1zZXR0aW5ncy50c1xuaW1wb3J0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuZnVuY3Rpb24gcHJlcGFyZUNhbGxTZXR0aW5ncyh7XG4gIG1heFRva2VucyxcbiAgdGVtcGVyYXR1cmUsXG4gIHRvcFAsXG4gIHByZXNlbmNlUGVuYWx0eSxcbiAgZnJlcXVlbmN5UGVuYWx0eSxcbiAgc2VlZCxcbiAgbWF4UmV0cmllc1xufSkge1xuICBpZiAobWF4VG9rZW5zICE9IG51bGwpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobWF4VG9rZW5zKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcIm1heFRva2Vuc1wiLFxuICAgICAgICB2YWx1ZTogbWF4VG9rZW5zLFxuICAgICAgICBtZXNzYWdlOiBcIm1heFRva2VucyBtdXN0IGJlIGFuIGludGVnZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChtYXhUb2tlbnMgPCAxKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwibWF4VG9rZW5zXCIsXG4gICAgICAgIHZhbHVlOiBtYXhUb2tlbnMsXG4gICAgICAgIG1lc3NhZ2U6IFwibWF4VG9rZW5zIG11c3QgYmUgPj0gMVwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHRlbXBlcmF0dXJlICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHRlbXBlcmF0dXJlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwidGVtcGVyYXR1cmVcIixcbiAgICAgICAgdmFsdWU6IHRlbXBlcmF0dXJlLFxuICAgICAgICBtZXNzYWdlOiBcInRlbXBlcmF0dXJlIG11c3QgYmUgYSBudW1iZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmICh0b3BQICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHRvcFAgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJ0b3BQXCIsXG4gICAgICAgIHZhbHVlOiB0b3BQLFxuICAgICAgICBtZXNzYWdlOiBcInRvcFAgbXVzdCBiZSBhIG51bWJlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHByZXNlbmNlUGVuYWx0eSAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBwcmVzZW5jZVBlbmFsdHkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJwcmVzZW5jZVBlbmFsdHlcIixcbiAgICAgICAgdmFsdWU6IHByZXNlbmNlUGVuYWx0eSxcbiAgICAgICAgbWVzc2FnZTogXCJwcmVzZW5jZVBlbmFsdHkgbXVzdCBiZSBhIG51bWJlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKGZyZXF1ZW5jeVBlbmFsdHkgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgZnJlcXVlbmN5UGVuYWx0eSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcImZyZXF1ZW5jeVBlbmFsdHlcIixcbiAgICAgICAgdmFsdWU6IGZyZXF1ZW5jeVBlbmFsdHksXG4gICAgICAgIG1lc3NhZ2U6IFwiZnJlcXVlbmN5UGVuYWx0eSBtdXN0IGJlIGEgbnVtYmVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAoc2VlZCAhPSBudWxsKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHNlZWQpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2VlZFwiLFxuICAgICAgICB2YWx1ZTogc2VlZCxcbiAgICAgICAgbWVzc2FnZTogXCJzZWVkIG11c3QgYmUgYW4gaW50ZWdlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKG1heFJldHJpZXMgIT0gbnVsbCkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihtYXhSZXRyaWVzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcIm1heFJldHJpZXNcIixcbiAgICAgICAgdmFsdWU6IG1heFJldHJpZXMsXG4gICAgICAgIG1lc3NhZ2U6IFwibWF4UmV0cmllcyBtdXN0IGJlIGFuIGludGVnZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChtYXhSZXRyaWVzIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcIm1heFJldHJpZXNcIixcbiAgICAgICAgdmFsdWU6IG1heFJldHJpZXMsXG4gICAgICAgIG1lc3NhZ2U6IFwibWF4UmV0cmllcyBtdXN0IGJlID49IDBcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgbWF4VG9rZW5zLFxuICAgIHRlbXBlcmF0dXJlOiB0ZW1wZXJhdHVyZSAhPSBudWxsID8gdGVtcGVyYXR1cmUgOiAwLFxuICAgIHRvcFAsXG4gICAgcHJlc2VuY2VQZW5hbHR5LFxuICAgIGZyZXF1ZW5jeVBlbmFsdHksXG4gICAgc2VlZCxcbiAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzICE9IG51bGwgPyBtYXhSZXRyaWVzIDogMlxuICB9O1xufVxuXG4vLyBjb3JlL3V0aWwvY29udmVydC16b2QtdG8tanNvbi1zY2hlbWEudHNcbmltcG9ydCB6b2RUb0pzb25TY2hlbWEgZnJvbSBcInpvZC10by1qc29uLXNjaGVtYVwiO1xuZnVuY3Rpb24gY29udmVydFpvZFRvSlNPTlNjaGVtYSh6b2RTY2hlbWEpIHtcbiAgcmV0dXJuIHpvZFRvSnNvblNjaGVtYSh6b2RTY2hlbWEpO1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLW9iamVjdC9pbmplY3QtanNvbi1zY2hlbWEtaW50by1zeXN0ZW0udHNcbnZhciBERUZBVUxUX1NDSEVNQV9QUkVGSVggPSBcIkpTT04gc2NoZW1hOlwiO1xudmFyIERFRkFVTFRfU0NIRU1BX1NVRkZJWCA9IFwiWW91IE1VU1QgYW5zd2VyIHdpdGggYSBKU09OIG9iamVjdCB0aGF0IG1hdGNoZXMgdGhlIEpTT04gc2NoZW1hIGFib3ZlLlwiO1xuZnVuY3Rpb24gaW5qZWN0SnNvblNjaGVtYUludG9TeXN0ZW0oe1xuICBzeXN0ZW0sXG4gIHNjaGVtYSxcbiAgc2NoZW1hUHJlZml4ID0gREVGQVVMVF9TQ0hFTUFfUFJFRklYLFxuICBzY2hlbWFTdWZmaXggPSBERUZBVUxUX1NDSEVNQV9TVUZGSVhcbn0pIHtcbiAgcmV0dXJuIFtcbiAgICBzeXN0ZW0sXG4gICAgc3lzdGVtICE9IG51bGwgPyBcIlwiIDogbnVsbCxcbiAgICAvLyBhZGQgYSBuZXdsaW5lIGlmIHN5c3RlbSBpcyBub3QgbnVsbFxuICAgIHNjaGVtYVByZWZpeCxcbiAgICBKU09OLnN0cmluZ2lmeShzY2hlbWEpLFxuICAgIHNjaGVtYVN1ZmZpeFxuICBdLmZpbHRlcigobGluZSkgPT4gbGluZSAhPSBudWxsKS5qb2luKFwiXFxuXCIpO1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLW9iamVjdC9nZW5lcmF0ZS1vYmplY3QudHNcbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlT2JqZWN0KHtcbiAgbW9kZWwsXG4gIHNjaGVtYSxcbiAgbW9kZSxcbiAgc3lzdGVtLFxuICBwcm9tcHQsXG4gIG1lc3NhZ2VzLFxuICBtYXhSZXRyaWVzLFxuICBhYm9ydFNpZ25hbCxcbiAgLi4uc2V0dGluZ3Ncbn0pIHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgcmV0cnkgPSByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoeyBtYXhSZXRyaWVzIH0pO1xuICBjb25zdCBqc29uU2NoZW1hID0gY29udmVydFpvZFRvSlNPTlNjaGVtYShzY2hlbWEpO1xuICBpZiAobW9kZSA9PT0gXCJhdXRvXCIgfHwgbW9kZSA9PSBudWxsKSB7XG4gICAgbW9kZSA9IG1vZGVsLmRlZmF1bHRPYmplY3RHZW5lcmF0aW9uTW9kZTtcbiAgfVxuICBsZXQgcmVzdWx0O1xuICBsZXQgZmluaXNoUmVhc29uO1xuICBsZXQgdXNhZ2U7XG4gIGxldCB3YXJuaW5ncztcbiAgbGV0IHJhd1Jlc3BvbnNlO1xuICBsZXQgbG9ncHJvYnM7XG4gIHN3aXRjaCAobW9kZSkge1xuICAgIGNhc2UgXCJqc29uXCI6IHtcbiAgICAgIGNvbnN0IHZhbGlkYXRlZFByb21wdCA9IGdldFZhbGlkYXRlZFByb21wdCh7XG4gICAgICAgIHN5c3RlbTogaW5qZWN0SnNvblNjaGVtYUludG9TeXN0ZW0oeyBzeXN0ZW0sIHNjaGVtYToganNvblNjaGVtYSB9KSxcbiAgICAgICAgcHJvbXB0LFxuICAgICAgICBtZXNzYWdlc1xuICAgICAgfSk7XG4gICAgICBjb25zdCBnZW5lcmF0ZVJlc3VsdCA9IGF3YWl0IHJldHJ5KCgpID0+IHtcbiAgICAgICAgcmV0dXJuIG1vZGVsLmRvR2VuZXJhdGUoe1xuICAgICAgICAgIG1vZGU6IHsgdHlwZTogXCJvYmplY3QtanNvblwiIH0sXG4gICAgICAgICAgLi4ucHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyksXG4gICAgICAgICAgaW5wdXRGb3JtYXQ6IHZhbGlkYXRlZFByb21wdC50eXBlLFxuICAgICAgICAgIHByb21wdDogY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh2YWxpZGF0ZWRQcm9tcHQpLFxuICAgICAgICAgIGFib3J0U2lnbmFsXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBpZiAoZ2VuZXJhdGVSZXN1bHQudGV4dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKCk7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBnZW5lcmF0ZVJlc3VsdC50ZXh0O1xuICAgICAgZmluaXNoUmVhc29uID0gZ2VuZXJhdGVSZXN1bHQuZmluaXNoUmVhc29uO1xuICAgICAgdXNhZ2UgPSBnZW5lcmF0ZVJlc3VsdC51c2FnZTtcbiAgICAgIHdhcm5pbmdzID0gZ2VuZXJhdGVSZXN1bHQud2FybmluZ3M7XG4gICAgICByYXdSZXNwb25zZSA9IGdlbmVyYXRlUmVzdWx0LnJhd1Jlc3BvbnNlO1xuICAgICAgbG9ncHJvYnMgPSBnZW5lcmF0ZVJlc3VsdC5sb2dwcm9icztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiZ3JhbW1hclwiOiB7XG4gICAgICBjb25zdCB2YWxpZGF0ZWRQcm9tcHQgPSBnZXRWYWxpZGF0ZWRQcm9tcHQoe1xuICAgICAgICBzeXN0ZW06IGluamVjdEpzb25TY2hlbWFJbnRvU3lzdGVtKHsgc3lzdGVtLCBzY2hlbWE6IGpzb25TY2hlbWEgfSksXG4gICAgICAgIHByb21wdCxcbiAgICAgICAgbWVzc2FnZXNcbiAgICAgIH0pO1xuICAgICAgY29uc3QgZ2VuZXJhdGVSZXN1bHQgPSBhd2FpdCByZXRyeShcbiAgICAgICAgKCkgPT4gbW9kZWwuZG9HZW5lcmF0ZSh7XG4gICAgICAgICAgbW9kZTogeyB0eXBlOiBcIm9iamVjdC1ncmFtbWFyXCIsIHNjaGVtYToganNvblNjaGVtYSB9LFxuICAgICAgICAgIC4uLnNldHRpbmdzLFxuICAgICAgICAgIGlucHV0Rm9ybWF0OiB2YWxpZGF0ZWRQcm9tcHQudHlwZSxcbiAgICAgICAgICBwcm9tcHQ6IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQodmFsaWRhdGVkUHJvbXB0KSxcbiAgICAgICAgICBhYm9ydFNpZ25hbFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIGlmIChnZW5lcmF0ZVJlc3VsdC50ZXh0ID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IE5vT2JqZWN0R2VuZXJhdGVkRXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGdlbmVyYXRlUmVzdWx0LnRleHQ7XG4gICAgICBmaW5pc2hSZWFzb24gPSBnZW5lcmF0ZVJlc3VsdC5maW5pc2hSZWFzb247XG4gICAgICB1c2FnZSA9IGdlbmVyYXRlUmVzdWx0LnVzYWdlO1xuICAgICAgd2FybmluZ3MgPSBnZW5lcmF0ZVJlc3VsdC53YXJuaW5ncztcbiAgICAgIHJhd1Jlc3BvbnNlID0gZ2VuZXJhdGVSZXN1bHQucmF3UmVzcG9uc2U7XG4gICAgICBsb2dwcm9icyA9IGdlbmVyYXRlUmVzdWx0LmxvZ3Byb2JzO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJ0b29sXCI6IHtcbiAgICAgIGNvbnN0IHZhbGlkYXRlZFByb21wdCA9IGdldFZhbGlkYXRlZFByb21wdCh7XG4gICAgICAgIHN5c3RlbSxcbiAgICAgICAgcHJvbXB0LFxuICAgICAgICBtZXNzYWdlc1xuICAgICAgfSk7XG4gICAgICBjb25zdCBnZW5lcmF0ZVJlc3VsdCA9IGF3YWl0IHJldHJ5KFxuICAgICAgICAoKSA9PiBtb2RlbC5kb0dlbmVyYXRlKHtcbiAgICAgICAgICBtb2RlOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm9iamVjdC10b29sXCIsXG4gICAgICAgICAgICB0b29sOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgbmFtZTogXCJqc29uXCIsXG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlJlc3BvbmQgd2l0aCBhIEpTT04gb2JqZWN0LlwiLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBqc29uU2NoZW1hXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICAuLi5zZXR0aW5ncyxcbiAgICAgICAgICBpbnB1dEZvcm1hdDogdmFsaWRhdGVkUHJvbXB0LnR5cGUsXG4gICAgICAgICAgcHJvbXB0OiBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHZhbGlkYXRlZFByb21wdCksXG4gICAgICAgICAgYWJvcnRTaWduYWxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBjb25zdCBmdW5jdGlvbkFyZ3MgPSAoX2IgPSAoX2EgPSBnZW5lcmF0ZVJlc3VsdC50b29sQ2FsbHMpID09IG51bGwgPyB2b2lkIDAgOiBfYVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmFyZ3M7XG4gICAgICBpZiAoZnVuY3Rpb25BcmdzID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IE5vT2JqZWN0R2VuZXJhdGVkRXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGZ1bmN0aW9uQXJncztcbiAgICAgIGZpbmlzaFJlYXNvbiA9IGdlbmVyYXRlUmVzdWx0LmZpbmlzaFJlYXNvbjtcbiAgICAgIHVzYWdlID0gZ2VuZXJhdGVSZXN1bHQudXNhZ2U7XG4gICAgICB3YXJuaW5ncyA9IGdlbmVyYXRlUmVzdWx0Lndhcm5pbmdzO1xuICAgICAgcmF3UmVzcG9uc2UgPSBnZW5lcmF0ZVJlc3VsdC5yYXdSZXNwb25zZTtcbiAgICAgIGxvZ3Byb2JzID0gZ2VuZXJhdGVSZXN1bHQubG9ncHJvYnM7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSB2b2lkIDA6IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1vZGVsIGRvZXMgbm90IGhhdmUgYSBkZWZhdWx0IG9iamVjdCBnZW5lcmF0aW9uIG1vZGUuXCIpO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gbW9kZTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbW9kZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgIH1cbiAgfVxuICBjb25zdCBwYXJzZVJlc3VsdCA9IHNhZmVQYXJzZUpTT04oeyB0ZXh0OiByZXN1bHQsIHNjaGVtYSB9KTtcbiAgaWYgKCFwYXJzZVJlc3VsdC5zdWNjZXNzKSB7XG4gICAgdGhyb3cgcGFyc2VSZXN1bHQuZXJyb3I7XG4gIH1cbiAgcmV0dXJuIG5ldyBHZW5lcmF0ZU9iamVjdFJlc3VsdCh7XG4gICAgb2JqZWN0OiBwYXJzZVJlc3VsdC52YWx1ZSxcbiAgICBmaW5pc2hSZWFzb24sXG4gICAgdXNhZ2U6IGNhbGN1bGF0ZVRva2VuVXNhZ2UodXNhZ2UpLFxuICAgIHdhcm5pbmdzLFxuICAgIHJhd1Jlc3BvbnNlLFxuICAgIGxvZ3Byb2JzXG4gIH0pO1xufVxudmFyIEdlbmVyYXRlT2JqZWN0UmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5vYmplY3QgPSBvcHRpb25zLm9iamVjdDtcbiAgICB0aGlzLmZpbmlzaFJlYXNvbiA9IG9wdGlvbnMuZmluaXNoUmVhc29uO1xuICAgIHRoaXMudXNhZ2UgPSBvcHRpb25zLnVzYWdlO1xuICAgIHRoaXMud2FybmluZ3MgPSBvcHRpb25zLndhcm5pbmdzO1xuICAgIHRoaXMucmF3UmVzcG9uc2UgPSBvcHRpb25zLnJhd1Jlc3BvbnNlO1xuICAgIHRoaXMubG9ncHJvYnMgPSBvcHRpb25zLmxvZ3Byb2JzO1xuICB9XG59O1xudmFyIGV4cGVyaW1lbnRhbF9nZW5lcmF0ZU9iamVjdCA9IGdlbmVyYXRlT2JqZWN0O1xuXG4vLyBjb3JlL3V0aWwvYXN5bmMtaXRlcmFibGUtc3RyZWFtLnRzXG5mdW5jdGlvbiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKHNvdXJjZSwgdHJhbnNmb3JtZXIpIHtcbiAgY29uc3QgdHJhbnNmb3JtZWRTdHJlYW0gPSBzb3VyY2UucGlwZVRocm91Z2goXG4gICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh0cmFuc2Zvcm1lcilcbiAgKTtcbiAgdHJhbnNmb3JtZWRTdHJlYW1bU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gKCkgPT4ge1xuICAgIGNvbnN0IHJlYWRlciA9IHRyYW5zZm9ybWVkU3RyZWFtLmdldFJlYWRlcigpO1xuICAgIHJldHVybiB7XG4gICAgICBhc3luYyBuZXh0KCkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICByZXR1cm4gZG9uZSA/IHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHZvaWQgMCB9IDogeyBkb25lOiBmYWxzZSwgdmFsdWUgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICByZXR1cm4gdHJhbnNmb3JtZWRTdHJlYW07XG59XG5cbi8vIGNvcmUvdXRpbC9pcy1kZWVwLWVxdWFsLWRhdGEudHNcbmZ1bmN0aW9uIGlzRGVlcEVxdWFsRGF0YShvYmoxLCBvYmoyKSB7XG4gIGlmIChvYmoxID09PSBvYmoyKVxuICAgIHJldHVybiB0cnVlO1xuICBpZiAob2JqMSA9PSBudWxsIHx8IG9iajIgPT0gbnVsbClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2Ygb2JqMSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqMiAhPT0gXCJvYmplY3RcIilcbiAgICByZXR1cm4gb2JqMSA9PT0gb2JqMjtcbiAgaWYgKG9iajEuY29uc3RydWN0b3IgIT09IG9iajIuY29uc3RydWN0b3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAob2JqMSBpbnN0YW5jZW9mIERhdGUgJiYgb2JqMiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gb2JqMS5nZXRUaW1lKCkgPT09IG9iajIuZ2V0VGltZSgpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KG9iajEpKSB7XG4gICAgaWYgKG9iajEubGVuZ3RoICE9PSBvYmoyLmxlbmd0aClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iajEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghaXNEZWVwRXF1YWxEYXRhKG9iajFbaV0sIG9iajJbaV0pKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGtleXMxID0gT2JqZWN0LmtleXMob2JqMSk7XG4gIGNvbnN0IGtleXMyID0gT2JqZWN0LmtleXMob2JqMik7XG4gIGlmIChrZXlzMS5sZW5ndGggIT09IGtleXMyLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMxKSB7XG4gICAgaWYgKCFrZXlzMi5pbmNsdWRlcyhrZXkpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghaXNEZWVwRXF1YWxEYXRhKG9iajFba2V5XSwgb2JqMltrZXldKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gY29yZS91dGlsL3BhcnNlLXBhcnRpYWwtanNvbi50c1xuaW1wb3J0IFNlY3VyZUpTT04gZnJvbSBcInNlY3VyZS1qc29uLXBhcnNlXCI7XG5cbi8vIGNvcmUvdXRpbC9maXgtanNvbi50c1xuZnVuY3Rpb24gZml4SnNvbihpbnB1dCkge1xuICBjb25zdCBzdGFjayA9IFtcIlJPT1RcIl07XG4gIGxldCBsYXN0VmFsaWRJbmRleCA9IC0xO1xuICBsZXQgbGl0ZXJhbFN0YXJ0ID0gbnVsbDtcbiAgZnVuY3Rpb24gcHJvY2Vzc1ZhbHVlU3RhcnQoY2hhciwgaSwgc3dhcFN0YXRlKSB7XG4gICAge1xuICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgIGNhc2UgJ1wiJzoge1xuICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICBzdGFjay5wdXNoKHN3YXBTdGF0ZSk7XG4gICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9TVFJJTkdcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImZcIjpcbiAgICAgICAgY2FzZSBcInRcIjpcbiAgICAgICAgY2FzZSBcIm5cIjoge1xuICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICBsaXRlcmFsU3RhcnQgPSBpO1xuICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgIHN0YWNrLnB1c2goc3dhcFN0YXRlKTtcbiAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX0xJVEVSQUxcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIi1cIjoge1xuICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgIHN0YWNrLnB1c2goc3dhcFN0YXRlKTtcbiAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX05VTUJFUlwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiMFwiOlxuICAgICAgICBjYXNlIFwiMVwiOlxuICAgICAgICBjYXNlIFwiMlwiOlxuICAgICAgICBjYXNlIFwiM1wiOlxuICAgICAgICBjYXNlIFwiNFwiOlxuICAgICAgICBjYXNlIFwiNVwiOlxuICAgICAgICBjYXNlIFwiNlwiOlxuICAgICAgICBjYXNlIFwiN1wiOlxuICAgICAgICBjYXNlIFwiOFwiOlxuICAgICAgICBjYXNlIFwiOVwiOiB7XG4gICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgIHN0YWNrLnB1c2goc3dhcFN0YXRlKTtcbiAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX05VTUJFUlwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwie1wiOiB7XG4gICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgIHN0YWNrLnB1c2goc3dhcFN0YXRlKTtcbiAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX09CSkVDVF9TVEFSVFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiW1wiOiB7XG4gICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgIHN0YWNrLnB1c2goc3dhcFN0YXRlKTtcbiAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX0FSUkFZX1NUQVJUXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHByb2Nlc3NBZnRlck9iamVjdFZhbHVlKGNoYXIsIGkpIHtcbiAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgIGNhc2UgXCIsXCI6IHtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfT0JKRUNUX0FGVEVSX0NPTU1BXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJ9XCI6IHtcbiAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHByb2Nlc3NBZnRlckFycmF5VmFsdWUoY2hhciwgaSkge1xuICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgY2FzZSBcIixcIjoge1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9BUlJBWV9BRlRFUl9DT01NQVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiXVwiOiB7XG4gICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hhciA9IGlucHV0W2ldO1xuICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgIHN3aXRjaCAoY3VycmVudFN0YXRlKSB7XG4gICAgICBjYXNlIFwiUk9PVFwiOlxuICAgICAgICBwcm9jZXNzVmFsdWVTdGFydChjaGFyLCBpLCBcIkZJTklTSFwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9TVEFSVFwiOiB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgIGNhc2UgJ1wiJzoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX09CSkVDVF9LRVlcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIn1cIjoge1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9BRlRFUl9DT01NQVwiOiB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgIGNhc2UgJ1wiJzoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX09CSkVDVF9LRVlcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9LRVlcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlICdcIic6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9PQkpFQ1RfQUZURVJfS0VZXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfQUZURVJfS0VZXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSBcIjpcIjoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX09CSkVDVF9CRUZPUkVfVkFMVUVcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9CRUZPUkVfVkFMVUVcIjoge1xuICAgICAgICBwcm9jZXNzVmFsdWVTdGFydChjaGFyLCBpLCBcIklOU0lERV9PQkpFQ1RfQUZURVJfVkFMVUVcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfQUZURVJfVkFMVUVcIjoge1xuICAgICAgICBwcm9jZXNzQWZ0ZXJPYmplY3RWYWx1ZShjaGFyLCBpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX1NUUklOR1wiOiB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgIGNhc2UgJ1wiJzoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIlxcXFxcIjoge1xuICAgICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9TVFJJTkdfRVNDQVBFXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX0FSUkFZX1NUQVJUXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSBcIl1cIjoge1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgICAgcHJvY2Vzc1ZhbHVlU3RhcnQoY2hhciwgaSwgXCJJTlNJREVfQVJSQVlfQUZURVJfVkFMVUVcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX0FSUkFZX0FGVEVSX1ZBTFVFXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSBcIixcIjoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX0FSUkFZX0FGVEVSX0NPTU1BXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJdXCI6IHtcbiAgICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfQVJSQVlfQUZURVJfQ09NTUFcIjoge1xuICAgICAgICBwcm9jZXNzVmFsdWVTdGFydChjaGFyLCBpLCBcIklOU0lERV9BUlJBWV9BRlRFUl9WQUxVRVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX1NUUklOR19FU0NBUEVcIjoge1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfTlVNQkVSXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSBcIjBcIjpcbiAgICAgICAgICBjYXNlIFwiMVwiOlxuICAgICAgICAgIGNhc2UgXCIyXCI6XG4gICAgICAgICAgY2FzZSBcIjNcIjpcbiAgICAgICAgICBjYXNlIFwiNFwiOlxuICAgICAgICAgIGNhc2UgXCI1XCI6XG4gICAgICAgICAgY2FzZSBcIjZcIjpcbiAgICAgICAgICBjYXNlIFwiN1wiOlxuICAgICAgICAgIGNhc2UgXCI4XCI6XG4gICAgICAgICAgY2FzZSBcIjlcIjoge1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJlXCI6XG4gICAgICAgICAgY2FzZSBcIkVcIjpcbiAgICAgICAgICBjYXNlIFwiLVwiOlxuICAgICAgICAgIGNhc2UgXCIuXCI6IHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiLFwiOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGlmIChzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gXCJJTlNJREVfQVJSQVlfQUZURVJfVkFMVUVcIikge1xuICAgICAgICAgICAgICBwcm9jZXNzQWZ0ZXJBcnJheVZhbHVlKGNoYXIsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBcIklOU0lERV9PQkpFQ1RfQUZURVJfVkFMVUVcIikge1xuICAgICAgICAgICAgICBwcm9jZXNzQWZ0ZXJPYmplY3RWYWx1ZShjaGFyLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwifVwiOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGlmIChzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gXCJJTlNJREVfT0JKRUNUX0FGVEVSX1ZBTFVFXCIpIHtcbiAgICAgICAgICAgICAgcHJvY2Vzc0FmdGVyT2JqZWN0VmFsdWUoY2hhciwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIl1cIjoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IFwiSU5TSURFX0FSUkFZX0FGVEVSX1ZBTFVFXCIpIHtcbiAgICAgICAgICAgICAgcHJvY2Vzc0FmdGVyQXJyYXlWYWx1ZShjaGFyLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfTElURVJBTFwiOiB7XG4gICAgICAgIGNvbnN0IHBhcnRpYWxMaXRlcmFsID0gaW5wdXQuc3Vic3RyaW5nKGxpdGVyYWxTdGFydCwgaSArIDEpO1xuICAgICAgICBpZiAoIVwiZmFsc2VcIi5zdGFydHNXaXRoKHBhcnRpYWxMaXRlcmFsKSAmJiAhXCJ0cnVlXCIuc3RhcnRzV2l0aChwYXJ0aWFsTGl0ZXJhbCkgJiYgIVwibnVsbFwiLnN0YXJ0c1dpdGgocGFydGlhbExpdGVyYWwpKSB7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBcIklOU0lERV9PQkpFQ1RfQUZURVJfVkFMVUVcIikge1xuICAgICAgICAgICAgcHJvY2Vzc0FmdGVyT2JqZWN0VmFsdWUoY2hhciwgaSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gXCJJTlNJREVfQVJSQVlfQUZURVJfVkFMVUVcIikge1xuICAgICAgICAgICAgcHJvY2Vzc0FmdGVyQXJyYXlWYWx1ZShjaGFyLCBpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBsZXQgcmVzdWx0ID0gaW5wdXQuc2xpY2UoMCwgbGFzdFZhbGlkSW5kZXggKyAxKTtcbiAgZm9yIChsZXQgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBzdGFja1tpXTtcbiAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICBjYXNlIFwiSU5TSURFX1NUUklOR1wiOiB7XG4gICAgICAgIHJlc3VsdCArPSAnXCInO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0tFWVwiOlxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfQUZURVJfS0VZXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9BRlRFUl9DT01NQVwiOlxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfU1RBUlRcIjpcbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0JFRk9SRV9WQUxVRVwiOlxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfQUZURVJfVkFMVUVcIjoge1xuICAgICAgICByZXN1bHQgKz0gXCJ9XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9BUlJBWV9TVEFSVFwiOlxuICAgICAgY2FzZSBcIklOU0lERV9BUlJBWV9BRlRFUl9DT01NQVwiOlxuICAgICAgY2FzZSBcIklOU0lERV9BUlJBWV9BRlRFUl9WQUxVRVwiOiB7XG4gICAgICAgIHJlc3VsdCArPSBcIl1cIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX0xJVEVSQUxcIjoge1xuICAgICAgICBjb25zdCBwYXJ0aWFsTGl0ZXJhbCA9IGlucHV0LnN1YnN0cmluZyhsaXRlcmFsU3RhcnQsIGlucHV0Lmxlbmd0aCk7XG4gICAgICAgIGlmIChcInRydWVcIi5zdGFydHNXaXRoKHBhcnRpYWxMaXRlcmFsKSkge1xuICAgICAgICAgIHJlc3VsdCArPSBcInRydWVcIi5zbGljZShwYXJ0aWFsTGl0ZXJhbC5sZW5ndGgpO1xuICAgICAgICB9IGVsc2UgaWYgKFwiZmFsc2VcIi5zdGFydHNXaXRoKHBhcnRpYWxMaXRlcmFsKSkge1xuICAgICAgICAgIHJlc3VsdCArPSBcImZhbHNlXCIuc2xpY2UocGFydGlhbExpdGVyYWwubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIGlmIChcIm51bGxcIi5zdGFydHNXaXRoKHBhcnRpYWxMaXRlcmFsKSkge1xuICAgICAgICAgIHJlc3VsdCArPSBcIm51bGxcIi5zbGljZShwYXJ0aWFsTGl0ZXJhbC5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIGNvcmUvdXRpbC9wYXJzZS1wYXJ0aWFsLWpzb24udHNcbmZ1bmN0aW9uIHBhcnNlUGFydGlhbEpzb24oanNvblRleHQpIHtcbiAgaWYgKGpzb25UZXh0ID09IG51bGwpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIFNlY3VyZUpTT04ucGFyc2UoanNvblRleHQpO1xuICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGZpeGVkSnNvblRleHQgPSBmaXhKc29uKGpzb25UZXh0KTtcbiAgICAgIHJldHVybiBTZWN1cmVKU09OLnBhcnNlKGZpeGVkSnNvblRleHQpO1xuICAgIH0gY2F0Y2ggKGlnbm9yZWQyKSB7XG4gICAgfVxuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5cbi8vIGNvcmUvZ2VuZXJhdGUtb2JqZWN0L3N0cmVhbS1vYmplY3QudHNcbmFzeW5jIGZ1bmN0aW9uIHN0cmVhbU9iamVjdCh7XG4gIG1vZGVsLFxuICBzY2hlbWEsXG4gIG1vZGUsXG4gIHN5c3RlbSxcbiAgcHJvbXB0LFxuICBtZXNzYWdlcyxcbiAgbWF4UmV0cmllcyxcbiAgYWJvcnRTaWduYWwsXG4gIC4uLnNldHRpbmdzXG59KSB7XG4gIGNvbnN0IHJldHJ5ID0gcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKHsgbWF4UmV0cmllcyB9KTtcbiAgY29uc3QganNvblNjaGVtYSA9IGNvbnZlcnRab2RUb0pTT05TY2hlbWEoc2NoZW1hKTtcbiAgaWYgKG1vZGUgPT09IFwiYXV0b1wiIHx8IG1vZGUgPT0gbnVsbCkge1xuICAgIG1vZGUgPSBtb2RlbC5kZWZhdWx0T2JqZWN0R2VuZXJhdGlvbk1vZGU7XG4gIH1cbiAgbGV0IGNhbGxPcHRpb25zO1xuICBsZXQgdHJhbnNmb3JtZXI7XG4gIHN3aXRjaCAobW9kZSkge1xuICAgIGNhc2UgXCJqc29uXCI6IHtcbiAgICAgIGNvbnN0IHZhbGlkYXRlZFByb21wdCA9IGdldFZhbGlkYXRlZFByb21wdCh7XG4gICAgICAgIHN5c3RlbTogaW5qZWN0SnNvblNjaGVtYUludG9TeXN0ZW0oeyBzeXN0ZW0sIHNjaGVtYToganNvblNjaGVtYSB9KSxcbiAgICAgICAgcHJvbXB0LFxuICAgICAgICBtZXNzYWdlc1xuICAgICAgfSk7XG4gICAgICBjYWxsT3B0aW9ucyA9IHtcbiAgICAgICAgbW9kZTogeyB0eXBlOiBcIm9iamVjdC1qc29uXCIgfSxcbiAgICAgICAgLi4ucHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyksXG4gICAgICAgIGlucHV0Rm9ybWF0OiB2YWxpZGF0ZWRQcm9tcHQudHlwZSxcbiAgICAgICAgcHJvbXB0OiBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHZhbGlkYXRlZFByb21wdCksXG4gICAgICAgIGFib3J0U2lnbmFsXG4gICAgICB9O1xuICAgICAgdHJhbnNmb3JtZXIgPSB7XG4gICAgICAgIHRyYW5zZm9ybTogKGNodW5rLCBjb250cm9sbGVyKSA9PiB7XG4gICAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOlxuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmsudGV4dERlbHRhKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6XG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJncmFtbWFyXCI6IHtcbiAgICAgIGNvbnN0IHZhbGlkYXRlZFByb21wdCA9IGdldFZhbGlkYXRlZFByb21wdCh7XG4gICAgICAgIHN5c3RlbTogaW5qZWN0SnNvblNjaGVtYUludG9TeXN0ZW0oeyBzeXN0ZW0sIHNjaGVtYToganNvblNjaGVtYSB9KSxcbiAgICAgICAgcHJvbXB0LFxuICAgICAgICBtZXNzYWdlc1xuICAgICAgfSk7XG4gICAgICBjYWxsT3B0aW9ucyA9IHtcbiAgICAgICAgbW9kZTogeyB0eXBlOiBcIm9iamVjdC1ncmFtbWFyXCIsIHNjaGVtYToganNvblNjaGVtYSB9LFxuICAgICAgICAuLi5zZXR0aW5ncyxcbiAgICAgICAgaW5wdXRGb3JtYXQ6IHZhbGlkYXRlZFByb21wdC50eXBlLFxuICAgICAgICBwcm9tcHQ6IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQodmFsaWRhdGVkUHJvbXB0KSxcbiAgICAgICAgYWJvcnRTaWduYWxcbiAgICAgIH07XG4gICAgICB0cmFuc2Zvcm1lciA9IHtcbiAgICAgICAgdHJhbnNmb3JtOiAoY2h1bmssIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgICBzd2l0Y2ggKGNodW5rLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0LWRlbHRhXCI6XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay50ZXh0RGVsdGEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjpcbiAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcInRvb2xcIjoge1xuICAgICAgY29uc3QgdmFsaWRhdGVkUHJvbXB0ID0gZ2V0VmFsaWRhdGVkUHJvbXB0KHtcbiAgICAgICAgc3lzdGVtLFxuICAgICAgICBwcm9tcHQsXG4gICAgICAgIG1lc3NhZ2VzXG4gICAgICB9KTtcbiAgICAgIGNhbGxPcHRpb25zID0ge1xuICAgICAgICBtb2RlOiB7XG4gICAgICAgICAgdHlwZTogXCJvYmplY3QtdG9vbFwiLFxuICAgICAgICAgIHRvb2w6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgIG5hbWU6IFwianNvblwiLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiUmVzcG9uZCB3aXRoIGEgSlNPTiBvYmplY3QuXCIsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBqc29uU2NoZW1hXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAuLi5zZXR0aW5ncyxcbiAgICAgICAgaW5wdXRGb3JtYXQ6IHZhbGlkYXRlZFByb21wdC50eXBlLFxuICAgICAgICBwcm9tcHQ6IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQodmFsaWRhdGVkUHJvbXB0KSxcbiAgICAgICAgYWJvcnRTaWduYWxcbiAgICAgIH07XG4gICAgICB0cmFuc2Zvcm1lciA9IHtcbiAgICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsLWRlbHRhXCI6XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay5hcmdzVGV4dERlbHRhKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6XG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2Ugdm9pZCAwOiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNb2RlbCBkb2VzIG5vdCBoYXZlIGEgZGVmYXVsdCBvYmplY3QgZ2VuZXJhdGlvbiBtb2RlLlwiKTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IG1vZGU7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG1vZGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmV0cnkoKCkgPT4gbW9kZWwuZG9TdHJlYW0oY2FsbE9wdGlvbnMpKTtcbiAgcmV0dXJuIG5ldyBTdHJlYW1PYmplY3RSZXN1bHQoe1xuICAgIHN0cmVhbTogcmVzdWx0LnN0cmVhbS5waXBlVGhyb3VnaChuZXcgVHJhbnNmb3JtU3RyZWFtKHRyYW5zZm9ybWVyKSksXG4gICAgd2FybmluZ3M6IHJlc3VsdC53YXJuaW5ncyxcbiAgICByYXdSZXNwb25zZTogcmVzdWx0LnJhd1Jlc3BvbnNlXG4gIH0pO1xufVxudmFyIFN0cmVhbU9iamVjdFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHN0cmVhbSxcbiAgICB3YXJuaW5ncyxcbiAgICByYXdSZXNwb25zZVxuICB9KSB7XG4gICAgdGhpcy5vcmlnaW5hbFN0cmVhbSA9IHN0cmVhbTtcbiAgICB0aGlzLndhcm5pbmdzID0gd2FybmluZ3M7XG4gICAgdGhpcy5yYXdSZXNwb25zZSA9IHJhd1Jlc3BvbnNlO1xuICB9XG4gIGdldCBwYXJ0aWFsT2JqZWN0U3RyZWFtKCkge1xuICAgIGxldCBhY2N1bXVsYXRlZFRleHQgPSBcIlwiO1xuICAgIGxldCBsYXRlc3RPYmplY3QgPSB2b2lkIDA7XG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0odGhpcy5vcmlnaW5hbFN0cmVhbSwge1xuICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBhY2N1bXVsYXRlZFRleHQgKz0gY2h1bms7XG4gICAgICAgICAgY29uc3QgY3VycmVudE9iamVjdCA9IHBhcnNlUGFydGlhbEpzb24oXG4gICAgICAgICAgICBhY2N1bXVsYXRlZFRleHRcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmICghaXNEZWVwRXF1YWxEYXRhKGxhdGVzdE9iamVjdCwgY3VycmVudE9iamVjdCkpIHtcbiAgICAgICAgICAgIGxhdGVzdE9iamVjdCA9IGN1cnJlbnRPYmplY3Q7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY3VycmVudE9iamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNodW5rLnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgIHRocm93IGNodW5rLmVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0IGZ1bGxTdHJlYW0oKSB7XG4gICAgbGV0IGFjY3VtdWxhdGVkVGV4dCA9IFwiXCI7XG4gICAgbGV0IGxhdGVzdE9iamVjdCA9IHZvaWQgMDtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbSh0aGlzLm9yaWdpbmFsU3RyZWFtLCB7XG4gICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGFjY3VtdWxhdGVkVGV4dCArPSBjaHVuaztcbiAgICAgICAgICBjb25zdCBjdXJyZW50T2JqZWN0ID0gcGFyc2VQYXJ0aWFsSnNvbihcbiAgICAgICAgICAgIGFjY3VtdWxhdGVkVGV4dFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKCFpc0RlZXBFcXVhbERhdGEobGF0ZXN0T2JqZWN0LCBjdXJyZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgbGF0ZXN0T2JqZWN0ID0gY3VycmVudE9iamVjdDtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwib2JqZWN0XCIsIG9iamVjdDogY3VycmVudE9iamVjdCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgLi4uY2h1bmssXG4gICAgICAgICAgICAgICAgdXNhZ2U6IGNhbGN1bGF0ZVRva2VuVXNhZ2UoY2h1bmsudXNhZ2UpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xudmFyIGV4cGVyaW1lbnRhbF9zdHJlYW1PYmplY3QgPSBzdHJlYW1PYmplY3Q7XG5cbi8vIGNvcmUvZ2VuZXJhdGUtdGV4dC90b29sLWNhbGwudHNcbmltcG9ydCB7XG4gIEludmFsaWRUb29sQXJndW1lbnRzRXJyb3IsXG4gIE5vU3VjaFRvb2xFcnJvclxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuaW1wb3J0IHsgc2FmZVBhcnNlSlNPTiBhcyBzYWZlUGFyc2VKU09OMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5mdW5jdGlvbiBwYXJzZVRvb2xDYWxsKHtcbiAgdG9vbENhbGwsXG4gIHRvb2xzXG59KSB7XG4gIGNvbnN0IHRvb2xOYW1lID0gdG9vbENhbGwudG9vbE5hbWU7XG4gIGlmICh0b29scyA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IE5vU3VjaFRvb2xFcnJvcih7IHRvb2xOYW1lOiB0b29sQ2FsbC50b29sTmFtZSB9KTtcbiAgfVxuICBjb25zdCB0b29sMiA9IHRvb2xzW3Rvb2xOYW1lXTtcbiAgaWYgKHRvb2wyID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgTm9TdWNoVG9vbEVycm9yKHtcbiAgICAgIHRvb2xOYW1lOiB0b29sQ2FsbC50b29sTmFtZSxcbiAgICAgIGF2YWlsYWJsZVRvb2xzOiBPYmplY3Qua2V5cyh0b29scylcbiAgICB9KTtcbiAgfVxuICBjb25zdCBwYXJzZVJlc3VsdCA9IHNhZmVQYXJzZUpTT04yKHtcbiAgICB0ZXh0OiB0b29sQ2FsbC5hcmdzLFxuICAgIHNjaGVtYTogdG9vbDIucGFyYW1ldGVyc1xuICB9KTtcbiAgaWYgKHBhcnNlUmVzdWx0LnN1Y2Nlc3MgPT09IGZhbHNlKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRUb29sQXJndW1lbnRzRXJyb3Ioe1xuICAgICAgdG9vbE5hbWUsXG4gICAgICB0b29sQXJnczogdG9vbENhbGwuYXJncyxcbiAgICAgIGNhdXNlOiBwYXJzZVJlc3VsdC5lcnJvclxuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ0b29sLWNhbGxcIixcbiAgICB0b29sQ2FsbElkOiB0b29sQ2FsbC50b29sQ2FsbElkLFxuICAgIHRvb2xOYW1lLFxuICAgIGFyZ3M6IHBhcnNlUmVzdWx0LnZhbHVlXG4gIH07XG59XG5cbi8vIGNvcmUvZ2VuZXJhdGUtdGV4dC9nZW5lcmF0ZS10ZXh0LnRzXG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVRleHQoe1xuICBtb2RlbCxcbiAgdG9vbHMsXG4gIHN5c3RlbSxcbiAgcHJvbXB0LFxuICBtZXNzYWdlcyxcbiAgbWF4UmV0cmllcyxcbiAgYWJvcnRTaWduYWwsXG4gIC4uLnNldHRpbmdzXG59KSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IHJldHJ5ID0gcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKHsgbWF4UmV0cmllcyB9KTtcbiAgY29uc3QgdmFsaWRhdGVkUHJvbXB0ID0gZ2V0VmFsaWRhdGVkUHJvbXB0KHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0pO1xuICBjb25zdCBtb2RlbFJlc3BvbnNlID0gYXdhaXQgcmV0cnkoKCkgPT4ge1xuICAgIHJldHVybiBtb2RlbC5kb0dlbmVyYXRlKHtcbiAgICAgIG1vZGU6IHtcbiAgICAgICAgdHlwZTogXCJyZWd1bGFyXCIsXG4gICAgICAgIHRvb2xzOiB0b29scyA9PSBudWxsID8gdm9pZCAwIDogT2JqZWN0LmVudHJpZXModG9vbHMpLm1hcCgoW25hbWUsIHRvb2wyXSkgPT4gKHtcbiAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogdG9vbDIuZGVzY3JpcHRpb24sXG4gICAgICAgICAgcGFyYW1ldGVyczogY29udmVydFpvZFRvSlNPTlNjaGVtYSh0b29sMi5wYXJhbWV0ZXJzKVxuICAgICAgICB9KSlcbiAgICAgIH0sXG4gICAgICAuLi5wcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKSxcbiAgICAgIGlucHV0Rm9ybWF0OiB2YWxpZGF0ZWRQcm9tcHQudHlwZSxcbiAgICAgIHByb21wdDogY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh2YWxpZGF0ZWRQcm9tcHQpLFxuICAgICAgYWJvcnRTaWduYWxcbiAgICB9KTtcbiAgfSk7XG4gIGNvbnN0IHRvb2xDYWxscyA9IFtdO1xuICBmb3IgKGNvbnN0IG1vZGVsVG9vbENhbGwgb2YgKF9hID0gbW9kZWxSZXNwb25zZS50b29sQ2FsbHMpICE9IG51bGwgPyBfYSA6IFtdKSB7XG4gICAgdG9vbENhbGxzLnB1c2gocGFyc2VUb29sQ2FsbCh7IHRvb2xDYWxsOiBtb2RlbFRvb2xDYWxsLCB0b29scyB9KSk7XG4gIH1cbiAgY29uc3QgdG9vbFJlc3VsdHMgPSB0b29scyA9PSBudWxsID8gW10gOiBhd2FpdCBleGVjdXRlVG9vbHMoeyB0b29sQ2FsbHMsIHRvb2xzIH0pO1xuICByZXR1cm4gbmV3IEdlbmVyYXRlVGV4dFJlc3VsdCh7XG4gICAgLy8gQWx3YXlzIHJldHVybiBhIHN0cmluZyBzbyB0aGF0IHRoZSBjYWxsZXIgZG9lc24ndCBoYXZlIHRvIGNoZWNrIGZvciB1bmRlZmluZWQuXG4gICAgLy8gSWYgdGhleSBuZWVkIHRvIGNoZWNrIGlmIHRoZSBtb2RlbCBkaWQgbm90IHJldHVybiBhbnkgdGV4dCxcbiAgICAvLyB0aGV5IGNhbiBjaGVjayB0aGUgbGVuZ3RoIG9mIHRoZSBzdHJpbmc6XG4gICAgdGV4dDogKF9iID0gbW9kZWxSZXNwb25zZS50ZXh0KSAhPSBudWxsID8gX2IgOiBcIlwiLFxuICAgIHRvb2xDYWxscyxcbiAgICB0b29sUmVzdWx0cyxcbiAgICBmaW5pc2hSZWFzb246IG1vZGVsUmVzcG9uc2UuZmluaXNoUmVhc29uLFxuICAgIHVzYWdlOiBjYWxjdWxhdGVUb2tlblVzYWdlKG1vZGVsUmVzcG9uc2UudXNhZ2UpLFxuICAgIHdhcm5pbmdzOiBtb2RlbFJlc3BvbnNlLndhcm5pbmdzLFxuICAgIHJhd1Jlc3BvbnNlOiBtb2RlbFJlc3BvbnNlLnJhd1Jlc3BvbnNlLFxuICAgIGxvZ3Byb2JzOiBtb2RlbFJlc3BvbnNlLmxvZ3Byb2JzXG4gIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gZXhlY3V0ZVRvb2xzKHtcbiAgdG9vbENhbGxzLFxuICB0b29sc1xufSkge1xuICBjb25zdCB0b29sUmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgIHRvb2xDYWxscy5tYXAoYXN5bmMgKHRvb2xDYWxsKSA9PiB7XG4gICAgICBjb25zdCB0b29sMiA9IHRvb2xzW3Rvb2xDYWxsLnRvb2xOYW1lXTtcbiAgICAgIGlmICgodG9vbDIgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2wyLmV4ZWN1dGUpID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRvb2wyLmV4ZWN1dGUodG9vbENhbGwuYXJncyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b29sQ2FsbElkOiB0b29sQ2FsbC50b29sQ2FsbElkLFxuICAgICAgICB0b29sTmFtZTogdG9vbENhbGwudG9vbE5hbWUsXG4gICAgICAgIGFyZ3M6IHRvb2xDYWxsLmFyZ3MsXG4gICAgICAgIHJlc3VsdFxuICAgICAgfTtcbiAgICB9KVxuICApO1xuICByZXR1cm4gdG9vbFJlc3VsdHMuZmlsdGVyKFxuICAgIChyZXN1bHQpID0+IHJlc3VsdCAhPSBudWxsXG4gICk7XG59XG52YXIgR2VuZXJhdGVUZXh0UmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy50ZXh0ID0gb3B0aW9ucy50ZXh0O1xuICAgIHRoaXMudG9vbENhbGxzID0gb3B0aW9ucy50b29sQ2FsbHM7XG4gICAgdGhpcy50b29sUmVzdWx0cyA9IG9wdGlvbnMudG9vbFJlc3VsdHM7XG4gICAgdGhpcy5maW5pc2hSZWFzb24gPSBvcHRpb25zLmZpbmlzaFJlYXNvbjtcbiAgICB0aGlzLnVzYWdlID0gb3B0aW9ucy51c2FnZTtcbiAgICB0aGlzLndhcm5pbmdzID0gb3B0aW9ucy53YXJuaW5ncztcbiAgICB0aGlzLnJhd1Jlc3BvbnNlID0gb3B0aW9ucy5yYXdSZXNwb25zZTtcbiAgICB0aGlzLmxvZ3Byb2JzID0gb3B0aW9ucy5sb2dwcm9icztcbiAgfVxufTtcbnZhciBleHBlcmltZW50YWxfZ2VuZXJhdGVUZXh0ID0gZ2VuZXJhdGVUZXh0O1xuXG4vLyBjb3JlL2dlbmVyYXRlLXRleHQvcnVuLXRvb2xzLXRyYW5zZm9ybWF0aW9uLnRzXG5pbXBvcnQgeyBOb1N1Y2hUb29sRXJyb3IgYXMgTm9TdWNoVG9vbEVycm9yMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5cbi8vIHNoYXJlZC9nZW5lcmF0ZS1pZC50c1xuaW1wb3J0IHsgY3VzdG9tQWxwaGFiZXQgfSBmcm9tIFwibmFub2lkL25vbi1zZWN1cmVcIjtcbnZhciBnZW5lcmF0ZUlkID0gY3VzdG9tQWxwaGFiZXQoXG4gIFwiMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIixcbiAgN1xuKTtcblxuLy8gY29yZS9nZW5lcmF0ZS10ZXh0L3J1bi10b29scy10cmFuc2Zvcm1hdGlvbi50c1xuZnVuY3Rpb24gcnVuVG9vbHNUcmFuc2Zvcm1hdGlvbih7XG4gIHRvb2xzLFxuICBnZW5lcmF0b3JTdHJlYW1cbn0pIHtcbiAgbGV0IGNhbkNsb3NlID0gZmFsc2U7XG4gIGNvbnN0IG91dHN0YW5kaW5nVG9vbENhbGxzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgbGV0IHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlciA9IG51bGw7XG4gIGNvbnN0IHRvb2xSZXN1bHRzU3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGZvcndhcmRTdHJlYW0gPSBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnN0IGNodW5rVHlwZSA9IGNodW5rLnR5cGU7XG4gICAgICBzd2l0Y2ggKGNodW5rVHlwZSkge1xuICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOlxuICAgICAgICBjYXNlIFwiZXJyb3JcIjoge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInRvb2wtY2FsbFwiOiB7XG4gICAgICAgICAgY29uc3QgdG9vbE5hbWUgPSBjaHVuay50b29sTmFtZTtcbiAgICAgICAgICBpZiAodG9vbHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgIGVycm9yOiBuZXcgTm9TdWNoVG9vbEVycm9yMih7IHRvb2xOYW1lOiBjaHVuay50b29sTmFtZSB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdG9vbDIgPSB0b29sc1t0b29sTmFtZV07XG4gICAgICAgICAgaWYgKHRvb2wyID09IG51bGwpIHtcbiAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICBlcnJvcjogbmV3IE5vU3VjaFRvb2xFcnJvcjIoe1xuICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBjaHVuay50b29sTmFtZSxcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVUb29sczogT2JqZWN0LmtleXModG9vbHMpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdG9vbENhbGwgPSBwYXJzZVRvb2xDYWxsKHtcbiAgICAgICAgICAgICAgdG9vbENhbGw6IGNodW5rLFxuICAgICAgICAgICAgICB0b29sc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodG9vbENhbGwpO1xuICAgICAgICAgICAgaWYgKHRvb2wyLmV4ZWN1dGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBjb25zdCB0b29sRXhlY3V0aW9uSWQgPSBnZW5lcmF0ZUlkKCk7XG4gICAgICAgICAgICAgIG91dHN0YW5kaW5nVG9vbENhbGxzLmFkZCh0b29sRXhlY3V0aW9uSWQpO1xuICAgICAgICAgICAgICB0b29sMi5leGVjdXRlKHRvb2xDYWxsLmFyZ3MpLnRoZW4oXG4gICAgICAgICAgICAgICAgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAuLi50b29sQ2FsbCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHRcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgb3V0c3RhbmRpbmdUb29sQ2FsbHMuZGVsZXRlKHRvb2xFeGVjdXRpb25JZCk7XG4gICAgICAgICAgICAgICAgICBpZiAoY2FuQ2xvc2UgJiYgb3V0c3RhbmRpbmdUb29sQ2FsbHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIG91dHN0YW5kaW5nVG9vbENhbGxzLmRlbGV0ZSh0b29sRXhlY3V0aW9uSWQpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNhbkNsb3NlICYmIG91dHN0YW5kaW5nVG9vbENhbGxzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZmluaXNoXCI6IHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgdHlwZTogXCJmaW5pc2hcIixcbiAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogY2h1bmsuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgbG9ncHJvYnM6IGNodW5rLmxvZ3Byb2JzLFxuICAgICAgICAgICAgdXNhZ2U6IGNhbGN1bGF0ZVRva2VuVXNhZ2UoY2h1bmsudXNhZ2UpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInRvb2wtY2FsbC1kZWx0YVwiOiB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSBjaHVua1R5cGU7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmhhbmRsZWQgY2h1bmsgdHlwZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBmbHVzaCgpIHtcbiAgICAgIGNhbkNsb3NlID0gdHJ1ZTtcbiAgICAgIGlmIChvdXRzdGFuZGluZ1Rvb2xDYWxscy5zaXplID09PSAwKSB7XG4gICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgIGdlbmVyYXRvclN0cmVhbS5waXBlVGhyb3VnaChmb3J3YXJkU3RyZWFtKS5waXBlVG8oXG4gICAgICAgICAgbmV3IFdyaXRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgIHdyaXRlKGNodW5rKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvc2UoKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKSxcbiAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW0ucGlwZVRvKFxuICAgICAgICAgIG5ldyBXcml0YWJsZVN0cmVhbSh7XG4gICAgICAgICAgICB3cml0ZShjaHVuaykge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsb3NlKCkge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgXSk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS10ZXh0L3N0cmVhbS10ZXh0LnRzXG5hc3luYyBmdW5jdGlvbiBzdHJlYW1UZXh0KHtcbiAgbW9kZWwsXG4gIHRvb2xzLFxuICBzeXN0ZW0sXG4gIHByb21wdCxcbiAgbWVzc2FnZXMsXG4gIG1heFJldHJpZXMsXG4gIGFib3J0U2lnbmFsLFxuICAuLi5zZXR0aW5nc1xufSkge1xuICBjb25zdCByZXRyeSA9IHJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZih7IG1heFJldHJpZXMgfSk7XG4gIGNvbnN0IHZhbGlkYXRlZFByb21wdCA9IGdldFZhbGlkYXRlZFByb21wdCh7IHN5c3RlbSwgcHJvbXB0LCBtZXNzYWdlcyB9KTtcbiAgY29uc3QgeyBzdHJlYW0sIHdhcm5pbmdzLCByYXdSZXNwb25zZSB9ID0gYXdhaXQgcmV0cnkoXG4gICAgKCkgPT4gbW9kZWwuZG9TdHJlYW0oe1xuICAgICAgbW9kZToge1xuICAgICAgICB0eXBlOiBcInJlZ3VsYXJcIixcbiAgICAgICAgdG9vbHM6IHRvb2xzID09IG51bGwgPyB2b2lkIDAgOiBPYmplY3QuZW50cmllcyh0b29scykubWFwKChbbmFtZSwgdG9vbDJdKSA9PiAoe1xuICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiB0b29sMi5kZXNjcmlwdGlvbixcbiAgICAgICAgICBwYXJhbWV0ZXJzOiBjb252ZXJ0Wm9kVG9KU09OU2NoZW1hKHRvb2wyLnBhcmFtZXRlcnMpXG4gICAgICAgIH0pKVxuICAgICAgfSxcbiAgICAgIC4uLnByZXBhcmVDYWxsU2V0dGluZ3Moc2V0dGluZ3MpLFxuICAgICAgaW5wdXRGb3JtYXQ6IHZhbGlkYXRlZFByb21wdC50eXBlLFxuICAgICAgcHJvbXB0OiBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHZhbGlkYXRlZFByb21wdCksXG4gICAgICBhYm9ydFNpZ25hbFxuICAgIH0pXG4gICk7XG4gIHJldHVybiBuZXcgU3RyZWFtVGV4dFJlc3VsdCh7XG4gICAgc3RyZWFtOiBydW5Ub29sc1RyYW5zZm9ybWF0aW9uKHtcbiAgICAgIHRvb2xzLFxuICAgICAgZ2VuZXJhdG9yU3RyZWFtOiBzdHJlYW1cbiAgICB9KSxcbiAgICB3YXJuaW5ncyxcbiAgICByYXdSZXNwb25zZVxuICB9KTtcbn1cbnZhciBTdHJlYW1UZXh0UmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgc3RyZWFtLFxuICAgIHdhcm5pbmdzLFxuICAgIHJhd1Jlc3BvbnNlXG4gIH0pIHtcbiAgICB0aGlzLndhcm5pbmdzID0gd2FybmluZ3M7XG4gICAgdGhpcy5yYXdSZXNwb25zZSA9IHJhd1Jlc3BvbnNlO1xuICAgIGxldCByZXNvbHZlVXNhZ2U7XG4gICAgdGhpcy51c2FnZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICByZXNvbHZlVXNhZ2UgPSByZXNvbHZlO1xuICAgIH0pO1xuICAgIGxldCByZXNvbHZlRmluaXNoUmVhc29uO1xuICAgIHRoaXMuZmluaXNoUmVhc29uID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHJlc29sdmVGaW5pc2hSZWFzb24gPSByZXNvbHZlO1xuICAgIH0pO1xuICAgIHRoaXMub3JpZ2luYWxTdHJlYW0gPSBzdHJlYW0ucGlwZVRocm91Z2goXG4gICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJmaW5pc2hcIikge1xuICAgICAgICAgICAgcmVzb2x2ZVVzYWdlKGNodW5rLnVzYWdlKTtcbiAgICAgICAgICAgIHJlc29sdmVGaW5pc2hSZWFzb24oY2h1bmsuZmluaXNoUmVhc29uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICAvKipcbiAgU3BsaXQgb3V0IGEgbmV3IHN0cmVhbSBmcm9tIHRoZSBvcmlnaW5hbCBzdHJlYW0uXG4gIFRoZSBvcmlnaW5hbCBzdHJlYW0gaXMgcmVwbGFjZWQgdG8gYWxsb3cgZm9yIGZ1cnRoZXIgc3BsaXR0aW5nLFxuICBzaW5jZSB3ZSBkbyBub3Qga25vdyBob3cgbWFueSB0aW1lcyB0aGUgc3RyZWFtIHdpbGwgYmUgc3BsaXQuXG4gIFxuICBOb3RlOiB0aGlzIGxlYWRzIHRvIGJ1ZmZlcmluZyB0aGUgc3RyZWFtIGNvbnRlbnQgb24gdGhlIHNlcnZlci5cbiAgSG93ZXZlciwgdGhlIExMTSByZXN1bHRzIGFyZSBleHBlY3RlZCB0byBiZSBzbWFsbCBlbm91Z2ggdG8gbm90IGNhdXNlIGlzc3Vlcy5cbiAgICAgKi9cbiAgdGVlU3RyZWFtKCkge1xuICAgIGNvbnN0IFtzdHJlYW0xLCBzdHJlYW0yXSA9IHRoaXMub3JpZ2luYWxTdHJlYW0udGVlKCk7XG4gICAgdGhpcy5vcmlnaW5hbFN0cmVhbSA9IHN0cmVhbTI7XG4gICAgcmV0dXJuIHN0cmVhbTE7XG4gIH1cbiAgLyoqXG4gIEEgdGV4dCBzdHJlYW0gdGhhdCByZXR1cm5zIG9ubHkgdGhlIGdlbmVyYXRlZCB0ZXh0IGRlbHRhcy4gWW91IGNhbiB1c2UgaXRcbiAgYXMgZWl0aGVyIGFuIEFzeW5jSXRlcmFibGUgb3IgYSBSZWFkYWJsZVN0cmVhbS4gV2hlbiBhbiBlcnJvciBvY2N1cnMsIHRoZVxuICBzdHJlYW0gd2lsbCB0aHJvdyB0aGUgZXJyb3IuXG4gICAgICovXG4gIGdldCB0ZXh0U3RyZWFtKCkge1xuICAgIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKHRoaXMudGVlU3RyZWFtKCksIHtcbiAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJ0ZXh0LWRlbHRhXCIpIHtcbiAgICAgICAgICBpZiAoY2h1bmsudGV4dERlbHRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay50ZXh0RGVsdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjaHVuay50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICB0aHJvdyBjaHVuay5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICBBIHN0cmVhbSB3aXRoIGFsbCBldmVudHMsIGluY2x1ZGluZyB0ZXh0IGRlbHRhcywgdG9vbCBjYWxscywgdG9vbCByZXN1bHRzLCBhbmRcbiAgZXJyb3JzLlxuICBZb3UgY2FuIHVzZSBpdCBhcyBlaXRoZXIgYW4gQXN5bmNJdGVyYWJsZSBvciBhIFJlYWRhYmxlU3RyZWFtLiBXaGVuIGFuIGVycm9yIG9jY3VycywgdGhlXG4gIHN0cmVhbSB3aWxsIHRocm93IHRoZSBlcnJvci5cbiAgICAgKi9cbiAgZ2V0IGZ1bGxTdHJlYW0oKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0odGhpcy50ZWVTdHJlYW0oKSwge1xuICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgIGlmIChjaHVuay50eXBlID09PSBcInRleHQtZGVsdGFcIikge1xuICAgICAgICAgIGlmIChjaHVuay50ZXh0RGVsdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICBDb252ZXJ0cyB0aGUgcmVzdWx0IHRvIGFuIGBBSVN0cmVhbWAgb2JqZWN0IHRoYXQgaXMgY29tcGF0aWJsZSB3aXRoIGBTdHJlYW1pbmdUZXh0UmVzcG9uc2VgLlxuICBJdCBjYW4gYmUgdXNlZCB3aXRoIHRoZSBgdXNlQ2hhdGAgYW5kIGB1c2VDb21wbGV0aW9uYCBob29rcy5cbiAgXG4gIEBwYXJhbSBjYWxsYmFja3MgXG4gIFN0cmVhbSBjYWxsYmFja3MgdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBzdHJlYW0gZW1pdHMgZXZlbnRzLlxuICBcbiAgQHJldHVybnMgYW4gYEFJU3RyZWFtYCBvYmplY3QuXG4gICAgICovXG4gIHRvQUlTdHJlYW0oY2FsbGJhY2tzID0ge30pIHtcbiAgICBsZXQgYWdncmVnYXRlZFJlc3BvbnNlID0gXCJcIjtcbiAgICBjb25zdCBjYWxsYmFja1RyYW5zZm9ybWVyID0gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICBhc3luYyBzdGFydCgpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrcy5vblN0YXJ0KVxuICAgICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vblN0YXJ0KCk7XG4gICAgICB9LFxuICAgICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgIGlmIChjaHVuay50eXBlID09PSBcInRleHQtZGVsdGFcIikge1xuICAgICAgICAgIGNvbnN0IHRleHREZWx0YSA9IGNodW5rLnRleHREZWx0YTtcbiAgICAgICAgICBhZ2dyZWdhdGVkUmVzcG9uc2UgKz0gdGV4dERlbHRhO1xuICAgICAgICAgIGlmIChjYWxsYmFja3Mub25Ub2tlbilcbiAgICAgICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vblRva2VuKHRleHREZWx0YSk7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrcy5vblRleHQpXG4gICAgICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25UZXh0KHRleHREZWx0YSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhc3luYyBmbHVzaCgpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrcy5vbkNvbXBsZXRpb24pXG4gICAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uQ29tcGxldGlvbihhZ2dyZWdhdGVkUmVzcG9uc2UpO1xuICAgICAgICBpZiAoY2FsbGJhY2tzLm9uRmluYWwpXG4gICAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uRmluYWwoYWdncmVnYXRlZFJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBzdHJlYW1EYXRhVHJhbnNmb3JtZXIgPSBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIHRyYW5zZm9ybTogYXN5bmMgKGNodW5rLCBjb250cm9sbGVyKSA9PiB7XG4gICAgICAgIHN3aXRjaCAoY2h1bmsudHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJ0ZXh0LWRlbHRhXCI6XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZm9ybWF0U3RyZWFtUGFydChcInRleHRcIiwgY2h1bmsudGV4dERlbHRhKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsXCI6XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQoXCJ0b29sX2NhbGxcIiwge1xuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgdG9vbE5hbWU6IGNodW5rLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgIGFyZ3M6IGNodW5rLmFyZ3NcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwidG9vbC1yZXN1bHRcIjpcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgZm9ybWF0U3RyZWFtUGFydChcInRvb2xfcmVzdWx0XCIsIHtcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBjaHVuay50b29sTmFtZSxcbiAgICAgICAgICAgICAgICBhcmdzOiBjaHVuay5hcmdzLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogY2h1bmsucmVzdWx0XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQoXCJlcnJvclwiLCBKU09OLnN0cmluZ2lmeShjaHVuay5lcnJvcikpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5mdWxsU3RyZWFtLnBpcGVUaHJvdWdoKGNhbGxiYWNrVHJhbnNmb3JtZXIpLnBpcGVUaHJvdWdoKHN0cmVhbURhdGFUcmFuc2Zvcm1lcikucGlwZVRocm91Z2gobmV3IFRleHRFbmNvZGVyU3RyZWFtKCkpO1xuICB9XG4gIC8qKlxuICBXcml0ZXMgc3RyZWFtIGRhdGEgb3V0cHV0IHRvIGEgTm9kZS5qcyByZXNwb25zZS1saWtlIG9iamVjdC5cbiAgSXQgc2V0cyBhIGBDb250ZW50LVR5cGVgIGhlYWRlciB0byBgdGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOGAgYW5kIFxuICB3cml0ZXMgZWFjaCBzdHJlYW0gZGF0YSBwYXJ0IGFzIGEgc2VwYXJhdGUgY2h1bmsuXG4gIFxuICBAcGFyYW0gcmVzcG9uc2UgQSBOb2RlLmpzIHJlc3BvbnNlLWxpa2Ugb2JqZWN0IChTZXJ2ZXJSZXNwb25zZSkuXG4gIEBwYXJhbSBpbml0IE9wdGlvbmFsIGhlYWRlcnMgYW5kIHN0YXR1cyBjb2RlLlxuICAgICAqL1xuICBwaXBlQUlTdHJlYW1Ub1Jlc3BvbnNlKHJlc3BvbnNlLCBpbml0KSB7XG4gICAgdmFyIF9hO1xuICAgIHJlc3BvbnNlLndyaXRlSGVhZCgoX2EgPSBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cykgIT0gbnVsbCA/IF9hIDogMjAwLCB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIixcbiAgICAgIC4uLmluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuaGVhZGVyc1xuICAgIH0pO1xuICAgIGNvbnN0IHJlYWRlciA9IHRoaXMudGV4dFN0cmVhbS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcih2b2lkIDApKS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSkuZ2V0UmVhZGVyKCk7XG4gICAgY29uc3QgcmVhZCA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIHJlc3BvbnNlLndyaXRlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICByZXNwb25zZS5lbmQoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJlYWQoKTtcbiAgfVxuICAvKipcbiAgV3JpdGVzIHRleHQgZGVsdGEgb3V0cHV0IHRvIGEgTm9kZS5qcyByZXNwb25zZS1saWtlIG9iamVjdC5cbiAgSXQgc2V0cyBhIGBDb250ZW50LVR5cGVgIGhlYWRlciB0byBgdGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOGAgYW5kIFxuICB3cml0ZXMgZWFjaCB0ZXh0IGRlbHRhIGFzIGEgc2VwYXJhdGUgY2h1bmsuXG4gIFxuICBAcGFyYW0gcmVzcG9uc2UgQSBOb2RlLmpzIHJlc3BvbnNlLWxpa2Ugb2JqZWN0IChTZXJ2ZXJSZXNwb25zZSkuXG4gIEBwYXJhbSBpbml0IE9wdGlvbmFsIGhlYWRlcnMgYW5kIHN0YXR1cyBjb2RlLlxuICAgICAqL1xuICBwaXBlVGV4dFN0cmVhbVRvUmVzcG9uc2UocmVzcG9uc2UsIGluaXQpIHtcbiAgICB2YXIgX2E7XG4gICAgcmVzcG9uc2Uud3JpdGVIZWFkKChfYSA9IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzKSAhPSBudWxsID8gX2EgOiAyMDAsIHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiLFxuICAgICAgLi4uaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5oZWFkZXJzXG4gICAgfSk7XG4gICAgY29uc3QgcmVhZGVyID0gdGhpcy50ZXh0U3RyZWFtLmdldFJlYWRlcigpO1xuICAgIGNvbnN0IHJlYWQgPSBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICB0cnkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICByZXNwb25zZS53cml0ZShlbmNvZGVyLmVuY29kZSh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHJlc3BvbnNlLmVuZCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmVhZCgpO1xuICB9XG4gIC8qKlxuICBDb252ZXJ0cyB0aGUgcmVzdWx0IHRvIGEgc3RyZWFtZWQgcmVzcG9uc2Ugb2JqZWN0IHdpdGggYSBzdHJlYW0gZGF0YSBwYXJ0IHN0cmVhbS5cbiAgSXQgY2FuIGJlIHVzZWQgd2l0aCB0aGUgYHVzZUNoYXRgIGFuZCBgdXNlQ29tcGxldGlvbmAgaG9va3MuXG4gIFxuICBAcGFyYW0gaW5pdCBPcHRpb25hbCBoZWFkZXJzLlxuICBcbiAgQHJldHVybiBBIHJlc3BvbnNlIG9iamVjdC5cbiAgICAgKi9cbiAgdG9BSVN0cmVhbVJlc3BvbnNlKGluaXQpIHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbWluZ1RleHRSZXNwb25zZSh0aGlzLnRvQUlTdHJlYW0oKSwgaW5pdCk7XG4gIH1cbiAgLyoqXG4gIENyZWF0ZXMgYSBzaW1wbGUgdGV4dCBzdHJlYW0gcmVzcG9uc2UuXG4gIEVhY2ggdGV4dCBkZWx0YSBpcyBlbmNvZGVkIGFzIFVURi04IGFuZCBzZW50IGFzIGEgc2VwYXJhdGUgY2h1bmsuXG4gIE5vbi10ZXh0LWRlbHRhIGV2ZW50cyBhcmUgaWdub3JlZC5cbiAgXG4gIEBwYXJhbSBpbml0IE9wdGlvbmFsIGhlYWRlcnMgYW5kIHN0YXR1cyBjb2RlLlxuICAgICAqL1xuICB0b1RleHRTdHJlYW1SZXNwb25zZShpbml0KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKFxuICAgICAgdGhpcy50ZXh0U3RyZWFtLnBpcGVUaHJvdWdoKFxuICAgICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVyLmVuY29kZShjaHVuaykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICksXG4gICAgICB7XG4gICAgICAgIHN0YXR1czogKF9hID0gaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXMpICE9IG51bGwgPyBfYSA6IDIwMCxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiLFxuICAgICAgICAgIC4uLmluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuaGVhZGVyc1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgfVxufTtcbnZhciBleHBlcmltZW50YWxfc3RyZWFtVGV4dCA9IHN0cmVhbVRleHQ7XG5cbi8vIGNvcmUvcHJvbXB0L2NvbnZlcnQtdG8tY29yZS1tZXNzYWdlcy50c1xuZnVuY3Rpb24gY29udmVydFRvQ29yZU1lc3NhZ2VzKG1lc3NhZ2VzKSB7XG4gIGNvbnN0IGNvcmVNZXNzYWdlcyA9IFtdO1xuICBmb3IgKGNvbnN0IHsgcm9sZSwgY29udGVudCwgdG9vbEludm9jYXRpb25zIH0gb2YgbWVzc2FnZXMpIHtcbiAgICBzd2l0Y2ggKHJvbGUpIHtcbiAgICAgIGNhc2UgXCJ1c2VyXCI6IHtcbiAgICAgICAgY29yZU1lc3NhZ2VzLnB1c2goeyByb2xlOiBcInVzZXJcIiwgY29udGVudCB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiYXNzaXN0YW50XCI6IHtcbiAgICAgICAgaWYgKHRvb2xJbnZvY2F0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgY29yZU1lc3NhZ2VzLnB1c2goeyByb2xlOiBcImFzc2lzdGFudFwiLCBjb250ZW50IH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvcmVNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgIHsgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IGNvbnRlbnQgfSxcbiAgICAgICAgICAgIC4uLnRvb2xJbnZvY2F0aW9ucy5tYXAoKHsgdG9vbENhbGxJZCwgdG9vbE5hbWUsIGFyZ3MgfSkgPT4gKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWNhbGxcIixcbiAgICAgICAgICAgICAgdG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgIGFyZ3NcbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgIF1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvcmVNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICByb2xlOiBcInRvb2xcIixcbiAgICAgICAgICBjb250ZW50OiB0b29sSW52b2NhdGlvbnMubWFwKFxuICAgICAgICAgICAgKHsgdG9vbENhbGxJZCwgdG9vbE5hbWUsIGFyZ3MsIHJlc3VsdCB9KSA9PiAoe1xuICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgICAgIHRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgIHRvb2xOYW1lLFxuICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICByZXN1bHRcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSByb2xlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuaGFuZGxlZCByb2xlOiAke19leGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjb3JlTWVzc2FnZXM7XG59XG5cbi8vIGNvcmUvdG9vbC90b29sLnRzXG5mdW5jdGlvbiB0b29sKHRvb2wyKSB7XG4gIHJldHVybiB0b29sMjtcbn1cblxuLy8gY29yZS90eXBlcy9lcnJvcnMudHNcbmltcG9ydCB7XG4gIEFQSUNhbGxFcnJvciBhcyBBUElDYWxsRXJyb3IyLFxuICBFbXB0eVJlc3BvbnNlQm9keUVycm9yLFxuICBJbnZhbGlkQXJndW1lbnRFcnJvciBhcyBJbnZhbGlkQXJndW1lbnRFcnJvcjIsXG4gIEludmFsaWREYXRhQ29udGVudEVycm9yIGFzIEludmFsaWREYXRhQ29udGVudEVycm9yMixcbiAgSW52YWxpZFByb21wdEVycm9yIGFzIEludmFsaWRQcm9tcHRFcnJvcjIsXG4gIEludmFsaWRSZXNwb25zZURhdGFFcnJvcixcbiAgSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvciBhcyBJbnZhbGlkVG9vbEFyZ3VtZW50c0Vycm9yMixcbiAgSlNPTlBhcnNlRXJyb3IsXG4gIExvYWRBUElLZXlFcnJvcixcbiAgTm9PYmplY3RHZW5lcmF0ZWRFcnJvciBhcyBOb09iamVjdEdlbmVyYXRlZEVycm9yMixcbiAgTm9TdWNoVG9vbEVycm9yIGFzIE5vU3VjaFRvb2xFcnJvcjMsXG4gIFJldHJ5RXJyb3IgYXMgUmV0cnlFcnJvcjIsXG4gIFRvb2xDYWxsUGFyc2VFcnJvcixcbiAgVHlwZVZhbGlkYXRpb25FcnJvcixcbiAgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IsXG4gIFVuc3VwcG9ydGVkSlNPTlNjaGVtYUVycm9yXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5cbi8vIHNoYXJlZC9zdHJlYW0tcGFydHMudHNcbnZhciB0ZXh0U3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCIwXCIsXG4gIG5hbWU6IFwidGV4dFwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcInRleHRcIiBwYXJ0cyBleHBlY3QgYSBzdHJpbmcgdmFsdWUuJyk7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6IFwidGV4dFwiLCB2YWx1ZSB9O1xuICB9XG59O1xudmFyIGZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiMVwiLFxuICBuYW1lOiBcImZ1bmN0aW9uX2NhbGxcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwiZnVuY3Rpb25fY2FsbFwiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUuZnVuY3Rpb25fY2FsbCAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZS5mdW5jdGlvbl9jYWxsID09IG51bGwgfHwgIShcIm5hbWVcIiBpbiB2YWx1ZS5mdW5jdGlvbl9jYWxsKSB8fCAhKFwiYXJndW1lbnRzXCIgaW4gdmFsdWUuZnVuY3Rpb25fY2FsbCkgfHwgdHlwZW9mIHZhbHVlLmZ1bmN0aW9uX2NhbGwubmFtZSAhPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUuZnVuY3Rpb25fY2FsbC5hcmd1bWVudHMgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiZnVuY3Rpb25fY2FsbFwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwiZnVuY3Rpb25fY2FsbFwiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImZ1bmN0aW9uX2NhbGxcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxufTtcbnZhciBkYXRhU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCIyXCIsXG4gIG5hbWU6IFwiZGF0YVwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImRhdGFcIiBwYXJ0cyBleHBlY3QgYW4gYXJyYXkgdmFsdWUuJyk7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6IFwiZGF0YVwiLCB2YWx1ZSB9O1xuICB9XG59O1xudmFyIGVycm9yU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCIzXCIsXG4gIG5hbWU6IFwiZXJyb3JcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJlcnJvclwiIHBhcnRzIGV4cGVjdCBhIHN0cmluZyB2YWx1ZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCB2YWx1ZSB9O1xuICB9XG59O1xudmFyIGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjRcIixcbiAgbmFtZTogXCJhc3Npc3RhbnRfbWVzc2FnZVwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJpZFwiIGluIHZhbHVlKSB8fCAhKFwicm9sZVwiIGluIHZhbHVlKSB8fCAhKFwiY29udGVudFwiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUuaWQgIT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlLnJvbGUgIT09IFwic3RyaW5nXCIgfHwgdmFsdWUucm9sZSAhPT0gXCJhc3Npc3RhbnRcIiB8fCAhQXJyYXkuaXNBcnJheSh2YWx1ZS5jb250ZW50KSB8fCAhdmFsdWUuY29udGVudC5ldmVyeShcbiAgICAgIChpdGVtKSA9PiBpdGVtICE9IG51bGwgJiYgdHlwZW9mIGl0ZW0gPT09IFwib2JqZWN0XCIgJiYgXCJ0eXBlXCIgaW4gaXRlbSAmJiBpdGVtLnR5cGUgPT09IFwidGV4dFwiICYmIFwidGV4dFwiIGluIGl0ZW0gJiYgaXRlbS50ZXh0ICE9IG51bGwgJiYgdHlwZW9mIGl0ZW0udGV4dCA9PT0gXCJvYmplY3RcIiAmJiBcInZhbHVlXCIgaW4gaXRlbS50ZXh0ICYmIHR5cGVvZiBpdGVtLnRleHQudmFsdWUgPT09IFwic3RyaW5nXCJcbiAgICApKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImFzc2lzdGFudF9tZXNzYWdlXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGFuIFwiaWRcIiwgXCJyb2xlXCIsIGFuZCBcImNvbnRlbnRcIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJhc3Npc3RhbnRfbWVzc2FnZVwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG59O1xudmFyIGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCI1XCIsXG4gIG5hbWU6IFwiYXNzaXN0YW50X2NvbnRyb2xfZGF0YVwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJ0aHJlYWRJZFwiIGluIHZhbHVlKSB8fCAhKFwibWVzc2FnZUlkXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS50aHJlYWRJZCAhPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUubWVzc2FnZUlkICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImFzc2lzdGFudF9jb250cm9sX2RhdGFcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcInRocmVhZElkXCIgYW5kIFwibWVzc2FnZUlkXCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYXNzaXN0YW50X2NvbnRyb2xfZGF0YVwiLFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgdGhyZWFkSWQ6IHZhbHVlLnRocmVhZElkLFxuICAgICAgICBtZXNzYWdlSWQ6IHZhbHVlLm1lc3NhZ2VJZFxuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG52YXIgZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjZcIixcbiAgbmFtZTogXCJkYXRhX21lc3NhZ2VcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwicm9sZVwiIGluIHZhbHVlKSB8fCAhKFwiZGF0YVwiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUucm9sZSAhPT0gXCJzdHJpbmdcIiB8fCB2YWx1ZS5yb2xlICE9PSBcImRhdGFcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJkYXRhX21lc3NhZ2VcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcInJvbGVcIiBhbmQgXCJkYXRhXCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZGF0YV9tZXNzYWdlXCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbn07XG52YXIgdG9vbENhbGxzU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCI3XCIsXG4gIG5hbWU6IFwidG9vbF9jYWxsc1wiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJ0b29sX2NhbGxzXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS50b29sX2NhbGxzICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlLnRvb2xfY2FsbHMgPT0gbnVsbCB8fCAhQXJyYXkuaXNBcnJheSh2YWx1ZS50b29sX2NhbGxzKSB8fCB2YWx1ZS50b29sX2NhbGxzLnNvbWUoXG4gICAgICAodGMpID0+IHRjID09IG51bGwgfHwgdHlwZW9mIHRjICE9PSBcIm9iamVjdFwiIHx8ICEoXCJpZFwiIGluIHRjKSB8fCB0eXBlb2YgdGMuaWQgIT09IFwic3RyaW5nXCIgfHwgIShcInR5cGVcIiBpbiB0YykgfHwgdHlwZW9mIHRjLnR5cGUgIT09IFwic3RyaW5nXCIgfHwgIShcImZ1bmN0aW9uXCIgaW4gdGMpIHx8IHRjLmZ1bmN0aW9uID09IG51bGwgfHwgdHlwZW9mIHRjLmZ1bmN0aW9uICE9PSBcIm9iamVjdFwiIHx8ICEoXCJhcmd1bWVudHNcIiBpbiB0Yy5mdW5jdGlvbikgfHwgdHlwZW9mIHRjLmZ1bmN0aW9uLm5hbWUgIT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHRjLmZ1bmN0aW9uLmFyZ3VtZW50cyAhPT0gXCJzdHJpbmdcIlxuICAgICkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1widG9vbF9jYWxsc1wiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFRvb2xDYWxsUGF5bG9hZC4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ0b29sX2NhbGxzXCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbn07XG52YXIgbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCI4XCIsXG4gIG5hbWU6IFwibWVzc2FnZV9hbm5vdGF0aW9uc1wiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm1lc3NhZ2VfYW5ub3RhdGlvbnNcIiBwYXJ0cyBleHBlY3QgYW4gYXJyYXkgdmFsdWUuJyk7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6IFwibWVzc2FnZV9hbm5vdGF0aW9uc1wiLCB2YWx1ZSB9O1xuICB9XG59O1xudmFyIHRvb2xDYWxsU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCI5XCIsXG4gIG5hbWU6IFwidG9vbF9jYWxsXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcInRvb2xDYWxsSWRcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLnRvb2xDYWxsSWQgIT09IFwic3RyaW5nXCIgfHwgIShcInRvb2xOYW1lXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS50b29sTmFtZSAhPT0gXCJzdHJpbmdcIiB8fCAhKFwiYXJnc1wiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUuYXJncyAhPT0gXCJvYmplY3RcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJ0b29sX2NhbGxcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcInRvb2xDYWxsSWRcIiwgXCJ0b29sTmFtZVwiLCBhbmQgXCJhcmdzXCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidG9vbF9jYWxsXCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbn07XG52YXIgdG9vbFJlc3VsdFN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiYVwiLFxuICBuYW1lOiBcInRvb2xfcmVzdWx0XCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcInRvb2xDYWxsSWRcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLnRvb2xDYWxsSWQgIT09IFwic3RyaW5nXCIgfHwgIShcInRvb2xOYW1lXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS50b29sTmFtZSAhPT0gXCJzdHJpbmdcIiB8fCAhKFwiYXJnc1wiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUuYXJncyAhPT0gXCJvYmplY3RcIiB8fCAhKFwicmVzdWx0XCIgaW4gdmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcInRvb2xfcmVzdWx0XCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJ0b29sQ2FsbElkXCIsIFwidG9vbE5hbWVcIiwgXCJhcmdzXCIsIGFuZCBcInJlc3VsdFwiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInRvb2xfcmVzdWx0XCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbn07XG52YXIgc3RyZWFtUGFydHMgPSBbXG4gIHRleHRTdHJlYW1QYXJ0LFxuICBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0LFxuICBkYXRhU3RyZWFtUGFydCxcbiAgZXJyb3JTdHJlYW1QYXJ0LFxuICBhc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydCxcbiAgYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0LFxuICBkYXRhTWVzc2FnZVN0cmVhbVBhcnQsXG4gIHRvb2xDYWxsc1N0cmVhbVBhcnQsXG4gIG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQsXG4gIHRvb2xDYWxsU3RyZWFtUGFydCxcbiAgdG9vbFJlc3VsdFN0cmVhbVBhcnRcbl07XG52YXIgc3RyZWFtUGFydHNCeUNvZGUgPSB7XG4gIFt0ZXh0U3RyZWFtUGFydC5jb2RlXTogdGV4dFN0cmVhbVBhcnQsXG4gIFtmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0LmNvZGVdOiBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0LFxuICBbZGF0YVN0cmVhbVBhcnQuY29kZV06IGRhdGFTdHJlYW1QYXJ0LFxuICBbZXJyb3JTdHJlYW1QYXJ0LmNvZGVdOiBlcnJvclN0cmVhbVBhcnQsXG4gIFthc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydC5jb2RlXTogYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQsXG4gIFthc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQuY29kZV06IGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydCxcbiAgW2RhdGFNZXNzYWdlU3RyZWFtUGFydC5jb2RlXTogZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0LFxuICBbdG9vbENhbGxzU3RyZWFtUGFydC5jb2RlXTogdG9vbENhbGxzU3RyZWFtUGFydCxcbiAgW21lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQuY29kZV06IG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQsXG4gIFt0b29sQ2FsbFN0cmVhbVBhcnQuY29kZV06IHRvb2xDYWxsU3RyZWFtUGFydCxcbiAgW3Rvb2xSZXN1bHRTdHJlYW1QYXJ0LmNvZGVdOiB0b29sUmVzdWx0U3RyZWFtUGFydFxufTtcbnZhciBTdHJlYW1TdHJpbmdQcmVmaXhlcyA9IHtcbiAgW3RleHRTdHJlYW1QYXJ0Lm5hbWVdOiB0ZXh0U3RyZWFtUGFydC5jb2RlLFxuICBbZnVuY3Rpb25DYWxsU3RyZWFtUGFydC5uYW1lXTogZnVuY3Rpb25DYWxsU3RyZWFtUGFydC5jb2RlLFxuICBbZGF0YVN0cmVhbVBhcnQubmFtZV06IGRhdGFTdHJlYW1QYXJ0LmNvZGUsXG4gIFtlcnJvclN0cmVhbVBhcnQubmFtZV06IGVycm9yU3RyZWFtUGFydC5jb2RlLFxuICBbYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQubmFtZV06IGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0LmNvZGUsXG4gIFthc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQubmFtZV06IGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydC5jb2RlLFxuICBbZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0Lm5hbWVdOiBkYXRhTWVzc2FnZVN0cmVhbVBhcnQuY29kZSxcbiAgW3Rvb2xDYWxsc1N0cmVhbVBhcnQubmFtZV06IHRvb2xDYWxsc1N0cmVhbVBhcnQuY29kZSxcbiAgW21lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQubmFtZV06IG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQuY29kZSxcbiAgW3Rvb2xDYWxsU3RyZWFtUGFydC5uYW1lXTogdG9vbENhbGxTdHJlYW1QYXJ0LmNvZGUsXG4gIFt0b29sUmVzdWx0U3RyZWFtUGFydC5uYW1lXTogdG9vbFJlc3VsdFN0cmVhbVBhcnQuY29kZVxufTtcbnZhciB2YWxpZENvZGVzID0gc3RyZWFtUGFydHMubWFwKChwYXJ0KSA9PiBwYXJ0LmNvZGUpO1xudmFyIHBhcnNlU3RyZWFtUGFydCA9IChsaW5lKSA9PiB7XG4gIGNvbnN0IGZpcnN0U2VwYXJhdG9ySW5kZXggPSBsaW5lLmluZGV4T2YoXCI6XCIpO1xuICBpZiAoZmlyc3RTZXBhcmF0b3JJbmRleCA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gcGFyc2Ugc3RyZWFtIHN0cmluZy4gTm8gc2VwYXJhdG9yIGZvdW5kLlwiKTtcbiAgfVxuICBjb25zdCBwcmVmaXggPSBsaW5lLnNsaWNlKDAsIGZpcnN0U2VwYXJhdG9ySW5kZXgpO1xuICBpZiAoIXZhbGlkQ29kZXMuaW5jbHVkZXMocHJlZml4KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIHN0cmVhbSBzdHJpbmcuIEludmFsaWQgY29kZSAke3ByZWZpeH0uYCk7XG4gIH1cbiAgY29uc3QgY29kZSA9IHByZWZpeDtcbiAgY29uc3QgdGV4dFZhbHVlID0gbGluZS5zbGljZShmaXJzdFNlcGFyYXRvckluZGV4ICsgMSk7XG4gIGNvbnN0IGpzb25WYWx1ZSA9IEpTT04ucGFyc2UodGV4dFZhbHVlKTtcbiAgcmV0dXJuIHN0cmVhbVBhcnRzQnlDb2RlW2NvZGVdLnBhcnNlKGpzb25WYWx1ZSk7XG59O1xuZnVuY3Rpb24gZm9ybWF0U3RyZWFtUGFydCh0eXBlLCB2YWx1ZSkge1xuICBjb25zdCBzdHJlYW1QYXJ0ID0gc3RyZWFtUGFydHMuZmluZCgocGFydCkgPT4gcGFydC5uYW1lID09PSB0eXBlKTtcbiAgaWYgKCFzdHJlYW1QYXJ0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHN0cmVhbSBwYXJ0IHR5cGU6ICR7dHlwZX1gKTtcbiAgfVxuICByZXR1cm4gYCR7c3RyZWFtUGFydC5jb2RlfToke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1cbmA7XG59XG5cbi8vIHNoYXJlZC9yZWFkLWRhdGEtc3RyZWFtLnRzXG52YXIgTkVXTElORSA9IFwiXFxuXCIuY2hhckNvZGVBdCgwKTtcbmZ1bmN0aW9uIGNvbmNhdENodW5rcyhjaHVua3MsIHRvdGFsTGVuZ3RoKSB7XG4gIGNvbnN0IGNvbmNhdGVuYXRlZENodW5rcyA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGZvciAoY29uc3QgY2h1bmsgb2YgY2h1bmtzKSB7XG4gICAgY29uY2F0ZW5hdGVkQ2h1bmtzLnNldChjaHVuaywgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gY2h1bmsubGVuZ3RoO1xuICB9XG4gIGNodW5rcy5sZW5ndGggPSAwO1xuICByZXR1cm4gY29uY2F0ZW5hdGVkQ2h1bmtzO1xufVxuYXN5bmMgZnVuY3Rpb24qIHJlYWREYXRhU3RyZWFtKHJlYWRlciwge1xuICBpc0Fib3J0ZWRcbn0gPSB7fSkge1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIGNvbnN0IGNodW5rcyA9IFtdO1xuICBsZXQgdG90YWxMZW5ndGggPSAwO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHsgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBjaHVua3MucHVzaCh2YWx1ZSk7XG4gICAgICB0b3RhbExlbmd0aCArPSB2YWx1ZS5sZW5ndGg7XG4gICAgICBpZiAodmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gIT09IE5FV0xJTkUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3QgY29uY2F0ZW5hdGVkQ2h1bmtzID0gY29uY2F0Q2h1bmtzKGNodW5rcywgdG90YWxMZW5ndGgpO1xuICAgIHRvdGFsTGVuZ3RoID0gMDtcbiAgICBjb25zdCBzdHJlYW1QYXJ0czIgPSBkZWNvZGVyLmRlY29kZShjb25jYXRlbmF0ZWRDaHVua3MsIHsgc3RyZWFtOiB0cnVlIH0pLnNwbGl0KFwiXFxuXCIpLmZpbHRlcigobGluZSkgPT4gbGluZSAhPT0gXCJcIikubWFwKHBhcnNlU3RyZWFtUGFydCk7XG4gICAgZm9yIChjb25zdCBzdHJlYW1QYXJ0IG9mIHN0cmVhbVBhcnRzMikge1xuICAgICAgeWllbGQgc3RyZWFtUGFydDtcbiAgICB9XG4gICAgaWYgKGlzQWJvcnRlZCA9PSBudWxsID8gdm9pZCAwIDogaXNBYm9ydGVkKCkpIHtcbiAgICAgIHJlYWRlci5jYW5jZWwoKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG4vLyBzaGFyZWQvdXRpbHMudHNcbmZ1bmN0aW9uIGNyZWF0ZUNodW5rRGVjb2Rlcihjb21wbGV4KSB7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgaWYgKCFjb21wbGV4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICBpZiAoIWNodW5rKVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIHJldHVybiBkZWNvZGVyLmRlY29kZShjaHVuaywgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oY2h1bmspIHtcbiAgICBjb25zdCBkZWNvZGVkID0gZGVjb2Rlci5kZWNvZGUoY2h1bmssIHsgc3RyZWFtOiB0cnVlIH0pLnNwbGl0KFwiXFxuXCIpLmZpbHRlcigobGluZSkgPT4gbGluZSAhPT0gXCJcIik7XG4gICAgcmV0dXJuIGRlY29kZWQubWFwKHBhcnNlU3RyZWFtUGFydCkuZmlsdGVyKEJvb2xlYW4pO1xuICB9O1xufVxudmFyIGlzU3RyZWFtU3RyaW5nRXF1YWxUb1R5cGUgPSAodHlwZSwgdmFsdWUpID0+IHZhbHVlLnN0YXJ0c1dpdGgoYCR7U3RyZWFtU3RyaW5nUHJlZml4ZXNbdHlwZV19OmApICYmIHZhbHVlLmVuZHNXaXRoKFwiXFxuXCIpO1xuXG4vLyBzdHJlYW1zL2FpLXN0cmVhbS50c1xuaW1wb3J0IHtcbiAgY3JlYXRlUGFyc2VyXG59IGZyb20gXCJldmVudHNvdXJjZS1wYXJzZXJcIjtcbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50U3RyZWFtVHJhbnNmb3JtZXIoY3VzdG9tUGFyc2VyKSB7XG4gIGNvbnN0IHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIGxldCBldmVudFNvdXJjZVBhcnNlcjtcbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIGV2ZW50U291cmNlUGFyc2VyID0gY3JlYXRlUGFyc2VyKFxuICAgICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgICBpZiAoXCJkYXRhXCIgaW4gZXZlbnQgJiYgZXZlbnQudHlwZSA9PT0gXCJldmVudFwiICYmIGV2ZW50LmRhdGEgPT09IFwiW0RPTkVdXCIgfHwgLy8gUmVwbGljYXRlIGRvZXNuJ3Qgc2VuZCBbRE9ORV0gYnV0IGRvZXMgc2VuZCBhICdkb25lJyBldmVudFxuICAgICAgICAgIC8vIEBzZWUgaHR0cHM6Ly9yZXBsaWNhdGUuY29tL2RvY3Mvc3RyZWFtaW5nXG4gICAgICAgICAgZXZlbnQuZXZlbnQgPT09IFwiZG9uZVwiKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXCJkYXRhXCIgaW4gZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZE1lc3NhZ2UgPSBjdXN0b21QYXJzZXIgPyBjdXN0b21QYXJzZXIoZXZlbnQuZGF0YSwge1xuICAgICAgICAgICAgICBldmVudDogZXZlbnQuZXZlbnRcbiAgICAgICAgICAgIH0pIDogZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIGlmIChwYXJzZWRNZXNzYWdlKVxuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUocGFyc2VkTWVzc2FnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH0sXG4gICAgdHJhbnNmb3JtKGNodW5rKSB7XG4gICAgICBldmVudFNvdXJjZVBhcnNlci5mZWVkKHRleHREZWNvZGVyLmRlY29kZShjaHVuaykpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYikge1xuICBjb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICBsZXQgYWdncmVnYXRlZFJlc3BvbnNlID0gXCJcIjtcbiAgY29uc3QgY2FsbGJhY2tzID0gY2IgfHwge307XG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICBhc3luYyBzdGFydCgpIHtcbiAgICAgIGlmIChjYWxsYmFja3Mub25TdGFydClcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uU3RhcnQoKTtcbiAgICB9LFxuICAgIGFzeW5jIHRyYW5zZm9ybShtZXNzYWdlLCBjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgPyBtZXNzYWdlIDogbWVzc2FnZS5jb250ZW50O1xuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHRleHRFbmNvZGVyLmVuY29kZShjb250ZW50KSk7XG4gICAgICBhZ2dyZWdhdGVkUmVzcG9uc2UgKz0gY29udGVudDtcbiAgICAgIGlmIChjYWxsYmFja3Mub25Ub2tlbilcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uVG9rZW4oY29udGVudCk7XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uVGV4dCAmJiB0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25UZXh0KG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH0sXG4gICAgYXN5bmMgZmx1c2goKSB7XG4gICAgICBjb25zdCBpc09wZW5BSUNhbGxiYWNrcyA9IGlzT2ZUeXBlT3BlbkFJU3RyZWFtQ2FsbGJhY2tzKGNhbGxiYWNrcyk7XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uQ29tcGxldGlvbikge1xuICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25Db21wbGV0aW9uKGFnZ3JlZ2F0ZWRSZXNwb25zZSk7XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uRmluYWwgJiYgIWlzT3BlbkFJQ2FsbGJhY2tzKSB7XG4gICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vbkZpbmFsKGFnZ3JlZ2F0ZWRSZXNwb25zZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGlzT2ZUeXBlT3BlbkFJU3RyZWFtQ2FsbGJhY2tzKGNhbGxiYWNrcykge1xuICByZXR1cm4gXCJleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGxcIiBpbiBjYWxsYmFja3M7XG59XG5mdW5jdGlvbiB0cmltU3RhcnRPZlN0cmVhbUhlbHBlcigpIHtcbiAgbGV0IGlzU3RyZWFtU3RhcnQgPSB0cnVlO1xuICByZXR1cm4gKHRleHQpID0+IHtcbiAgICBpZiAoaXNTdHJlYW1TdGFydCkge1xuICAgICAgdGV4dCA9IHRleHQudHJpbVN0YXJ0KCk7XG4gICAgICBpZiAodGV4dClcbiAgICAgICAgaXNTdHJlYW1TdGFydCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcbn1cbmZ1bmN0aW9uIEFJU3RyZWFtKHJlc3BvbnNlLCBjdXN0b21QYXJzZXIsIGNhbGxiYWNrcykge1xuICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgaWYgKHJlc3BvbnNlLmJvZHkpIHtcbiAgICAgIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gICAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvclRleHQgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUodmFsdWUpO1xuICAgICAgICAgICAgY29udHJvbGxlci5lcnJvcihuZXcgRXJyb3IoYFJlc3BvbnNlIGVycm9yOiAke2Vycm9yVGV4dH1gKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVycm9yKG5ldyBFcnJvcihcIlJlc3BvbnNlIGVycm9yOiBObyByZXNwb25zZSBib2R5XCIpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHJlc3BvbnNlQm9keVN0cmVhbSA9IHJlc3BvbnNlLmJvZHkgfHwgY3JlYXRlRW1wdHlSZWFkYWJsZVN0cmVhbSgpO1xuICByZXR1cm4gcmVzcG9uc2VCb2R5U3RyZWFtLnBpcGVUaHJvdWdoKGNyZWF0ZUV2ZW50U3RyZWFtVHJhbnNmb3JtZXIoY3VzdG9tUGFyc2VyKSkucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVFbXB0eVJlYWRhYmxlU3RyZWFtKCkge1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGUoaXRlcmFibGUpIHtcbiAgbGV0IGl0ID0gaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgaXQubmV4dCgpO1xuICAgICAgaWYgKGRvbmUpXG4gICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgIGVsc2VcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICB9LFxuICAgIGFzeW5jIGNhbmNlbChyZWFzb24pIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGF3YWl0ICgoX2EgPSBpdC5yZXR1cm4pID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKGl0LCByZWFzb24pKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzdHJlYW1zL3N0cmVhbS1kYXRhLnRzXG52YXIgU3RyZWFtRGF0YSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5lbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgdGhpcy5jb250cm9sbGVyID0gbnVsbDtcbiAgICAvLyBjbG9zaW5nIHRoZSBzdHJlYW0gaXMgc3luY2hyb25vdXMsIGJ1dCB3ZSB3YW50IHRvIHJldHVybiBhIHByb21pc2VcbiAgICAvLyBpbiBjYXNlIHdlJ3JlIGRvaW5nIGFzeW5jIHdvcmtcbiAgICB0aGlzLmlzQ2xvc2VkUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5pc0Nsb3NlZFByb21pc2VSZXNvbHZlciA9IHZvaWQgMDtcbiAgICB0aGlzLmlzQ2xvc2VkID0gZmFsc2U7XG4gICAgLy8gYXJyYXkgdG8gc3RvcmUgYXBwZW5kZWQgZGF0YVxuICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgIHRoaXMubWVzc2FnZUFubm90YXRpb25zID0gW107XG4gICAgdGhpcy5pc0Nsb3NlZFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgdGhpcy5pc0Nsb3NlZFByb21pc2VSZXNvbHZlciA9IHJlc29sdmU7XG4gICAgfSk7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5zdHJlYW0gPSBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIHN0YXJ0OiBhc3luYyAoY29udHJvbGxlcikgPT4ge1xuICAgICAgICBzZWxmLmNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybTogYXN5bmMgKGNodW5rLCBjb250cm9sbGVyKSA9PiB7XG4gICAgICAgIGlmIChzZWxmLmRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IGVuY29kZWREYXRhID0gc2VsZi5lbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQoXCJkYXRhXCIsIHNlbGYuZGF0YSlcbiAgICAgICAgICApO1xuICAgICAgICAgIHNlbGYuZGF0YSA9IFtdO1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVkRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYubWVzc2FnZUFubm90YXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IGVuY29kZWRNZXNzYWdlQW5ub3RhdGlvbnMgPSBzZWxmLmVuY29kZXIuZW5jb2RlKFxuICAgICAgICAgICAgZm9ybWF0U3RyZWFtUGFydChcIm1lc3NhZ2VfYW5ub3RhdGlvbnNcIiwgc2VsZi5tZXNzYWdlQW5ub3RhdGlvbnMpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzZWxmLm1lc3NhZ2VBbm5vdGF0aW9ucyA9IFtdO1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVkTWVzc2FnZUFubm90YXRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgfSxcbiAgICAgIGFzeW5jIGZsdXNoKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3Qgd2FybmluZ1RpbWVvdXQgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiID8gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgXCJUaGUgZGF0YSBzdHJlYW0gaXMgaGFuZ2luZy4gRGlkIHlvdSBmb3JnZXQgdG8gY2xvc2UgaXQgd2l0aCBgZGF0YS5jbG9zZSgpYD9cIlxuICAgICAgICAgICk7XG4gICAgICAgIH0sIDNlMykgOiBudWxsO1xuICAgICAgICBhd2FpdCBzZWxmLmlzQ2xvc2VkUHJvbWlzZTtcbiAgICAgICAgaWYgKHdhcm5pbmdUaW1lb3V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHdhcm5pbmdUaW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5kYXRhLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IGVuY29kZWREYXRhID0gc2VsZi5lbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQoXCJkYXRhXCIsIHNlbGYuZGF0YSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVkRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYubWVzc2FnZUFubm90YXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IGVuY29kZWREYXRhID0gc2VsZi5lbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQoXCJtZXNzYWdlX2Fubm90YXRpb25zXCIsIHNlbGYubWVzc2FnZUFubm90YXRpb25zKVxuICAgICAgICAgICk7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGVuY29kZWREYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGNsb3NlKCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YSBTdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY29udHJvbGxlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RyZWFtIGNvbnRyb2xsZXIgaXMgbm90IGluaXRpYWxpemVkLlwiKTtcbiAgICB9XG4gICAgKF9hID0gdGhpcy5pc0Nsb3NlZFByb21pc2VSZXNvbHZlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcyk7XG4gICAgdGhpcy5pc0Nsb3NlZCA9IHRydWU7XG4gIH1cbiAgYXBwZW5kKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGEgU3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLlwiKTtcbiAgICB9XG4gICAgdGhpcy5kYXRhLnB1c2godmFsdWUpO1xuICB9XG4gIGFwcGVuZE1lc3NhZ2VBbm5vdGF0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGEgU3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLlwiKTtcbiAgICB9XG4gICAgdGhpcy5tZXNzYWdlQW5ub3RhdGlvbnMucHVzaCh2YWx1ZSk7XG4gIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSB7XG4gIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgdHJhbnNmb3JtOiBhc3luYyAoY2h1bmssIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBkZWNvZGVyLmRlY29kZShjaHVuayk7XG4gICAgICBjb250cm9sbGVyLmVucXVldWUoZW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydChcInRleHRcIiwgbWVzc2FnZSkpKTtcbiAgICB9XG4gIH0pO1xufVxudmFyIGV4cGVyaW1lbnRhbF9TdHJlYW1EYXRhID0gY2xhc3MgZXh0ZW5kcyBTdHJlYW1EYXRhIHtcbn07XG5cbi8vIHN0cmVhbXMvYW50aHJvcGljLXN0cmVhbS50c1xuZnVuY3Rpb24gcGFyc2VBbnRocm9waWNTdHJlYW0oKSB7XG4gIGxldCBwcmV2aW91cyA9IFwiXCI7XG4gIHJldHVybiAoZGF0YSkgPT4ge1xuICAgIGNvbnN0IGpzb24gPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgIGlmIChcImVycm9yXCIgaW4ganNvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2pzb24uZXJyb3IudHlwZX06ICR7anNvbi5lcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgICBpZiAoIShcImNvbXBsZXRpb25cIiBpbiBqc29uKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0ID0ganNvbi5jb21wbGV0aW9uO1xuICAgIGlmICghcHJldmlvdXMgfHwgdGV4dC5sZW5ndGggPiBwcmV2aW91cy5sZW5ndGggJiYgdGV4dC5zdGFydHNXaXRoKHByZXZpb3VzKSkge1xuICAgICAgY29uc3QgZGVsdGEgPSB0ZXh0LnNsaWNlKHByZXZpb3VzLmxlbmd0aCk7XG4gICAgICBwcmV2aW91cyA9IHRleHQ7XG4gICAgICByZXR1cm4gZGVsdGE7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0O1xuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24qIHN0cmVhbWFibGUoc3RyZWFtKSB7XG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygc3RyZWFtKSB7XG4gICAgaWYgKFwiY29tcGxldGlvblwiIGluIGNodW5rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gY2h1bmsuY29tcGxldGlvbjtcbiAgICAgIGlmICh0ZXh0KVxuICAgICAgICB5aWVsZCB0ZXh0O1xuICAgIH0gZWxzZSBpZiAoXCJkZWx0YVwiIGluIGNodW5rKSB7XG4gICAgICBjb25zdCB7IGRlbHRhIH0gPSBjaHVuaztcbiAgICAgIGlmIChcInRleHRcIiBpbiBkZWx0YSkge1xuICAgICAgICBjb25zdCB0ZXh0ID0gZGVsdGEudGV4dDtcbiAgICAgICAgaWYgKHRleHQpXG4gICAgICAgICAgeWllbGQgdGV4dDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIEFudGhyb3BpY1N0cmVhbShyZXMsIGNiKSB7XG4gIGlmIChTeW1ib2wuYXN5bmNJdGVyYXRvciBpbiByZXMpIHtcbiAgICByZXR1cm4gcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZShzdHJlYW1hYmxlKHJlcykpLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNiKSkucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBBSVN0cmVhbShyZXMsIHBhcnNlQW50aHJvcGljU3RyZWFtKCksIGNiKS5waXBlVGhyb3VnaChcbiAgICAgIGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpXG4gICAgKTtcbiAgfVxufVxuXG4vLyBzdHJlYW1zL2Fzc2lzdGFudC1yZXNwb25zZS50c1xuZnVuY3Rpb24gQXNzaXN0YW50UmVzcG9uc2UoeyB0aHJlYWRJZCwgbWVzc2FnZUlkIH0sIHByb2Nlc3MyKSB7XG4gIGNvbnN0IHN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICAgIGNvbnN0IHNlbmRNZXNzYWdlID0gKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShmb3JtYXRTdHJlYW1QYXJ0KFwiYXNzaXN0YW50X21lc3NhZ2VcIiwgbWVzc2FnZSkpXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2VuZERhdGFNZXNzYWdlID0gKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShmb3JtYXRTdHJlYW1QYXJ0KFwiZGF0YV9tZXNzYWdlXCIsIG1lc3NhZ2UpKVxuICAgICAgICApO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHNlbmRFcnJvciA9IChlcnJvck1lc3NhZ2UpID0+IHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShmb3JtYXRTdHJlYW1QYXJ0KFwiZXJyb3JcIiwgZXJyb3JNZXNzYWdlKSlcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBmb3J3YXJkU3RyZWFtID0gYXN5bmMgKHN0cmVhbTIpID0+IHtcbiAgICAgICAgdmFyIF9hMiwgX2I7XG4gICAgICAgIGxldCByZXN1bHQgPSB2b2lkIDA7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2Ygc3RyZWFtMikge1xuICAgICAgICAgIHN3aXRjaCAodmFsdWUuZXZlbnQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0aHJlYWQubWVzc2FnZS5jcmVhdGVkXCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQoXCJhc3Npc3RhbnRfbWVzc2FnZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiB2YWx1ZS5kYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBbeyB0eXBlOiBcInRleHRcIiwgdGV4dDogeyB2YWx1ZTogXCJcIiB9IH1dXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidGhyZWFkLm1lc3NhZ2UuZGVsdGFcIjoge1xuICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gKF9hMiA9IHZhbHVlLmRhdGEuZGVsdGEuY29udGVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMlswXTtcbiAgICAgICAgICAgICAgaWYgKChjb250ZW50ID09IG51bGwgPyB2b2lkIDAgOiBjb250ZW50LnR5cGUpID09PSBcInRleHRcIiAmJiAoKF9iID0gY29udGVudC50ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2IudmFsdWUpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQoXCJ0ZXh0XCIsIGNvbnRlbnQudGV4dC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRocmVhZC5ydW4uY29tcGxldGVkXCI6XG4gICAgICAgICAgICBjYXNlIFwidGhyZWFkLnJ1bi5yZXF1aXJlc19hY3Rpb25cIjoge1xuICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZS5kYXRhO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShcbiAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0KFwiYXNzaXN0YW50X2NvbnRyb2xfZGF0YVwiLCB7XG4gICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgIG1lc3NhZ2VJZFxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBwcm9jZXNzMih7XG4gICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgbWVzc2FnZUlkLFxuICAgICAgICAgIHNlbmRNZXNzYWdlLFxuICAgICAgICAgIHNlbmREYXRhTWVzc2FnZSxcbiAgICAgICAgICBmb3J3YXJkU3RyZWFtXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgc2VuZEVycm9yKChfYSA9IGVycm9yLm1lc3NhZ2UpICE9IG51bGwgPyBfYSA6IGAke2Vycm9yfWApO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcHVsbChjb250cm9sbGVyKSB7XG4gICAgfSxcbiAgICBjYW5jZWwoKSB7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG5ldyBSZXNwb25zZShzdHJlYW0sIHtcbiAgICBzdGF0dXM6IDIwMCxcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIlxuICAgIH1cbiAgfSk7XG59XG52YXIgZXhwZXJpbWVudGFsX0Fzc2lzdGFudFJlc3BvbnNlID0gQXNzaXN0YW50UmVzcG9uc2U7XG5cbi8vIHN0cmVhbXMvYXdzLWJlZHJvY2stc3RyZWFtLnRzXG5hc3luYyBmdW5jdGlvbiogYXNEZWx0YUl0ZXJhYmxlKHJlc3BvbnNlLCBleHRyYWN0VGV4dERlbHRhRnJvbUNodW5rKSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiAoX2EgPSByZXNwb25zZS5ib2R5KSAhPSBudWxsID8gX2EgOiBbXSkge1xuICAgIGNvbnN0IGJ5dGVzID0gKF9iID0gY2h1bmsuY2h1bmspID09IG51bGwgPyB2b2lkIDAgOiBfYi5ieXRlcztcbiAgICBpZiAoYnl0ZXMgIT0gbnVsbCkge1xuICAgICAgY29uc3QgY2h1bmtUZXh0ID0gZGVjb2Rlci5kZWNvZGUoYnl0ZXMpO1xuICAgICAgY29uc3QgY2h1bmtKU09OID0gSlNPTi5wYXJzZShjaHVua1RleHQpO1xuICAgICAgY29uc3QgZGVsdGEgPSBleHRyYWN0VGV4dERlbHRhRnJvbUNodW5rKGNodW5rSlNPTik7XG4gICAgICBpZiAoZGVsdGEgIT0gbnVsbCkge1xuICAgICAgICB5aWVsZCBkZWx0YTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIEFXU0JlZHJvY2tBbnRocm9waWNNZXNzYWdlc1N0cmVhbShyZXNwb25zZSwgY2FsbGJhY2tzKSB7XG4gIHJldHVybiBBV1NCZWRyb2NrU3RyZWFtKHJlc3BvbnNlLCBjYWxsYmFja3MsIChjaHVuaykgPT4ge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gY2h1bmsuZGVsdGEpID09IG51bGwgPyB2b2lkIDAgOiBfYS50ZXh0O1xuICB9KTtcbn1cbmZ1bmN0aW9uIEFXU0JlZHJvY2tBbnRocm9waWNTdHJlYW0ocmVzcG9uc2UsIGNhbGxiYWNrcykge1xuICByZXR1cm4gQVdTQmVkcm9ja1N0cmVhbShyZXNwb25zZSwgY2FsbGJhY2tzLCAoY2h1bmspID0+IGNodW5rLmNvbXBsZXRpb24pO1xufVxuZnVuY3Rpb24gQVdTQmVkcm9ja0NvaGVyZVN0cmVhbShyZXNwb25zZSwgY2FsbGJhY2tzKSB7XG4gIHJldHVybiBBV1NCZWRyb2NrU3RyZWFtKHJlc3BvbnNlLCBjYWxsYmFja3MsIChjaHVuaykgPT4gY2h1bmsgPT0gbnVsbCA/IHZvaWQgMCA6IGNodW5rLnRleHQpO1xufVxuZnVuY3Rpb24gQVdTQmVkcm9ja0xsYW1hMlN0cmVhbShyZXNwb25zZSwgY2FsbGJhY2tzKSB7XG4gIHJldHVybiBBV1NCZWRyb2NrU3RyZWFtKHJlc3BvbnNlLCBjYWxsYmFja3MsIChjaHVuaykgPT4gY2h1bmsuZ2VuZXJhdGlvbik7XG59XG5mdW5jdGlvbiBBV1NCZWRyb2NrU3RyZWFtKHJlc3BvbnNlLCBjYWxsYmFja3MsIGV4dHJhY3RUZXh0RGVsdGFGcm9tQ2h1bmspIHtcbiAgcmV0dXJuIHJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGUoXG4gICAgYXNEZWx0YUl0ZXJhYmxlKHJlc3BvbnNlLCBleHRyYWN0VGV4dERlbHRhRnJvbUNodW5rKVxuICApLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcykpLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpKTtcbn1cblxuLy8gc3RyZWFtcy9jb2hlcmUtc3RyZWFtLnRzXG52YXIgdXRmOERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoXCJ1dGYtOFwiKTtcbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NMaW5lcyhsaW5lcywgY29udHJvbGxlcikge1xuICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICBjb25zdCB7IHRleHQsIGlzX2ZpbmlzaGVkIH0gPSBKU09OLnBhcnNlKGxpbmUpO1xuICAgIGlmICghaXNfZmluaXNoZWQpIHtcbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh0ZXh0KTtcbiAgICB9XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHJlYWRBbmRQcm9jZXNzTGluZXMocmVhZGVyLCBjb250cm9sbGVyKSB7XG4gIGxldCBzZWdtZW50ID0gXCJcIjtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCB7IHZhbHVlOiBjaHVuaywgZG9uZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAoZG9uZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHNlZ21lbnQgKz0gdXRmOERlY29kZXIuZGVjb2RlKGNodW5rLCB7IHN0cmVhbTogdHJ1ZSB9KTtcbiAgICBjb25zdCBsaW5lc0FycmF5ID0gc2VnbWVudC5zcGxpdCgvXFxyXFxufFxcbnxcXHIvZyk7XG4gICAgc2VnbWVudCA9IGxpbmVzQXJyYXkucG9wKCkgfHwgXCJcIjtcbiAgICBhd2FpdCBwcm9jZXNzTGluZXMobGluZXNBcnJheSwgY29udHJvbGxlcik7XG4gIH1cbiAgaWYgKHNlZ21lbnQpIHtcbiAgICBjb25zdCBsaW5lc0FycmF5ID0gW3NlZ21lbnRdO1xuICAgIGF3YWl0IHByb2Nlc3NMaW5lcyhsaW5lc0FycmF5LCBjb250cm9sbGVyKTtcbiAgfVxuICBjb250cm9sbGVyLmNsb3NlKCk7XG59XG5mdW5jdGlvbiBjcmVhdGVQYXJzZXIyKHJlcykge1xuICB2YXIgX2E7XG4gIGNvbnN0IHJlYWRlciA9IChfYSA9IHJlcy5ib2R5KSA9PSBudWxsID8gdm9pZCAwIDogX2EuZ2V0UmVhZGVyKCk7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIGlmICghcmVhZGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYXdhaXQgcmVhZEFuZFByb2Nlc3NMaW5lcyhyZWFkZXIsIGNvbnRyb2xsZXIpO1xuICAgIH1cbiAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiogc3RyZWFtYWJsZTIoc3RyZWFtKSB7XG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygc3RyZWFtKSB7XG4gICAgaWYgKGNodW5rLmV2ZW50VHlwZSA9PT0gXCJ0ZXh0LWdlbmVyYXRpb25cIikge1xuICAgICAgY29uc3QgdGV4dCA9IGNodW5rLnRleHQ7XG4gICAgICBpZiAodGV4dClcbiAgICAgICAgeWllbGQgdGV4dDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIENvaGVyZVN0cmVhbShyZWFkZXIsIGNhbGxiYWNrcykge1xuICBpZiAoU3ltYm9sLmFzeW5jSXRlcmF0b3IgaW4gcmVhZGVyKSB7XG4gICAgcmV0dXJuIHJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGUoc3RyZWFtYWJsZTIocmVhZGVyKSkucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSkucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjcmVhdGVQYXJzZXIyKHJlYWRlcikucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSkucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkpO1xuICB9XG59XG5cbi8vIHN0cmVhbXMvZ29vZ2xlLWdlbmVyYXRpdmUtYWktc3RyZWFtLnRzXG5hc3luYyBmdW5jdGlvbiogc3RyZWFtYWJsZTMocmVzcG9uc2UpIHtcbiAgdmFyIF9hLCBfYiwgX2M7XG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgcmVzcG9uc2Uuc3RyZWFtKSB7XG4gICAgY29uc3QgcGFydHMgPSAoX2MgPSAoX2IgPSAoX2EgPSBjaHVuay5jYW5kaWRhdGVzKSA9PSBudWxsID8gdm9pZCAwIDogX2FbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfYi5jb250ZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2MucGFydHM7XG4gICAgaWYgKHBhcnRzID09PSB2b2lkIDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdFBhcnQgPSBwYXJ0c1swXTtcbiAgICBpZiAodHlwZW9mIGZpcnN0UGFydC50ZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB5aWVsZCBmaXJzdFBhcnQudGV4dDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIEdvb2dsZUdlbmVyYXRpdmVBSVN0cmVhbShyZXNwb25zZSwgY2IpIHtcbiAgcmV0dXJuIHJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGUoc3RyZWFtYWJsZTMocmVzcG9uc2UpKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYikpLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpKTtcbn1cblxuLy8gc3RyZWFtcy9odWdnaW5nZmFjZS1zdHJlYW0udHNcbmZ1bmN0aW9uIGNyZWF0ZVBhcnNlcjMocmVzKSB7XG4gIGNvbnN0IHRyaW1TdGFydE9mU3RyZWFtID0gdHJpbVN0YXJ0T2ZTdHJlYW1IZWxwZXIoKTtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgcmVzLm5leHQoKTtcbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdGV4dCA9IHRyaW1TdGFydE9mU3RyZWFtKChfYiA9IChfYSA9IHZhbHVlLnRva2VuKSA9PSBudWxsID8gdm9pZCAwIDogX2EudGV4dCkgIT0gbnVsbCA/IF9iIDogXCJcIik7XG4gICAgICBpZiAoIXRleHQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmICh2YWx1ZS5nZW5lcmF0ZWRfdGV4dCAhPSBudWxsICYmIHZhbHVlLmdlbmVyYXRlZF90ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRleHQgPT09IFwiPC9zPlwiIHx8IHRleHQgPT09IFwiPHxlbmRvZnRleHR8PlwiIHx8IHRleHQgPT09IFwiPHxlbmR8PlwiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh0ZXh0KTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gSHVnZ2luZ0ZhY2VTdHJlYW0ocmVzLCBjYWxsYmFja3MpIHtcbiAgcmV0dXJuIGNyZWF0ZVBhcnNlcjMocmVzKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSk7XG59XG5cbi8vIHN0cmVhbXMvaW5rZWVwLXN0cmVhbS50c1xuZnVuY3Rpb24gSW5rZWVwU3RyZWFtKHJlcywgY2FsbGJhY2tzKSB7XG4gIGlmICghcmVzLmJvZHkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXNwb25zZSBib2R5IGlzIG51bGxcIik7XG4gIH1cbiAgbGV0IGNoYXRfc2Vzc2lvbl9pZCA9IFwiXCI7XG4gIGxldCByZWNvcmRzX2NpdGVkO1xuICBjb25zdCBpbmtlZXBFdmVudFBhcnNlciA9IChkYXRhLCBvcHRpb25zKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCB7IGV2ZW50IH0gPSBvcHRpb25zO1xuICAgIGlmIChldmVudCA9PT0gXCJyZWNvcmRzX2NpdGVkXCIpIHtcbiAgICAgIHJlY29yZHNfY2l0ZWQgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgKF9hID0gY2FsbGJhY2tzID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25SZWNvcmRzQ2l0ZWQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKGNhbGxiYWNrcywgcmVjb3Jkc19jaXRlZCk7XG4gICAgfVxuICAgIGlmIChldmVudCA9PT0gXCJtZXNzYWdlX2NodW5rXCIpIHtcbiAgICAgIGNvbnN0IGlua2VlcE1lc3NhZ2VDaHVuayA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICBjaGF0X3Nlc3Npb25faWQgPSAoX2IgPSBpbmtlZXBNZXNzYWdlQ2h1bmsuY2hhdF9zZXNzaW9uX2lkKSAhPSBudWxsID8gX2IgOiBjaGF0X3Nlc3Npb25faWQ7XG4gICAgICByZXR1cm4gaW5rZWVwTWVzc2FnZUNodW5rLmNvbnRlbnRfY2h1bms7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfTtcbiAgbGV0IHsgb25SZWNvcmRzQ2l0ZWQsIC4uLnBhc3NUaHJvdWdoQ2FsbGJhY2tzIH0gPSBjYWxsYmFja3MgfHwge307XG4gIHBhc3NUaHJvdWdoQ2FsbGJhY2tzID0ge1xuICAgIC4uLnBhc3NUaHJvdWdoQ2FsbGJhY2tzLFxuICAgIG9uRmluYWw6IChjb21wbGV0aW9uKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBpbmtlZXBPbkZpbmFsTWV0YWRhdGEgPSB7XG4gICAgICAgIGNoYXRfc2Vzc2lvbl9pZCxcbiAgICAgICAgcmVjb3Jkc19jaXRlZFxuICAgICAgfTtcbiAgICAgIChfYSA9IGNhbGxiYWNrcyA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uRmluYWwpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKGNhbGxiYWNrcywgY29tcGxldGlvbiwgaW5rZWVwT25GaW5hbE1ldGFkYXRhKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBBSVN0cmVhbShyZXMsIGlua2VlcEV2ZW50UGFyc2VyLCBwYXNzVGhyb3VnaENhbGxiYWNrcykucGlwZVRocm91Z2goXG4gICAgY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKClcbiAgKTtcbn1cblxuLy8gc3RyZWFtcy9sYW5nY2hhaW4tYWRhcHRlci50c1xudmFyIGxhbmdjaGFpbl9hZGFwdGVyX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGxhbmdjaGFpbl9hZGFwdGVyX2V4cG9ydHMsIHtcbiAgdG9BSVN0cmVhbTogKCkgPT4gdG9BSVN0cmVhbVxufSk7XG5mdW5jdGlvbiB0b0FJU3RyZWFtKHN0cmVhbSwgY2FsbGJhY2tzKSB7XG4gIHJldHVybiBzdHJlYW0ucGlwZVRocm91Z2goXG4gICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICB0cmFuc2Zvcm06IGFzeW5jIChjaHVuaywgY29udHJvbGxlcikgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGNodW5rLmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmsuY29udGVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgY29udGVudCA9IGNodW5rLmNvbnRlbnQ7XG4gICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGNvbnRlbnQpIHtcbiAgICAgICAgICAgIGlmIChpdGVtLnR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShpdGVtLnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gICkucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSkucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkpO1xufVxuXG4vLyBzdHJlYW1zL2xhbmdjaGFpbi1zdHJlYW0udHNcbmZ1bmN0aW9uIExhbmdDaGFpblN0cmVhbShjYWxsYmFja3MpIHtcbiAgY29uc3Qgc3RyZWFtID0gbmV3IFRyYW5zZm9ybVN0cmVhbSgpO1xuICBjb25zdCB3cml0ZXIgPSBzdHJlYW0ud3JpdGFibGUuZ2V0V3JpdGVyKCk7XG4gIGNvbnN0IHJ1bnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBoYW5kbGVFcnJvciA9IGFzeW5jIChlLCBydW5JZCkgPT4ge1xuICAgIHJ1bnMuZGVsZXRlKHJ1bklkKTtcbiAgICBhd2FpdCB3cml0ZXIucmVhZHk7XG4gICAgYXdhaXQgd3JpdGVyLmFib3J0KGUpO1xuICB9O1xuICBjb25zdCBoYW5kbGVTdGFydCA9IGFzeW5jIChydW5JZCkgPT4ge1xuICAgIHJ1bnMuYWRkKHJ1bklkKTtcbiAgfTtcbiAgY29uc3QgaGFuZGxlRW5kID0gYXN5bmMgKHJ1bklkKSA9PiB7XG4gICAgcnVucy5kZWxldGUocnVuSWQpO1xuICAgIGlmIChydW5zLnNpemUgPT09IDApIHtcbiAgICAgIGF3YWl0IHdyaXRlci5yZWFkeTtcbiAgICAgIGF3YWl0IHdyaXRlci5jbG9zZSgpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBzdHJlYW06IHN0cmVhbS5yZWFkYWJsZS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSksXG4gICAgd3JpdGVyLFxuICAgIGhhbmRsZXJzOiB7XG4gICAgICBoYW5kbGVMTE1OZXdUb2tlbjogYXN5bmMgKHRva2VuKSA9PiB7XG4gICAgICAgIGF3YWl0IHdyaXRlci5yZWFkeTtcbiAgICAgICAgYXdhaXQgd3JpdGVyLndyaXRlKHRva2VuKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVMTE1TdGFydDogYXN5bmMgKF9sbG0sIF9wcm9tcHRzLCBydW5JZCkgPT4ge1xuICAgICAgICBoYW5kbGVTdGFydChydW5JZCk7XG4gICAgICB9LFxuICAgICAgaGFuZGxlTExNRW5kOiBhc3luYyAoX291dHB1dCwgcnVuSWQpID0+IHtcbiAgICAgICAgYXdhaXQgaGFuZGxlRW5kKHJ1bklkKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVMTE1FcnJvcjogYXN5bmMgKGUsIHJ1bklkKSA9PiB7XG4gICAgICAgIGF3YWl0IGhhbmRsZUVycm9yKGUsIHJ1bklkKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVDaGFpblN0YXJ0OiBhc3luYyAoX2NoYWluLCBfaW5wdXRzLCBydW5JZCkgPT4ge1xuICAgICAgICBoYW5kbGVTdGFydChydW5JZCk7XG4gICAgICB9LFxuICAgICAgaGFuZGxlQ2hhaW5FbmQ6IGFzeW5jIChfb3V0cHV0cywgcnVuSWQpID0+IHtcbiAgICAgICAgYXdhaXQgaGFuZGxlRW5kKHJ1bklkKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVDaGFpbkVycm9yOiBhc3luYyAoZSwgcnVuSWQpID0+IHtcbiAgICAgICAgYXdhaXQgaGFuZGxlRXJyb3IoZSwgcnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZVRvb2xTdGFydDogYXN5bmMgKF90b29sLCBfaW5wdXQsIHJ1bklkKSA9PiB7XG4gICAgICAgIGhhbmRsZVN0YXJ0KHJ1bklkKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVUb29sRW5kOiBhc3luYyAoX291dHB1dCwgcnVuSWQpID0+IHtcbiAgICAgICAgYXdhaXQgaGFuZGxlRW5kKHJ1bklkKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVUb29sRXJyb3I6IGFzeW5jIChlLCBydW5JZCkgPT4ge1xuICAgICAgICBhd2FpdCBoYW5kbGVFcnJvcihlLCBydW5JZCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG4vLyBzdHJlYW1zL21pc3RyYWwtc3RyZWFtLnRzXG5hc3luYyBmdW5jdGlvbiogc3RyZWFtYWJsZTQoc3RyZWFtKSB7XG4gIHZhciBfYSwgX2I7XG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygc3RyZWFtKSB7XG4gICAgY29uc3QgY29udGVudCA9IChfYiA9IChfYSA9IGNodW5rLmNob2ljZXNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfYS5kZWx0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNvbnRlbnQ7XG4gICAgaWYgKGNvbnRlbnQgPT09IHZvaWQgMCB8fCBjb250ZW50ID09PSBcIlwiKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgeWllbGQgY29udGVudDtcbiAgfVxufVxuZnVuY3Rpb24gTWlzdHJhbFN0cmVhbShyZXNwb25zZSwgY2FsbGJhY2tzKSB7XG4gIGNvbnN0IHN0cmVhbSA9IHJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGUoc3RyZWFtYWJsZTQocmVzcG9uc2UpKTtcbiAgcmV0dXJuIHN0cmVhbS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSk7XG59XG5cbi8vIHN0cmVhbXMvb3BlbmFpLXN0cmVhbS50c1xuZnVuY3Rpb24gcGFyc2VPcGVuQUlTdHJlYW0oKSB7XG4gIGNvbnN0IGV4dHJhY3QgPSBjaHVua1RvVGV4dCgpO1xuICByZXR1cm4gKGRhdGEpID0+IGV4dHJhY3QoSlNPTi5wYXJzZShkYXRhKSk7XG59XG5hc3luYyBmdW5jdGlvbiogc3RyZWFtYWJsZTUoc3RyZWFtKSB7XG4gIGNvbnN0IGV4dHJhY3QgPSBjaHVua1RvVGV4dCgpO1xuICBmb3IgYXdhaXQgKGxldCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICBpZiAoXCJwcm9tcHRGaWx0ZXJSZXN1bHRzXCIgaW4gY2h1bmspIHtcbiAgICAgIGNodW5rID0ge1xuICAgICAgICBpZDogY2h1bmsuaWQsXG4gICAgICAgIGNyZWF0ZWQ6IGNodW5rLmNyZWF0ZWQuZ2V0RGF0ZSgpLFxuICAgICAgICBvYmplY3Q6IGNodW5rLm9iamVjdCxcbiAgICAgICAgLy8gbm90IGV4cG9zZWQgYnkgQXp1cmUgQVBJXG4gICAgICAgIG1vZGVsOiBjaHVuay5tb2RlbCxcbiAgICAgICAgLy8gbm90IGV4cG9zZWQgYnkgQXp1cmUgQVBJXG4gICAgICAgIGNob2ljZXM6IGNodW5rLmNob2ljZXMubWFwKChjaG9pY2UpID0+IHtcbiAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlbHRhOiB7XG4gICAgICAgICAgICAgIGNvbnRlbnQ6IChfYSA9IGNob2ljZS5kZWx0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNvbnRlbnQsXG4gICAgICAgICAgICAgIGZ1bmN0aW9uX2NhbGw6IChfYiA9IGNob2ljZS5kZWx0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmZ1bmN0aW9uQ2FsbCxcbiAgICAgICAgICAgICAgcm9sZTogKF9jID0gY2hvaWNlLmRlbHRhKSA9PSBudWxsID8gdm9pZCAwIDogX2Mucm9sZSxcbiAgICAgICAgICAgICAgdG9vbF9jYWxsczogKChfZSA9IChfZCA9IGNob2ljZS5kZWx0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLnRvb2xDYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLmxlbmd0aCkgPyAoX2cgPSAoX2YgPSBjaG9pY2UuZGVsdGEpID09IG51bGwgPyB2b2lkIDAgOiBfZi50b29sQ2FsbHMpID09IG51bGwgPyB2b2lkIDAgOiBfZy5tYXAoKHRvb2xDYWxsLCBpbmRleCkgPT4gKHtcbiAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICBpZDogdG9vbENhbGwuaWQsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb246IHRvb2xDYWxsLmZ1bmN0aW9uLFxuICAgICAgICAgICAgICAgIHR5cGU6IHRvb2xDYWxsLnR5cGVcbiAgICAgICAgICAgICAgfSkpIDogdm9pZCAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmluaXNoX3JlYXNvbjogY2hvaWNlLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgIGluZGV4OiBjaG9pY2UuaW5kZXhcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgdGV4dCA9IGV4dHJhY3QoY2h1bmspO1xuICAgIGlmICh0ZXh0KVxuICAgICAgeWllbGQgdGV4dDtcbiAgfVxufVxuZnVuY3Rpb24gY2h1bmtUb1RleHQoKSB7XG4gIGNvbnN0IHRyaW1TdGFydE9mU3RyZWFtID0gdHJpbVN0YXJ0T2ZTdHJlYW1IZWxwZXIoKTtcbiAgbGV0IGlzRnVuY3Rpb25TdHJlYW1pbmdJbjtcbiAgcmV0dXJuIChqc29uKSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2ksIF9qLCBfaywgX2wsIF9tLCBfbiwgX28sIF9wLCBfcSwgX3I7XG4gICAgaWYgKGlzQ2hhdENvbXBsZXRpb25DaHVuayhqc29uKSkge1xuICAgICAgY29uc3QgZGVsdGEgPSAoX2EgPSBqc29uLmNob2ljZXNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfYS5kZWx0YTtcbiAgICAgIGlmICgoX2IgPSBkZWx0YS5mdW5jdGlvbl9jYWxsKSA9PSBudWxsID8gdm9pZCAwIDogX2IubmFtZSkge1xuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSB0cnVlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgY29udGVudDogYHtcImZ1bmN0aW9uX2NhbGxcIjoge1wibmFtZVwiOiBcIiR7ZGVsdGEuZnVuY3Rpb25fY2FsbC5uYW1lfVwiLCBcImFyZ3VtZW50c1wiOiBcImBcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoKF9lID0gKF9kID0gKF9jID0gZGVsdGEudG9vbF9jYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2QuZnVuY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfZS5uYW1lKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IHRydWU7XG4gICAgICAgIGNvbnN0IHRvb2xDYWxsID0gZGVsdGEudG9vbF9jYWxsc1swXTtcbiAgICAgICAgaWYgKHRvb2xDYWxsLmluZGV4ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgICBjb250ZW50OiBge1widG9vbF9jYWxsc1wiOlsge1wiaWRcIjogXCIke3Rvb2xDYWxsLmlkfVwiLCBcInR5cGVcIjogXCJmdW5jdGlvblwiLCBcImZ1bmN0aW9uXCI6IHtcIm5hbWVcIjogXCIkeyhfZiA9IHRvb2xDYWxsLmZ1bmN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2YubmFtZX1cIiwgXCJhcmd1bWVudHNcIjogXCJgXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IGBcIn19LCB7XCJpZFwiOiBcIiR7dG9vbENhbGwuaWR9XCIsIFwidHlwZVwiOiBcImZ1bmN0aW9uXCIsIFwiZnVuY3Rpb25cIjoge1wibmFtZVwiOiBcIiR7KF9nID0gdG9vbENhbGwuZnVuY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfZy5uYW1lfVwiLCBcImFyZ3VtZW50c1wiOiBcImBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKChfaCA9IGRlbHRhLmZ1bmN0aW9uX2NhbGwpID09IG51bGwgPyB2b2lkIDAgOiBfaC5hcmd1bWVudHMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6IGNsZWFudXBBcmd1bWVudHMoKF9pID0gZGVsdGEuZnVuY3Rpb25fY2FsbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9pLmFyZ3VtZW50cylcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoKF9sID0gKF9rID0gKF9qID0gZGVsdGEudG9vbF9jYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9qWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2suZnVuY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfbC5hcmd1bWVudHMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6IGNsZWFudXBBcmd1bWVudHMoKF9vID0gKF9uID0gKF9tID0gZGVsdGEudG9vbF9jYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9tWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX24uZnVuY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfby5hcmd1bWVudHMpXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb25TdHJlYW1pbmdJbiAmJiAoKChfcCA9IGpzb24uY2hvaWNlc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wLmZpbmlzaF9yZWFzb24pID09PSBcImZ1bmN0aW9uX2NhbGxcIiB8fCAoKF9xID0ganNvbi5jaG9pY2VzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3EuZmluaXNoX3JlYXNvbikgPT09IFwic3RvcFwiKSkge1xuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6ICdcIn19J1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gJiYgKChfciA9IGpzb24uY2hvaWNlc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yLmZpbmlzaF9yZWFzb24pID09PSBcInRvb2xfY2FsbHNcIikge1xuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6ICdcIn19XX0nXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRleHQgPSB0cmltU3RhcnRPZlN0cmVhbShcbiAgICAgIGlzQ2hhdENvbXBsZXRpb25DaHVuayhqc29uKSAmJiBqc29uLmNob2ljZXNbMF0uZGVsdGEuY29udGVudCA/IGpzb24uY2hvaWNlc1swXS5kZWx0YS5jb250ZW50IDogaXNDb21wbGV0aW9uKGpzb24pID8ganNvbi5jaG9pY2VzWzBdLnRleHQgOiBcIlwiXG4gICAgKTtcbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcbiAgZnVuY3Rpb24gY2xlYW51cEFyZ3VtZW50cyhhcmd1bWVudENodW5rKSB7XG4gICAgbGV0IGVzY2FwZWRQYXJ0aWFsSnNvbiA9IGFyZ3VtZW50Q2h1bmsucmVwbGFjZSgvXFxcXC9nLCBcIlxcXFxcXFxcXCIpLnJlcGxhY2UoL1xcLy9nLCBcIlxcXFwvXCIpLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKS5yZXBsYWNlKC9cXG4vZywgXCJcXFxcblwiKS5yZXBsYWNlKC9cXHIvZywgXCJcXFxcclwiKS5yZXBsYWNlKC9cXHQvZywgXCJcXFxcdFwiKS5yZXBsYWNlKC9cXGYvZywgXCJcXFxcZlwiKTtcbiAgICByZXR1cm4gYCR7ZXNjYXBlZFBhcnRpYWxKc29ufWA7XG4gIH1cbn1cbnZhciBfX2ludGVybmFsX19PcGVuQUlGbk1lc3NhZ2VzU3ltYm9sID0gU3ltYm9sKFxuICBcImludGVybmFsX29wZW5haV9mbl9tZXNzYWdlc1wiXG4pO1xuZnVuY3Rpb24gaXNDaGF0Q29tcGxldGlvbkNodW5rKGRhdGEpIHtcbiAgcmV0dXJuIFwiY2hvaWNlc1wiIGluIGRhdGEgJiYgZGF0YS5jaG9pY2VzICYmIGRhdGEuY2hvaWNlc1swXSAmJiBcImRlbHRhXCIgaW4gZGF0YS5jaG9pY2VzWzBdO1xufVxuZnVuY3Rpb24gaXNDb21wbGV0aW9uKGRhdGEpIHtcbiAgcmV0dXJuIFwiY2hvaWNlc1wiIGluIGRhdGEgJiYgZGF0YS5jaG9pY2VzICYmIGRhdGEuY2hvaWNlc1swXSAmJiBcInRleHRcIiBpbiBkYXRhLmNob2ljZXNbMF07XG59XG5mdW5jdGlvbiBPcGVuQUlTdHJlYW0ocmVzLCBjYWxsYmFja3MpIHtcbiAgY29uc3QgY2IgPSBjYWxsYmFja3M7XG4gIGxldCBzdHJlYW07XG4gIGlmIChTeW1ib2wuYXN5bmNJdGVyYXRvciBpbiByZXMpIHtcbiAgICBzdHJlYW0gPSByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlKHN0cmVhbWFibGU1KHJlcykpLnBpcGVUaHJvdWdoKFxuICAgICAgY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoXG4gICAgICAgIChjYiA9PSBudWxsID8gdm9pZCAwIDogY2IuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKSB8fCAoY2IgPT0gbnVsbCA/IHZvaWQgMCA6IGNiLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKSA/IHtcbiAgICAgICAgICAuLi5jYixcbiAgICAgICAgICBvbkZpbmFsOiB2b2lkIDBcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICAuLi5jYlxuICAgICAgICB9XG4gICAgICApXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0gPSBBSVN0cmVhbShcbiAgICAgIHJlcyxcbiAgICAgIHBhcnNlT3BlbkFJU3RyZWFtKCksXG4gICAgICAoY2IgPT0gbnVsbCA/IHZvaWQgMCA6IGNiLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCkgfHwgKGNiID09IG51bGwgPyB2b2lkIDAgOiBjYi5leHBlcmltZW50YWxfb25Ub29sQ2FsbCkgPyB7XG4gICAgICAgIC4uLmNiLFxuICAgICAgICBvbkZpbmFsOiB2b2lkIDBcbiAgICAgIH0gOiB7XG4gICAgICAgIC4uLmNiXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBpZiAoY2IgJiYgKGNiLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCB8fCBjYi5leHBlcmltZW50YWxfb25Ub29sQ2FsbCkpIHtcbiAgICBjb25zdCBmdW5jdGlvbkNhbGxUcmFuc2Zvcm1lciA9IGNyZWF0ZUZ1bmN0aW9uQ2FsbFRyYW5zZm9ybWVyKGNiKTtcbiAgICByZXR1cm4gc3RyZWFtLnBpcGVUaHJvdWdoKGZ1bmN0aW9uQ2FsbFRyYW5zZm9ybWVyKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyZWFtLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpKTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSB7XG4gIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIGxldCBpc0ZpcnN0Q2h1bmsgPSB0cnVlO1xuICBsZXQgYWdncmVnYXRlZFJlc3BvbnNlID0gXCJcIjtcbiAgbGV0IGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSA9IFwiXCI7XG4gIGxldCBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSBmYWxzZTtcbiAgbGV0IGZ1bmN0aW9uQ2FsbE1lc3NhZ2VzID0gY2FsbGJhY2tzW19faW50ZXJuYWxfX09wZW5BSUZuTWVzc2FnZXNTeW1ib2xdIHx8IFtdO1xuICBjb25zdCBkZWNvZGUgPSBjcmVhdGVDaHVua0RlY29kZXIoKTtcbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIGFzeW5jIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGRlY29kZShjaHVuayk7XG4gICAgICBhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UgKz0gbWVzc2FnZTtcbiAgICAgIGNvbnN0IHNob3VsZEhhbmRsZUFzRnVuY3Rpb24gPSBpc0ZpcnN0Q2h1bmsgJiYgKG1lc3NhZ2Uuc3RhcnRzV2l0aCgne1wiZnVuY3Rpb25fY2FsbFwiOicpIHx8IG1lc3NhZ2Uuc3RhcnRzV2l0aCgne1widG9vbF9jYWxsc1wiOicpKTtcbiAgICAgIGlmIChzaG91bGRIYW5kbGVBc0Z1bmN0aW9uKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IHRydWU7XG4gICAgICAgIGFnZ3JlZ2F0ZWRSZXNwb25zZSArPSBtZXNzYWdlO1xuICAgICAgICBpc0ZpcnN0Q2h1bmsgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0Z1bmN0aW9uU3RyZWFtaW5nSW4pIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShmb3JtYXRTdHJlYW1QYXJ0KFwidGV4dFwiLCBtZXNzYWdlKSlcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWdncmVnYXRlZFJlc3BvbnNlICs9IG1lc3NhZ2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBhc3luYyBmbHVzaChjb250cm9sbGVyKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIWlzRmlyc3RDaHVuayAmJiBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gJiYgKGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgfHwgY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKSkge1xuICAgICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKGFnZ3JlZ2F0ZWRSZXNwb25zZSk7XG4gICAgICAgICAgbGV0IG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzID0gW1xuICAgICAgICAgICAgLi4uZnVuY3Rpb25DYWxsTWVzc2FnZXNcbiAgICAgICAgICBdO1xuICAgICAgICAgIGxldCBmdW5jdGlvblJlc3BvbnNlID0gdm9pZCAwO1xuICAgICAgICAgIGlmIChjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKSB7XG4gICAgICAgICAgICBpZiAocGF5bG9hZC5mdW5jdGlvbl9jYWxsID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgIFwiZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHNob3VsZCBub3QgYmUgZGVmaW5lZCB3aGVuIHVzaW5nIHRvb2xzXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFyZ3VtZW50c1BheWxvYWQgPSBKU09OLnBhcnNlKFxuICAgICAgICAgICAgICBwYXlsb2FkLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZnVuY3Rpb25SZXNwb25zZSA9IGF3YWl0IGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwoXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXlsb2FkLmZ1bmN0aW9uX2NhbGwubmFtZSxcbiAgICAgICAgICAgICAgICBhcmd1bWVudHM6IGFyZ3VtZW50c1BheWxvYWRcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzID0gW1xuICAgICAgICAgICAgICAgICAgLi4uZnVuY3Rpb25DYWxsTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uX2NhbGw6IHBheWxvYWQuZnVuY3Rpb25fY2FsbFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBwYXlsb2FkLmZ1bmN0aW9uX2NhbGwubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogSlNPTi5zdHJpbmdpZnkocmVzdWx0KVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKSB7XG4gICAgICAgICAgICBjb25zdCB0b29sQ2FsbHMgPSB7XG4gICAgICAgICAgICAgIHRvb2xzOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdG9vbDIgb2YgcGF5bG9hZC50b29sX2NhbGxzKSB7XG4gICAgICAgICAgICAgIHRvb2xDYWxscy50b29scy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZDogdG9vbDIuaWQsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgIGZ1bmM6IHtcbiAgICAgICAgICAgICAgICAgIG5hbWU6IHRvb2wyLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IEpTT04ucGFyc2UodG9vbDIuZnVuY3Rpb24uYXJndW1lbnRzKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzcG9uc2VJbmRleCA9IDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmdW5jdGlvblJlc3BvbnNlID0gYXdhaXQgY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKFxuICAgICAgICAgICAgICAgIHRvb2xDYWxscyxcbiAgICAgICAgICAgICAgICAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdG9vbF9jYWxsX2lkLCBmdW5jdGlvbl9uYW1lLCB0b29sX2NhbGxfcmVzdWx0IH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzID0gW1xuICAgICAgICAgICAgICAgICAgICAgIC4uLm5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgYXBwZW5kIHRoZSBhc3Npc3RhbnQgbWVzc2FnZSBpZiBpdCdzIHRoZSBmaXJzdCByZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICAgIC4uLnJlc3BvbnNlSW5kZXggPT09IDAgPyBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xfY2FsbHM6IHBheWxvYWQudG9vbF9jYWxscy5tYXAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRjKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHRjLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGMuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2Ugc2VuZCB0aGUgYXJndW1lbnRzIGFuIG9iamVjdCB0byB0aGUgdXNlciwgYnV0IGFzIHRoZSBBUEkgZXhwZWN0cyBhIHN0cmluZywgd2UgbmVlZCB0byBzdHJpbmdpZnkgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0Yy5mdW5jdGlvbi5hcmd1bWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBdIDogW10sXG4gICAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBmdW5jdGlvbiBjYWxsIHJlc3VsdCBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm9sZTogXCJ0b29sXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sX2NhbGxfaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBmdW5jdGlvbl9uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogSlNPTi5zdHJpbmdpZnkodG9vbF9jYWxsX3Jlc3VsdClcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjYWxsaW5nIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsOlwiLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFmdW5jdGlvblJlc3BvbnNlKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0KFxuICAgICAgICAgICAgICAgICAgcGF5bG9hZC5mdW5jdGlvbl9jYWxsID8gXCJmdW5jdGlvbl9jYWxsXCIgOiBcInRvb2xfY2FsbHNcIixcbiAgICAgICAgICAgICAgICAgIC8vIHBhcnNlIHRvIHByZXZlbnQgZG91YmxlLWVuY29kaW5nOlxuICAgICAgICAgICAgICAgICAgSlNPTi5wYXJzZShhZ2dyZWdhdGVkUmVzcG9uc2UpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZ1bmN0aW9uUmVzcG9uc2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKGZvcm1hdFN0cmVhbVBhcnQoXCJ0ZXh0XCIsIGZ1bmN0aW9uUmVzcG9uc2UpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSA9IGZ1bmN0aW9uUmVzcG9uc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGZpbHRlcmVkQ2FsbGJhY2tzID0ge1xuICAgICAgICAgICAgLi4uY2FsbGJhY2tzLFxuICAgICAgICAgICAgb25TdGFydDogdm9pZCAwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjYWxsYmFja3Mub25GaW5hbCA9IHZvaWQgMDtcbiAgICAgICAgICBjb25zdCBvcGVuQUlTdHJlYW0gPSBPcGVuQUlTdHJlYW0oZnVuY3Rpb25SZXNwb25zZSwge1xuICAgICAgICAgICAgLi4uZmlsdGVyZWRDYWxsYmFja3MsXG4gICAgICAgICAgICBbX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbF06IG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgcmVhZGVyID0gb3BlbkFJU3RyZWFtLmdldFJlYWRlcigpO1xuICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGNhbGxiYWNrcy5vbkZpbmFsICYmIGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSkge1xuICAgICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vbkZpbmFsKGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzdHJlYW1zL3JlcGxpY2F0ZS1zdHJlYW0udHNcbmFzeW5jIGZ1bmN0aW9uIFJlcGxpY2F0ZVN0cmVhbShyZXMsIGNiLCBvcHRpb25zKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgdXJsID0gKF9hID0gcmVzLnVybHMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zdHJlYW07XG4gIGlmICghdXJsKSB7XG4gICAgaWYgKHJlcy5lcnJvcilcbiAgICAgIHRocm93IG5ldyBFcnJvcihyZXMuZXJyb3IpO1xuICAgIGVsc2VcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3Npbmcgc3RyZWFtIFVSTCBpbiBSZXBsaWNhdGUgcmVzcG9uc2VcIik7XG4gIH1cbiAgY29uc3QgZXZlbnRTdHJlYW0gPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgaGVhZGVyczoge1xuICAgICAgQWNjZXB0OiBcInRleHQvZXZlbnQtc3RyZWFtXCIsXG4gICAgICAuLi5vcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gQUlTdHJlYW0oZXZlbnRTdHJlYW0sIHZvaWQgMCwgY2IpLnBpcGVUaHJvdWdoKFxuICAgIGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpXG4gICk7XG59XG5cbi8vIHNoYXJlZC9wYXJzZS1jb21wbGV4LXJlc3BvbnNlLnRzXG5mdW5jdGlvbiBhc3NpZ25Bbm5vdGF0aW9uc1RvTWVzc2FnZShtZXNzYWdlLCBhbm5vdGF0aW9ucykge1xuICBpZiAoIW1lc3NhZ2UgfHwgIWFubm90YXRpb25zIHx8ICFhbm5vdGF0aW9ucy5sZW5ndGgpXG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIHJldHVybiB7IC4uLm1lc3NhZ2UsIGFubm90YXRpb25zOiBbLi4uYW5ub3RhdGlvbnNdIH07XG59XG5hc3luYyBmdW5jdGlvbiBwYXJzZUNvbXBsZXhSZXNwb25zZSh7XG4gIHJlYWRlcixcbiAgYWJvcnRDb250cm9sbGVyUmVmLFxuICB1cGRhdGUsXG4gIG9uRmluaXNoLFxuICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMiA9IGdlbmVyYXRlSWQsXG4gIGdldEN1cnJlbnREYXRlID0gKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKClcbn0pIHtcbiAgY29uc3QgY3JlYXRlZEF0ID0gZ2V0Q3VycmVudERhdGUoKTtcbiAgY29uc3QgcHJlZml4TWFwID0ge1xuICAgIGRhdGE6IFtdXG4gIH07XG4gIGxldCBtZXNzYWdlX2Fubm90YXRpb25zID0gdm9pZCAwO1xuICBmb3IgYXdhaXQgKGNvbnN0IHsgdHlwZSwgdmFsdWUgfSBvZiByZWFkRGF0YVN0cmVhbShyZWFkZXIsIHtcbiAgICBpc0Fib3J0ZWQ6ICgpID0+IChhYm9ydENvbnRyb2xsZXJSZWYgPT0gbnVsbCA/IHZvaWQgMCA6IGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50KSA9PT0gbnVsbFxuICB9KSkge1xuICAgIGlmICh0eXBlID09PSBcInRleHRcIikge1xuICAgICAgaWYgKHByZWZpeE1hcFtcInRleHRcIl0pIHtcbiAgICAgICAgcHJlZml4TWFwW1widGV4dFwiXSA9IHtcbiAgICAgICAgICAuLi5wcmVmaXhNYXBbXCJ0ZXh0XCJdLFxuICAgICAgICAgIGNvbnRlbnQ6IChwcmVmaXhNYXBbXCJ0ZXh0XCJdLmNvbnRlbnQgfHwgXCJcIikgKyB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJlZml4TWFwW1widGV4dFwiXSA9IHtcbiAgICAgICAgICBpZDogZ2VuZXJhdGVJZDIoKSxcbiAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgIGNvbnRlbnQ6IHZhbHVlLFxuICAgICAgICAgIGNyZWF0ZWRBdFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJ0b29sX2NhbGxcIikge1xuICAgICAgaWYgKHByZWZpeE1hcC50ZXh0ID09IG51bGwpIHtcbiAgICAgICAgcHJlZml4TWFwLnRleHQgPSB7XG4gICAgICAgICAgaWQ6IGdlbmVyYXRlSWQyKCksXG4gICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgICAgIGNyZWF0ZWRBdFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKHByZWZpeE1hcC50ZXh0LnRvb2xJbnZvY2F0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgIHByZWZpeE1hcC50ZXh0LnRvb2xJbnZvY2F0aW9ucyA9IFtdO1xuICAgICAgfVxuICAgICAgcHJlZml4TWFwLnRleHQudG9vbEludm9jYXRpb25zLnB1c2godmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ0b29sX3Jlc3VsdFwiKSB7XG4gICAgICBpZiAocHJlZml4TWFwLnRleHQgPT0gbnVsbCkge1xuICAgICAgICBwcmVmaXhNYXAudGV4dCA9IHtcbiAgICAgICAgICBpZDogZ2VuZXJhdGVJZDIoKSxcbiAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgICAgICAgY3JlYXRlZEF0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAocHJlZml4TWFwLnRleHQudG9vbEludm9jYXRpb25zID09IG51bGwpIHtcbiAgICAgICAgcHJlZml4TWFwLnRleHQudG9vbEludm9jYXRpb25zID0gW107XG4gICAgICB9XG4gICAgICBjb25zdCB0b29sSW52b2NhdGlvbkluZGV4ID0gcHJlZml4TWFwLnRleHQudG9vbEludm9jYXRpb25zLmZpbmRJbmRleChcbiAgICAgICAgKGludm9jYXRpb24pID0+IGludm9jYXRpb24udG9vbENhbGxJZCA9PT0gdmFsdWUudG9vbENhbGxJZFxuICAgICAgKTtcbiAgICAgIGlmICh0b29sSW52b2NhdGlvbkluZGV4ICE9PSAtMSkge1xuICAgICAgICBwcmVmaXhNYXAudGV4dC50b29sSW52b2NhdGlvbnNbdG9vbEludm9jYXRpb25JbmRleF0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZWZpeE1hcC50ZXh0LnRvb2xJbnZvY2F0aW9ucy5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGZ1bmN0aW9uQ2FsbE1lc3NhZ2UgPSBudWxsO1xuICAgIGlmICh0eXBlID09PSBcImZ1bmN0aW9uX2NhbGxcIikge1xuICAgICAgcHJlZml4TWFwW1wiZnVuY3Rpb25fY2FsbFwiXSA9IHtcbiAgICAgICAgaWQ6IGdlbmVyYXRlSWQyKCksXG4gICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgICAgIGZ1bmN0aW9uX2NhbGw6IHZhbHVlLmZ1bmN0aW9uX2NhbGwsXG4gICAgICAgIG5hbWU6IHZhbHVlLmZ1bmN0aW9uX2NhbGwubmFtZSxcbiAgICAgICAgY3JlYXRlZEF0XG4gICAgICB9O1xuICAgICAgZnVuY3Rpb25DYWxsTWVzc2FnZSA9IHByZWZpeE1hcFtcImZ1bmN0aW9uX2NhbGxcIl07XG4gICAgfVxuICAgIGxldCB0b29sQ2FsbE1lc3NhZ2UgPSBudWxsO1xuICAgIGlmICh0eXBlID09PSBcInRvb2xfY2FsbHNcIikge1xuICAgICAgcHJlZml4TWFwW1widG9vbF9jYWxsc1wiXSA9IHtcbiAgICAgICAgaWQ6IGdlbmVyYXRlSWQyKCksXG4gICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgICAgIHRvb2xfY2FsbHM6IHZhbHVlLnRvb2xfY2FsbHMsXG4gICAgICAgIGNyZWF0ZWRBdFxuICAgICAgfTtcbiAgICAgIHRvb2xDYWxsTWVzc2FnZSA9IHByZWZpeE1hcFtcInRvb2xfY2FsbHNcIl07XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcImRhdGFcIikge1xuICAgICAgcHJlZml4TWFwW1wiZGF0YVwiXS5wdXNoKC4uLnZhbHVlKTtcbiAgICB9XG4gICAgbGV0IHJlc3BvbnNlTWVzc2FnZSA9IHByZWZpeE1hcFtcInRleHRcIl07XG4gICAgaWYgKHR5cGUgPT09IFwibWVzc2FnZV9hbm5vdGF0aW9uc1wiKSB7XG4gICAgICBpZiAoIW1lc3NhZ2VfYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgbWVzc2FnZV9hbm5vdGF0aW9ucyA9IFsuLi52YWx1ZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXNzYWdlX2Fubm90YXRpb25zLnB1c2goLi4udmFsdWUpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb25DYWxsTWVzc2FnZSA9IGFzc2lnbkFubm90YXRpb25zVG9NZXNzYWdlKFxuICAgICAgICBwcmVmaXhNYXBbXCJmdW5jdGlvbl9jYWxsXCJdLFxuICAgICAgICBtZXNzYWdlX2Fubm90YXRpb25zXG4gICAgICApO1xuICAgICAgdG9vbENhbGxNZXNzYWdlID0gYXNzaWduQW5ub3RhdGlvbnNUb01lc3NhZ2UoXG4gICAgICAgIHByZWZpeE1hcFtcInRvb2xfY2FsbHNcIl0sXG4gICAgICAgIG1lc3NhZ2VfYW5ub3RhdGlvbnNcbiAgICAgICk7XG4gICAgICByZXNwb25zZU1lc3NhZ2UgPSBhc3NpZ25Bbm5vdGF0aW9uc1RvTWVzc2FnZShcbiAgICAgICAgcHJlZml4TWFwW1widGV4dFwiXSxcbiAgICAgICAgbWVzc2FnZV9hbm5vdGF0aW9uc1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2VfYW5ub3RhdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG1lc3NhZ2VfYW5ub3RhdGlvbnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBtZXNzYWdlUHJlZml4S2V5cyA9IFtcbiAgICAgICAgXCJ0ZXh0XCIsXG4gICAgICAgIFwiZnVuY3Rpb25fY2FsbFwiLFxuICAgICAgICBcInRvb2xfY2FsbHNcIlxuICAgICAgXTtcbiAgICAgIG1lc3NhZ2VQcmVmaXhLZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBpZiAocHJlZml4TWFwW2tleV0pIHtcbiAgICAgICAgICBwcmVmaXhNYXBba2V5XS5hbm5vdGF0aW9ucyA9IFsuLi5tZXNzYWdlX2Fubm90YXRpb25zXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG1lcmdlZCA9IFtmdW5jdGlvbkNhbGxNZXNzYWdlLCB0b29sQ2FsbE1lc3NhZ2UsIHJlc3BvbnNlTWVzc2FnZV0uZmlsdGVyKEJvb2xlYW4pLm1hcCgobWVzc2FnZSkgPT4gKHtcbiAgICAgIC4uLmFzc2lnbkFubm90YXRpb25zVG9NZXNzYWdlKG1lc3NhZ2UsIG1lc3NhZ2VfYW5ub3RhdGlvbnMpXG4gICAgfSkpO1xuICAgIHVwZGF0ZShtZXJnZWQsIFsuLi5wcmVmaXhNYXBbXCJkYXRhXCJdXSk7XG4gIH1cbiAgb25GaW5pc2ggPT0gbnVsbCA/IHZvaWQgMCA6IG9uRmluaXNoKHByZWZpeE1hcCk7XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZXM6IFtcbiAgICAgIHByZWZpeE1hcC50ZXh0LFxuICAgICAgcHJlZml4TWFwLmZ1bmN0aW9uX2NhbGwsXG4gICAgICBwcmVmaXhNYXAudG9vbF9jYWxsc1xuICAgIF0uZmlsdGVyKEJvb2xlYW4pLFxuICAgIGRhdGE6IHByZWZpeE1hcC5kYXRhXG4gIH07XG59XG5cbi8vIHN0cmVhbXMvc3RyZWFtaW5nLXJlYWN0LXJlc3BvbnNlLnRzXG52YXIgZXhwZXJpbWVudGFsX1N0cmVhbWluZ1JlYWN0UmVzcG9uc2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHJlcywgb3B0aW9ucykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgbGV0IHJlc29sdmVGdW5jID0gKCkgPT4ge1xuICAgIH07XG4gICAgbGV0IG5leHQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgcmVzb2x2ZUZ1bmMgPSByZXNvbHZlO1xuICAgIH0pO1xuICAgIGNvbnN0IHByb2Nlc3NlZFN0cmVhbSA9IChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmRhdGEpICE9IG51bGwgPyByZXMucGlwZVRocm91Z2goKF9hID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5kYXRhKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc3RyZWFtKSA6IHJlcztcbiAgICBsZXQgbGFzdFBheWxvYWQgPSB2b2lkIDA7XG4gICAgcGFyc2VDb21wbGV4UmVzcG9uc2Uoe1xuICAgICAgcmVhZGVyOiBwcm9jZXNzZWRTdHJlYW0uZ2V0UmVhZGVyKCksXG4gICAgICB1cGRhdGU6IChtZXJnZWQsIGRhdGEpID0+IHtcbiAgICAgICAgdmFyIF9hMiwgX2IyLCBfYztcbiAgICAgICAgY29uc3QgY29udGVudCA9IChfYjIgPSAoX2EyID0gbWVyZ2VkWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmNvbnRlbnQpICE9IG51bGwgPyBfYjIgOiBcIlwiO1xuICAgICAgICBjb25zdCB1aSA9ICgoX2MgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnVpKSA9PSBudWxsID8gdm9pZCAwIDogX2MuY2FsbChvcHRpb25zLCB7IGNvbnRlbnQsIGRhdGEgfSkpIHx8IGNvbnRlbnQ7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7IHVpLCBjb250ZW50IH07XG4gICAgICAgIGNvbnN0IHJlc29sdmVQcmV2aW91cyA9IHJlc29sdmVGdW5jO1xuICAgICAgICBjb25zdCBuZXh0Um93ID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICByZXNvbHZlRnVuYyA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXNvbHZlUHJldmlvdXMoe1xuICAgICAgICAgIG5leHQ6IG5leHRSb3csXG4gICAgICAgICAgLi4ucGF5bG9hZFxuICAgICAgICB9KTtcbiAgICAgICAgbGFzdFBheWxvYWQgPSBwYXlsb2FkO1xuICAgICAgfSxcbiAgICAgIGdlbmVyYXRlSWQ6IChfYiA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZ2VuZXJhdGVJZCkgIT0gbnVsbCA/IF9iIDogZ2VuZXJhdGVJZCxcbiAgICAgIG9uRmluaXNoOiAoKSA9PiB7XG4gICAgICAgIGlmIChsYXN0UGF5bG9hZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmVzb2x2ZUZ1bmMoe1xuICAgICAgICAgICAgbmV4dDogbnVsbCxcbiAgICAgICAgICAgIC4uLmxhc3RQYXlsb2FkXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxufTtcblxuLy8gc3RyZWFtcy9zdHJlYW1pbmctdGV4dC1yZXNwb25zZS50c1xudmFyIFN0cmVhbWluZ1RleHRSZXNwb25zZSA9IGNsYXNzIGV4dGVuZHMgUmVzcG9uc2Uge1xuICBjb25zdHJ1Y3RvcihyZXMsIGluaXQsIGRhdGEpIHtcbiAgICBsZXQgcHJvY2Vzc2VkU3RyZWFtID0gcmVzO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICBwcm9jZXNzZWRTdHJlYW0gPSByZXMucGlwZVRocm91Z2goZGF0YS5zdHJlYW0pO1xuICAgIH1cbiAgICBzdXBlcihwcm9jZXNzZWRTdHJlYW0sIHtcbiAgICAgIC4uLmluaXQsXG4gICAgICBzdGF0dXM6IDIwMCxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgICAgIC4uLmluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuaGVhZGVyc1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuZnVuY3Rpb24gc3RyZWFtVG9SZXNwb25zZShyZXMsIHJlc3BvbnNlLCBpbml0KSB7XG4gIHJlc3BvbnNlLndyaXRlSGVhZCgoaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXMpIHx8IDIwMCwge1xuICAgIFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiLFxuICAgIC4uLmluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuaGVhZGVyc1xuICB9KTtcbiAgY29uc3QgcmVhZGVyID0gcmVzLmdldFJlYWRlcigpO1xuICBmdW5jdGlvbiByZWFkKCkge1xuICAgIHJlYWRlci5yZWFkKCkudGhlbigoeyBkb25lLCB2YWx1ZSB9KSA9PiB7XG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICByZXNwb25zZS5lbmQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVzcG9uc2Uud3JpdGUodmFsdWUpO1xuICAgICAgcmVhZCgpO1xuICAgIH0pO1xuICB9XG4gIHJlYWQoKTtcbn1cbmV4cG9ydCB7XG4gIEFJU3RyZWFtLFxuICBBUElDYWxsRXJyb3IyIGFzIEFQSUNhbGxFcnJvcixcbiAgQVdTQmVkcm9ja0FudGhyb3BpY01lc3NhZ2VzU3RyZWFtLFxuICBBV1NCZWRyb2NrQW50aHJvcGljU3RyZWFtLFxuICBBV1NCZWRyb2NrQ29oZXJlU3RyZWFtLFxuICBBV1NCZWRyb2NrTGxhbWEyU3RyZWFtLFxuICBBV1NCZWRyb2NrU3RyZWFtLFxuICBBbnRocm9waWNTdHJlYW0sXG4gIEFzc2lzdGFudFJlc3BvbnNlLFxuICBDb2hlcmVTdHJlYW0sXG4gIEVtYmVkUmVzdWx0LFxuICBFbXB0eVJlc3BvbnNlQm9keUVycm9yLFxuICBHZW5lcmF0ZU9iamVjdFJlc3VsdCxcbiAgR2VuZXJhdGVUZXh0UmVzdWx0LFxuICBHb29nbGVHZW5lcmF0aXZlQUlTdHJlYW0sXG4gIEh1Z2dpbmdGYWNlU3RyZWFtLFxuICBJbmtlZXBTdHJlYW0sXG4gIEludmFsaWRBcmd1bWVudEVycm9yMiBhcyBJbnZhbGlkQXJndW1lbnRFcnJvcixcbiAgSW52YWxpZERhdGFDb250ZW50RXJyb3IyIGFzIEludmFsaWREYXRhQ29udGVudEVycm9yLFxuICBJbnZhbGlkUHJvbXB0RXJyb3IyIGFzIEludmFsaWRQcm9tcHRFcnJvcixcbiAgSW52YWxpZFJlc3BvbnNlRGF0YUVycm9yLFxuICBJbnZhbGlkVG9vbEFyZ3VtZW50c0Vycm9yMiBhcyBJbnZhbGlkVG9vbEFyZ3VtZW50c0Vycm9yLFxuICBKU09OUGFyc2VFcnJvcixcbiAgbGFuZ2NoYWluX2FkYXB0ZXJfZXhwb3J0cyBhcyBMYW5nQ2hhaW5BZGFwdGVyLFxuICBMYW5nQ2hhaW5TdHJlYW0sXG4gIExvYWRBUElLZXlFcnJvcixcbiAgTWlzdHJhbFN0cmVhbSxcbiAgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcjIgYXMgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcixcbiAgTm9TdWNoVG9vbEVycm9yMyBhcyBOb1N1Y2hUb29sRXJyb3IsXG4gIE9wZW5BSVN0cmVhbSxcbiAgUmVwbGljYXRlU3RyZWFtLFxuICBSZXRyeUVycm9yMiBhcyBSZXRyeUVycm9yLFxuICBTdHJlYW1EYXRhLFxuICBTdHJlYW1PYmplY3RSZXN1bHQsXG4gIFN0cmVhbVRleHRSZXN1bHQsXG4gIFN0cmVhbWluZ1RleHRSZXNwb25zZSxcbiAgVG9vbENhbGxQYXJzZUVycm9yLFxuICBUeXBlVmFsaWRhdGlvbkVycm9yLFxuICBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcixcbiAgVW5zdXBwb3J0ZWRKU09OU2NoZW1hRXJyb3IsXG4gIGNvbnZlcnREYXRhQ29udGVudFRvQmFzZTY0U3RyaW5nLFxuICBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXksXG4gIGNvbnZlcnRUb0NvcmVNZXNzYWdlcyxcbiAgY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIsXG4gIGNyZWF0ZUNodW5rRGVjb2RlcixcbiAgY3JlYXRlRXZlbnRTdHJlYW1UcmFuc2Zvcm1lcixcbiAgY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyLFxuICBlbWJlZCxcbiAgZXhwZXJpbWVudGFsX0Fzc2lzdGFudFJlc3BvbnNlLFxuICBleHBlcmltZW50YWxfU3RyZWFtRGF0YSxcbiAgZXhwZXJpbWVudGFsX1N0cmVhbWluZ1JlYWN0UmVzcG9uc2UsXG4gIGV4cGVyaW1lbnRhbF9nZW5lcmF0ZU9iamVjdCxcbiAgZXhwZXJpbWVudGFsX2dlbmVyYXRlVGV4dCxcbiAgZXhwZXJpbWVudGFsX3N0cmVhbU9iamVjdCxcbiAgZXhwZXJpbWVudGFsX3N0cmVhbVRleHQsXG4gIGZvcm1hdFN0cmVhbVBhcnQsXG4gIGdlbmVyYXRlSWQsXG4gIGdlbmVyYXRlT2JqZWN0LFxuICBnZW5lcmF0ZVRleHQsXG4gIGlzU3RyZWFtU3RyaW5nRXF1YWxUb1R5cGUsXG4gIGdlbmVyYXRlSWQgYXMgbmFub2lkLFxuICBwYXJzZVN0cmVhbVBhcnQsXG4gIHJlYWREYXRhU3RyZWFtLFxuICByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlLFxuICBzdHJlYW1PYmplY3QsXG4gIHN0cmVhbVRleHQsXG4gIHN0cmVhbVRvUmVzcG9uc2UsXG4gIHRvb2wsXG4gIHRyaW1TdGFydE9mU3RyZWFtSGVscGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ai/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/ai/node_modules/nanoid/non-secure/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ai/node_modules/nanoid/non-secure/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   customAlphabet: () => (/* binding */ customAlphabet),\n/* harmony export */   nanoid: () => (/* binding */ nanoid)\n/* harmony export */ });\nlet urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nlet customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = ''\n    let i = size\n    while (i--) {\n      id += alphabet[(Math.random() * alphabet.length) | 0]\n    }\n    return id\n  }\n}\nlet nanoid = (size = 21) => {\n  let id = ''\n  let i = size\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0]\n  }\n  return id\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWkvbm9kZV9tb2R1bGVzL25hbm9pZC9ub24tc2VjdXJlL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FhLy4vbm9kZV9tb2R1bGVzL2FpL25vZGVfbW9kdWxlcy9uYW5vaWQvbm9uLXNlY3VyZS9pbmRleC5qcz82NzMzIl0sInNvdXJjZXNDb250ZW50IjpbImxldCB1cmxBbHBoYWJldCA9XG4gICd1c2VhbmRvbS0yNlQxOTgzNDBQWDc1cHhKQUNLVkVSWU1JTkRCVVNIV09MRl9HUVpiZmdoamtscXZ3eXpyaWN0J1xubGV0IGN1c3RvbUFscGhhYmV0ID0gKGFscGhhYmV0LCBkZWZhdWx0U2l6ZSA9IDIxKSA9PiB7XG4gIHJldHVybiAoc2l6ZSA9IGRlZmF1bHRTaXplKSA9PiB7XG4gICAgbGV0IGlkID0gJydcbiAgICBsZXQgaSA9IHNpemVcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBpZCArPSBhbHBoYWJldFsoTWF0aC5yYW5kb20oKSAqIGFscGhhYmV0Lmxlbmd0aCkgfCAwXVxuICAgIH1cbiAgICByZXR1cm4gaWRcbiAgfVxufVxubGV0IG5hbm9pZCA9IChzaXplID0gMjEpID0+IHtcbiAgbGV0IGlkID0gJydcbiAgbGV0IGkgPSBzaXplXG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZCArPSB1cmxBbHBoYWJldFsoTWF0aC5yYW5kb20oKSAqIDY0KSB8IDBdXG4gIH1cbiAgcmV0dXJuIGlkXG59XG5leHBvcnQgeyBuYW5vaWQsIGN1c3RvbUFscGhhYmV0IH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ai/node_modules/nanoid/non-secure/index.js\n");

/***/ })

};
;